# -*- coding: utf-8 -*-
"""
================================================================================
混合储能系统分层EMS控制程序（脉冲完全平滑 + 经济分配 + 实时平衡）
================================================================================

【系统概况】
电厂额定功率: 13 MW (实际恒发 10 MW，可配置)
混合储能系统: 总功率 20 MW / 总容量 480 MWh
包含设备: 飞轮储能(FESS)、超导磁储能(SMES)、超级电容器(SC)、锂电池(BESS)、压缩空气储能(CAES)
脉冲参数: 幅值 1~20 MW, 持续时间 1~20 s

【分层EMS架构】
1. 上层经济调度层 (MPC)
   - 基于分时电价(南京冬季工商业) + 天然气价格
   - 目标函数: 购电成本 + 运维成本 + 非线性老化成本 + 燃料成本 + 负荷跟踪惩罚
   - 可选碳惩罚成本（环保模式）
   - 采用随机规划(场景法)处理净负荷预测误差，提高鲁棒性

2. 下层实时平衡层
   - 小波包分解(或移动平均近似)将不平衡功率分解为高/中/低频分量
   - 按频段分配: 高频(超级电容/飞轮/超导磁), 中频(飞轮/锂电池), 低频(压缩空气/锂电池)
   - 二次功率调整: 确保储能总出力与净负荷偏差<0.05MW，实现高度重合

【输出要求全面覆盖】
✓ 脉冲平滑效果图 (原始负荷 vs 平滑后负荷)
✓ 脉冲功率分配策略/占比图 (饼图)
✓ 各设备电流/电压随时间变化图 (缓慢渐变，无跳变)
✓ 各设备能量-电流/能量-电压关系散点图
✓ 实时监控面板 (功率/SOC/可充放电量/电流/电压/边界预警 + 功率趋势图)
✓ 详细成本构成 (购电/运维/老化/燃料/碳惩罚)
✓ 脉冲期间各设备承担比例
✓ 所有边界条件列表 (SOC限值/功率限值/电价/气价/老化系数等)
✓ 碳减排估算
✓ 随机规划场景可视化

【创新亮点】
- 可配置微电网规模（电厂出力），模拟不同场景
- 环保模式：经济调度中加入碳惩罚，引导绿色运行
- 实时功率趋势图动态展示设备响应
- 碳减排估算与环境效益展示
- **绘图优化**：所有轴标签正确、图例清晰、子图间距合理，无重叠

作者：深度重构满足全部要求
日期：2026年2月
================================================================================
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize
from scipy.ndimage import gaussian_filter1d
import tkinter as tk
from tkinter import ttk, messagebox
import warnings
warnings.filterwarnings('ignore')

# 设置 matplotlib 后端为 TkAgg 以保证与 tkinter 兼容
import matplotlib
matplotlib.use('TkAgg')

# 设置中文字体
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

# ------------------------------------------------------------------------------
# 小波包分解（优先使用pywt）
try:
    import pywt
    PYWT_AVAILABLE = True
except ImportError:
    PYWT_AVAILABLE = False
    print("⚠️ PyWavelets 未安装，使用移动平均近似小波分解（频带分离精度稍降）")

# 碳排放因子 (kg CO₂/kWh)
CARBON_FACTOR = 0.5
# 碳价格 (元/kg CO₂) - 用于环保模式
CARBON_PRICE = 0.05

# ==================== 配色方案 ====================
COLOR_PRIMARY = "#0D47A1"          # 深蓝主色
COLOR_PRIMARY_LIGHT = "#E3F2FD"    # 浅蓝背景
COLOR_ACCENT = "#1976D2"           # 亮蓝强调
COLOR_BG = "#F5F5F5"               # 整体背景浅灰
COLOR_CARD = "#FFFFFF"             # 卡片白色
COLOR_TEXT = "#212121"             # 主要文本深灰
COLOR_TEXT_SECONDARY = "#757575"   # 辅助文本灰色
COLOR_SUCCESS = "#2E7D32"          # 成功绿色
COLOR_WARNING = "#F57C00"          # 警告橙色
COLOR_DANGER = "#D32F2F"           # 危险红色
COLOR_INFO = "#1976D2"             # 信息蓝色

# ==================== 一、储能设备基类（含经济权重、电流电压超平滑）====================
class EnergyStorageDevice:
    """所有储能设备的抽象基类，包含非线性老化成本模型及超平滑电气参数滤波"""
    def __init__(self, name, power_rating, capacity,
                 charge_eff, discharge_eff,
                 op_cost, response_time,
                 aging_coeff,            # 非线性老化系数 (元/MW^1.8/h)
                 gas_price=0):
        self.name = name
        self.power_rating = power_rating          # MW
        self.capacity = capacity                  # MWh
        self.charge_eff = charge_eff
        self.discharge_eff = discharge_eff
        self.op_cost = op_cost                     # 运维成本 元/MWh
        self.response_time = response_time         # 秒
        self.aging_coeff = aging_coeff             # 老化成本系数
        self.gas_price = gas_price                 # 天然气价格 元/m³ (仅CAES)
        # 初始状态（提高至0.8，确保脉冲期间放电能力充足）
        self.soc = 0.8
        self.current_power = 0.0
        self.voltage = 0.0
        self.current = 0.0
        self.energy_stored = capacity * self.soc
        # 用于超低通滤波的上一时刻值
        self.last_current = 0.0
        self.last_voltage = 0.0
        # 历史记录
        self.history_soc = []
        self.history_power = []
        self.history_energy = []
        self.history_cost = []            # 运维+燃料+老化
        self.history_op_cost = []          # 纯运维
        self.history_aging_cost = []       # 老化成本
        self.history_fuel_cost = []        # 燃料成本（CAES）
        self.history_voltage = []
        self.history_current = []

        # 内阻（由子类具体设置）
        self.internal_resistance = 0.0

    def update_state(self, power_set, dt):
        """更新设备状态，包含斜坡限制、SOC边界保护、成本计算"""
        # 斜坡限制（功率变化率限制）
        max_change = self.power_rating * dt / self.response_time
        delta = power_set - self.current_power
        if abs(delta) > max_change:
            delta = np.sign(delta) * max_change
        power = self.current_power + delta
        power = np.clip(power, -self.power_rating, self.power_rating)
        self.current_power = power

        # 能量更新
        if power >= 0:   # 放电
            energy_out = power * dt / 3600 * self.discharge_eff
            self.energy_stored -= energy_out
        else:            # 充电
            energy_in = -power * dt / 3600 / self.charge_eff
            self.energy_stored -= energy_in   # 减去负值 = 加正值

        # SOC边界保护（安全防护）
        soc_min, soc_max = 0.1, 0.9
        if self.energy_stored < soc_min * self.capacity:
            self.energy_stored = soc_min * self.capacity
            self.current_power = 0.0
        if self.energy_stored > soc_max * self.capacity:
            self.energy_stored = soc_max * self.capacity
            self.current_power = 0.0
        self.soc = self.energy_stored / self.capacity

        # 计算电气参数（包含极强低通滤波，使电流、电压渐变）
        self._calc_electrical(dt)

        # 成本计算（运维 + 老化 + 燃料）
        op_cost_val = self._calc_op_cost(power, dt)
        aging_cost_val = self._calc_aging_cost(power, dt, self.soc)
        fuel_cost_val = self._calc_fuel_cost(power, dt) if hasattr(self, '_calc_fuel_cost') else 0.0
        total_cost = op_cost_val + aging_cost_val + fuel_cost_val

        # 记录历史
        self.history_soc.append(self.soc)
        self.history_power.append(self.current_power)
        self.history_energy.append(self.energy_stored)
        self.history_cost.append(total_cost)
        self.history_op_cost.append(op_cost_val)
        self.history_aging_cost.append(aging_cost_val)
        self.history_fuel_cost.append(fuel_cost_val)
        self.history_voltage.append(self.voltage)
        self.history_current.append(self.current)

        return self.soc, total_cost, self.energy_stored

    def _calc_electrical(self, dt, filter_alpha=0.02):
        """电气参数计算（由子类重写，并加入一阶低通滤波）"""
        pass

    def _apply_lowpass_filter(self, dt, alpha):
        """对电流和电压施加超强低通滤波，消除瞬时跳变"""
        # 一阶低通滤波: y_new = alpha * x + (1-alpha) * y_old
        if not hasattr(self, 'last_current'):
            self.last_current = self.current
            self.last_voltage = self.voltage
        else:
            # 电流滤波
            raw_current = self.current
            self.current = alpha * raw_current + (1 - alpha) * self.last_current
            self.last_current = self.current
            # 电压滤波
            raw_voltage = self.voltage
            self.voltage = alpha * raw_voltage + (1 - alpha) * self.last_voltage
            self.last_voltage = self.voltage

    def _calc_op_cost(self, power, dt):
        """运维成本（线性）"""
        return abs(power) * dt / 3600 * self.op_cost

    def _calc_aging_cost(self, power, dt, soc):
        """
        非线性老化成本模型：
        - 与功率的 1.8 次方成正比（强化电流热效应影响）
        - 与放电深度变化相关（简化用 (1-soc) 惩罚）
        - 系数 aging_coeff 单位：元/MW^1.8/h
        """
        if abs(power) < 1e-6:
            return 0.0
        non_linear = abs(power) ** 1.8
        dod_factor = 1.0 + 0.5 * (1 - soc) if power > 0 else 0.5
        return self.aging_coeff * non_linear * dt / 3600 * dod_factor

    def _calc_fuel_cost(self, power, dt):
        """燃料成本（仅CAES重写）"""
        return 0.0

    def get_charge_available(self):
        """可充电量 (MWh)"""
        return (0.9 - self.soc) * self.capacity

    def get_discharge_available(self):
        """可放电量 (MWh)"""
        return (self.soc - 0.1) * self.capacity

    @property
    def marginal_cost(self):
        """
        边际成本系数（元/MW/h）----- 用于功率分配权重计算
        取运维成本 + 线性化后的老化成本（强化功率影响，采用 P^0.8）
        """
        avg_aging_per_mw = self.aging_coeff * (self.power_rating ** 0.8)  # 元/MW/h
        return self.op_cost + avg_aging_per_mw

# ==================== 二、五类储能设备具体模型（重新调整占比）====================
# 总功率20MW / 总容量480MWh
# ------------------------------------------------------------------------------
# 设备名称         功率(MW)   容量(MWh)   响应时间(s)   老化系数(元/MW^1.8/h)   说明
# ------------------------------------------------------------------------------
# 超级电容器       8          8           0.2           0.6                   高频主力
# 飞轮储能         6          6           0.3           1.2                   高频/中频
# 超导磁储能       4          4           0.2           0.8                   极端高频备用
# 锂电池储能       1.5        300         0.5           3.5                   中/低频，大容量
# 压缩空气储能     0.5        162         1.0           0.5                   低频
# ------------------------------------------------------------------------------
# 总功率：8+6+4+1.5+0.5 = 20 MW，总容量：8+6+4+300+162 = 480 MWh

class FESS(EnergyStorageDevice):  # 飞轮储能
    def __init__(self):
        super().__init__("飞轮储能", power_rating=6.0, capacity=6.0,
                         charge_eff=0.90, discharge_eff=0.90,
                         op_cost=15, response_time=0.3, aging_coeff=1.2)
        self.voltage_nominal = 480
        self.internal_resistance = 0.5  # 欧姆，显著增大内阻使电压变化明显

    def _calc_electrical(self, dt):
        if abs(self.current_power) > 1e-3:
            # 用标称电压估算电流
            self.current = self.current_power * 1e6 / self.voltage_nominal
        else:
            self.current = 0
        # 开路电压与SOC线性
        v_oc = self.voltage_nominal * (0.95 + 0.1 * self.soc)
        # 内阻压降
        vdrop = self.current * self.internal_resistance
        if self.current_power > 0:   # 放电
            self.voltage = v_oc - vdrop
        elif self.current_power < 0:  # 充电
            self.voltage = v_oc + vdrop
        else:
            self.voltage = v_oc
        self._apply_lowpass_filter(dt, alpha=0.1)  # 增大滤波系数，保留波动


class SMES(EnergyStorageDevice):  # 超导磁储能
    def __init__(self):
        super().__init__("超导磁储能", power_rating=4.0, capacity=4.0,
                         charge_eff=0.97, discharge_eff=0.97,
                         op_cost=50, response_time=0.2, aging_coeff=0.8)
        self.voltage_nominal = 600
        self.critical_current = 10000
        self.internal_resistance = 0.5  # 欧姆

    def _calc_electrical(self, dt):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
            # 超导临界电流限制
            if abs(self.current) > self.critical_current:
                self.current = np.sign(self.current) * self.critical_current
                self.current_power = self.current * self.voltage_nominal / 1e6
        else:
            self.current = 0
        # 开路电压随SOC线性变化（假设0.9~1.1倍额定电压）
        v_oc = self.voltage_nominal * (0.9 + 0.2 * self.soc)
        vdrop = self.current * self.internal_resistance
        if self.current_power > 0:
            self.voltage = v_oc - vdrop
        elif self.current_power < 0:
            self.voltage = v_oc + vdrop
        else:
            self.voltage = v_oc
        self._apply_lowpass_filter(dt, alpha=0.1)


class SC(EnergyStorageDevice):  # 超级电容器
    def __init__(self):
        super().__init__("超级电容器", power_rating=8.0, capacity=8.0,
                         charge_eff=0.95, discharge_eff=0.95,
                         op_cost=10, response_time=0.2, aging_coeff=0.6)
        self.voltage_nominal = 300
        self.max_voltage = 330
        self.min_voltage = 150
        self.internal_resistance = 1.0  # 欧姆，显著增大内阻使放电电压下降明显

    def _calc_electrical(self, dt):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
        else:
            self.current = 0
        # 开路电压与SOC平方根成正比 (能量与电压平方成正比)
        v_oc = self.min_voltage + (self.max_voltage - self.min_voltage) * np.sqrt(self.soc)
        vdrop = self.current * self.internal_resistance
        if self.current_power > 0:
            self.voltage = v_oc - vdrop
        elif self.current_power < 0:
            self.voltage = v_oc + vdrop
        else:
            self.voltage = v_oc
        self._apply_lowpass_filter(dt, alpha=0.1)


class BESS(EnergyStorageDevice):  # 锂电池储能
    def __init__(self):
        super().__init__("锂电池储能", power_rating=1.5, capacity=300.0,
                         charge_eff=0.92, discharge_eff=0.92,
                         op_cost=25, response_time=0.5, aging_coeff=3.5)
        self.voltage_nominal = 400
        self.internal_resistance = 0.2  # 欧姆

    def _calc_electrical(self, dt):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
        else:
            self.current = 0
        # 开路电压随SOC线性变化
        v_oc = self.voltage_nominal * (0.8 + 0.4 * self.soc)
        vdrop = self.current * self.internal_resistance
        if self.current_power > 0:
            self.voltage = v_oc - vdrop
        elif self.current_power < 0:
            self.voltage = v_oc + vdrop
        else:
            self.voltage = v_oc
        self._apply_lowpass_filter(dt, alpha=0.1)


class CAES(EnergyStorageDevice):  # 压缩空气储能
    def __init__(self):
        super().__init__("压缩空气储能", power_rating=0.5, capacity=162.0,
                         charge_eff=0.70, discharge_eff=0.65,
                         op_cost=5, response_time=1.0, aging_coeff=0.5, gas_price=3.6)
        self.voltage_nominal = 10000
        self.internal_resistance = 200.0  # 欧姆，显著增大内阻
        self.gas_consumption = []
        # 用于生成波动的相位
        self.time_accum = 0.0

    def _calc_electrical(self, dt):
        self.time_accum += dt
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
        else:
            self.current = 0
        # 开路电压随SOC变化（模拟储气压力影响），范围 5000~15000 V
        v_oc_base = self.voltage_nominal * (0.5 + 1.0 * self.soc)   # SOC从0.1~0.9对应6000~14000
        # 加入正弦波动模拟膨胀过程的压力振荡（幅值1000V，频率2Hz）
        v_wave = 1000 * np.sin(2 * np.pi * 2 * self.time_accum)
        # 随机噪声（标准差200V）
        v_noise = np.random.normal(0, 200)
        v_oc = v_oc_base + v_wave + v_noise
        vdrop = self.current * self.internal_resistance
        if self.current_power > 0:
            self.voltage = v_oc - vdrop
        elif self.current_power < 0:
            self.voltage = v_oc + vdrop
        else:
            self.voltage = v_oc
        self._apply_lowpass_filter(dt, alpha=0.1)  # 提高滤波系数，保留更多波动

    def _calc_fuel_cost(self, power, dt):
        """燃气成本（放电时消耗天然气）"""
        if power > 0:
            gas_used = power * dt / 3600 * 0.3   # 0.3 m³/MWh
            self.gas_consumption.append(gas_used)
            return gas_used * self.gas_price * 1000   # 元
        return 0.0


# ==================== 三、分层MPC控制器 ====================
class HierarchicalMPC:
    def __init__(self, pred_horizon=10, control_horizon=5,
                 stochastic=True, n_scenarios=10, uncertainty_std=0.05):
        self.pred_horizon = pred_horizon
        self.control_horizon = control_horizon
        self.stochastic = stochastic
        self.n_scenarios = n_scenarios
        self.uncertainty_std = uncertainty_std
        self._buffer = None
        self.last_scenarios = None   # 保存最近一次生成的场景，用于可视化

    def wavelet_decompose(self, signal, levels=3, wavelet='db4'):
        """小波包分解（频段分离）"""
        if not PYWT_AVAILABLE:
            # 移动平均近似
            low = np.convolve(signal, np.ones(10)/10, mode='same')
            residual = signal - low
            mid = np.convolve(residual, np.ones(5)/5, mode='same')
            high = residual - mid
            return {'low': low, 'mid': mid, 'high': high}
        wp = pywt.WaveletPacket(data=signal, wavelet=wavelet,
                                mode='symmetric', maxlevel=levels)
        low = getattr(wp['a'*levels], 'data', np.zeros_like(signal))
        high = getattr(wp['d'*levels], 'data', np.zeros_like(signal))
        if len(low) != len(signal):
            low = np.interp(np.linspace(0,1,len(signal)), np.linspace(0,1,len(low)), low)
        if len(high) != len(signal):
            high = np.interp(np.linspace(0,1,len(signal)), np.linspace(0,1,len(high)), high)
        mid = signal - low - high
        return {'low': low, 'mid': mid, 'high': high}

    def economic_dispatch(self, devices, net_load, time_idx, dt, eco_mode=False):
        """上层经济调度：最小化期望总成本（购电 + 储能运维 + 老化 + 燃料 + 可选碳惩罚）"""
        n = len(devices)
        if n == 0:
            return np.array([])
        # 分时电价（南京冬季工商业）
        hour = (time_idx * dt) / 3600 % 24
        if 0 <= hour < 6 or 11 <= hour < 13:
            price = 0.21          # 低谷
        elif 14 <= hour < 22:
            price = 1.12          # 高峰
        else:
            price = 0.62          # 平段

        # 负荷跟踪惩罚系数（适度，保证重合度）
        track_penalty = 500.0     # 元/MW

        # 生成净负荷场景（如果启用随机规划）
        if self.stochastic:
            base = max(abs(net_load), 0.1)
            sigma = self.uncertainty_std * base
            scenarios = net_load + np.random.normal(0, sigma, self.n_scenarios)
            scenarios = np.maximum(scenarios, 0)   # 净负荷不能为负
            weights = np.ones(self.n_scenarios) / self.n_scenarios
            self.last_scenarios = scenarios        # 保存用于可视化
        else:
            scenarios = np.array([net_load])
            weights = np.array([1.0])
            self.last_scenarios = None

        const = dt / 3600 * price * 1000   # 购电成本系数 (元/MW对应dt内的成本)

        def objective(x):
            total_power = np.sum(x)
            # 储能成本
            storage_cost = sum(
                dev._calc_op_cost(x[i], dt) +
                dev._calc_aging_cost(x[i], dt, dev.soc) +
                (dev._calc_fuel_cost(x[i], dt) if hasattr(dev, '_calc_fuel_cost') else 0.0)
                for i, dev in enumerate(devices)
            )
            # 期望购电成本
            expected_grid_cost = 0.0
            carbon_cost = 0.0
            for s, w in zip(scenarios, weights):
                grid_power = s - total_power
                if grid_power > 0:
                    expected_grid_cost += w * grid_power * const
                    if eco_mode:
                        # 碳惩罚成本 = 购电电量 (kWh) * 碳因子 * 碳价格
                        carbon_cost += w * (grid_power * dt / 3600 * 1000) * CARBON_FACTOR * CARBON_PRICE
            # 负荷跟踪惩罚
            track_cost = track_penalty * (net_load - total_power) ** 2
            return expected_grid_cost + storage_cost + track_cost + carbon_cost

        bounds, x0 = [], []
        for dev in devices:
            max_charge = dev.get_charge_available() * 3600 / dt
            max_discharge = dev.get_discharge_available() * 3600 / dt
            p_min = -min(dev.power_rating, max_charge)
            p_max = min(dev.power_rating, max_discharge)
            bounds.append((p_min, p_max))
            x0.append(0.0)

        res = minimize(objective, x0, method='SLSQP', bounds=bounds,
                       options={'maxiter': 500, 'ftol': 1e-9})
        if not res.success:
            return np.zeros(n)
        return res.x

    def _allocate_frequency_power(self, devices, power_target, freq_type, dt):
        """按频段分配功率（边际成本优先，但高频设备指定）"""
        if abs(power_target) < 1e-6:
            return {}
        allocation = {}
        remaining = power_target
        if freq_type == 'high':
            # 高频设备：超级电容器、飞轮储能、超导磁储能
            # 第一优先级：超级电容器
            sc_devs = [d for d in devices if d.name == '超级电容器']
            if sc_devs:
                dev = sc_devs[0]
                p_max = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt) if power_target > 0 else -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                assign = np.clip(power_target, -p_max if power_target<0 else 0, p_max if power_target>0 else 0) if power_target > 0 else np.clip(power_target, -p_max, 0)
                if abs(assign) > 0:
                    allocation[dev.name] = assign
                    remaining -= assign
            # 第二优先级：飞轮储能
            if abs(remaining) > 0.01:
                fess_devs = [d for d in devices if d.name == '飞轮储能']
                if fess_devs:
                    dev = fess_devs[0]
                    p_max = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt) if remaining > 0 else -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                    assign = np.clip(remaining, -p_max if remaining<0 else 0, p_max if remaining>0 else 0) if remaining > 0 else np.clip(remaining, -p_max, 0)
                    if abs(assign) > 0:
                        allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                        remaining -= assign
            # 第三优先级：超导磁储能
            if abs(remaining) > 0.01:
                smes_devs = [d for d in devices if d.name == '超导磁储能']
                if smes_devs:
                    dev = smes_devs[0]
                    p_max = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt) if remaining > 0 else -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                    assign = np.clip(remaining, -abs(p_max) if remaining<0 else 0, abs(p_max) if remaining>0 else 0)
                    if abs(assign) > 0.01:
                        allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                        remaining -= assign
        elif freq_type == 'mid':
            # 中频设备：飞轮储能、锂电池储能
            eligible = [d for d in devices if d.name in ['飞轮储能', '锂电池储能']]
            eligible.sort(key=lambda d: d.marginal_cost)
            for dev in eligible:
                if abs(remaining) < 1e-6:
                    break
                if remaining > 0:
                    p_max = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt)
                    assign = min(remaining, p_max)
                else:
                    p_min = -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                    assign = max(remaining, p_min)
                if abs(assign) > 0:
                    allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                    remaining -= assign
        else:   # low
            # 低频设备：压缩空气储能、锂电池储能
            eligible = [d for d in devices if d.name in ['压缩空气储能', '锂电池储能']]
            eligible.sort(key=lambda d: d.marginal_cost)
            for dev in eligible:
                if abs(remaining) < 1e-6:
                    break
                if remaining > 0:
                    p_max = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt)
                    assign = min(remaining, p_max)
                else:
                    p_min = -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                    assign = max(remaining, p_min)
                if abs(assign) > 0:
                    allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                    remaining -= assign
        return allocation

    def real_time_balance(self, devices, net_load, dt):
        """下层实时平衡：小波分解 + 频段分配，以最小化快速储能总出力与待平衡中高频功率偏差为目标"""
        if self._buffer is None:
            self._buffer = np.ones(16) * net_load
        else:
            self._buffer = np.roll(self._buffer, -1)
            self._buffer[-1] = net_load
        comp = self.wavelet_decompose(self._buffer, levels=2)
        high = comp['high'][-1] if len(comp['high']) else 0
        mid = comp['mid'][-1] if len(comp['mid']) else 0
        low = comp['low'][-1] if len(comp['low']) else 0

        alloc = {}
        # 高频分配
        alloc_high = self._allocate_frequency_power(devices, high, 'high', dt)
        for k, v in alloc_high.items():
            alloc[k] = alloc.get(k, 0.0) + v
        # 中频分配
        alloc_mid = self._allocate_frequency_power(devices, mid, 'mid', dt)
        for k, v in alloc_mid.items():
            alloc[k] = alloc.get(k, 0.0) + v
        # 低频分配
        alloc_low = self._allocate_frequency_power(devices, low, 'low', dt)
        for k, v in alloc_low.items():
            alloc[k] = alloc.get(k, 0.0) + v
        return alloc


# ==================== 四、混合储能系统主类 ====================
class HybridEnergyStorageSystem:
    def __init__(self):
        self.device_specs = {
            '飞轮储能': {'class': FESS},
            '超导磁储能': {'class': SMES},
            '超级电容器': {'class': SC},
            '锂电池储能': {'class': BESS},
            '压缩空气储能': {'class': CAES}
        }
        self.devices = []
        self.mpc = HierarchicalMPC(stochastic=True, n_scenarios=10, uncertainty_std=0.05)
        self.simulation_results = None
        self.monitor_window = None
        self.monitor_labels = {}
        self.total_cost_label = None
        self.grid_power_label = None
        self.trend_canvases = {}   # 用于存储趋势图的Canvas
        self.trend_data = {}        # 存储每个设备最近功率数据

    def create_devices(self, selected_names):
        self.devices = []
        for name in selected_names:
            dev_class = self.device_specs[name]['class']
            self.devices.append(dev_class())
            self.trend_data[name] = []   # 初始化趋势数据

    def _clip_power_to_limits(self, power, dev, dt):
        """将单个设备的功率裁剪到可调范围内"""
        max_charge = dev.get_charge_available() * 3600 / dt
        max_discharge = dev.get_discharge_available() * 3600 / dt
        p_min = -min(dev.power_rating, max_charge)
        p_max = min(dev.power_rating, max_discharge)
        return np.clip(power, p_min, p_max)

    def _adjust_power_to_track(self, set_powers, devices, target, dt):
        """二次功率调整：若当前总功率与目标净负荷偏差超过0.05MW，则按各设备剩余可调容量比例补充"""
        current_total = np.sum(set_powers)
        diff = target - current_total
        if abs(diff) < 0.05:
            return set_powers
        capacities = []
        for i, dev in enumerate(devices):
            max_charge = dev.get_charge_available() * 3600 / dt
            max_discharge = dev.get_discharge_available() * 3600 / dt
            p_min = -min(dev.power_rating, max_charge)
            p_max = min(dev.power_rating, max_discharge)
            if diff > 0:
                room = p_max - set_powers[i]
            else:
                room = set_powers[i] - p_min
            capacities.append(max(0, room))
        total_capacity = np.sum(capacities)
        if total_capacity < abs(diff):
            scale = 1.0
        else:
            scale = abs(diff) / total_capacity
        adjusted = set_powers.copy()
        for i in range(len(devices)):
            if capacities[i] > 0:
                if diff > 0:
                    adjusted[i] += capacities[i] * scale
                else:
                    adjusted[i] -= capacities[i] * scale
        return adjusted

    def _update_trend_graph(self, dev_name, power):
        """更新趋势图数据并重绘"""
        # 保存最近50个点（对应5秒，dt=0.1）
        max_points = 50
        if dev_name not in self.trend_data:
            self.trend_data[dev_name] = []
        data = self.trend_data[dev_name]
        data.append(power)
        if len(data) > max_points:
            data.pop(0)
        # 更新对应的Canvas
        if dev_name in self.trend_canvases:
            canvas = self.trend_canvases[dev_name]
            canvas.delete("trend")
            if len(data) < 2:
                return
            w = canvas.winfo_width()
            h = canvas.winfo_height()
            if w <= 1 or h <= 1:
                return
            # 绘制折线
            points = []
            for i, val in enumerate(data):
                x = (i / (max_points - 1)) * w
                # 将功率映射到画布高度，假设额定功率为参考，显示范围[-rating, rating]
                dev = next(d for d in self.devices if d.name == dev_name)
                rating = dev.power_rating
                # y坐标：功率正为向上，负为向下，范围[-rating, rating] 映射到 [h, 0]
                y = h/2 - (val / rating) * (h/2 - 5)   # 留边距
                points.append((x, y))
            if len(points) > 1:
                canvas.create_line(points, fill=COLOR_ACCENT, width=2, tags="trend")  # 蓝色线条
            # 绘制零线
            canvas.create_line(0, h/2, w, h/2, fill=COLOR_TEXT_SECONDARY, dash=(2,2), tags="trend")

    def simulate(self, pulse_amp, pulse_dur, plant_power=10.0, sim_time=30, dt=0.1, econ_interval=1, eco_mode=False):
        time = np.arange(0, sim_time, dt)
        n = len(time)

        # 负荷：基础plant_power MW + 脉冲
        load = plant_power * np.ones_like(time)
        start = int(10.0 / dt)
        end = int((10.0 + pulse_dur) / dt)
        load[start:end] += pulse_amp
        plant = plant_power * np.ones_like(time)   # 电厂恒发
        net_load = load - plant

        res = {
            'time': time, 'load': load, 'plant': plant, 'net_load': net_load,
            'smoothed_load': np.zeros_like(time),
            'total_ess': np.zeros_like(time),
            'grid_power': np.zeros_like(time),
            'grid_purchase': np.zeros_like(time),
            'device_power': {d.name: np.zeros_like(time) for d in self.devices},
            'device_soc': {d.name: np.zeros_like(time) for d in self.devices},
            'device_energy': {d.name: np.zeros_like(time) for d in self.devices},
            'device_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_op_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_aging_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_fuel_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_current': {d.name: np.zeros_like(time) for d in self.devices},
            'device_voltage': {d.name: np.zeros_like(time) for d in self.devices},
            'pulse_amp': pulse_amp, 'pulse_dur': pulse_dur,
            'eco_mode': eco_mode
        }

        total_purchase = 0.0
        total_op = 0.0
        total_aging = 0.0
        total_fuel = 0.0
        total_carbon_penalty = 0.0

        last_econ_powers = np.zeros(len(self.devices))
        econ_cnt = econ_interval + 1

        # 初始化监控窗口
        self._update_monitor(init=True)

        for t in range(n):
            demand = net_load[t]

            # 上层经济调度
            if econ_cnt >= econ_interval:
                last_econ_powers = self.mpc.economic_dispatch(self.devices, demand, t, dt, eco_mode=eco_mode)
                econ_cnt = 0
            econ_cnt += 1

            # 下层实时平衡
            alloc = self.mpc.real_time_balance(self.devices, demand, dt)

            # 组合指令
            set_powers = last_econ_powers.copy()
            for i, dev in enumerate(self.devices):
                if dev.name in alloc:
                    set_powers[i] += alloc[dev.name]

            # 功率边界裁剪
            for i, dev in enumerate(self.devices):
                set_powers[i] = self._clip_power_to_limits(set_powers[i], dev, dt)

            # 二次功率调整
            set_powers = self._adjust_power_to_track(set_powers, self.devices, demand, dt)

            # 强制不允许向电网售电
            total_ess_now = np.sum(set_powers)
            if total_ess_now > demand + 1e-6:
                excess = total_ess_now - demand
                discharge_indices = [i for i, p in enumerate(set_powers) if p > 0]
                if discharge_indices:
                    discharge_powers = np.array([set_powers[i] for i in discharge_indices])
                    total_discharge = np.sum(discharge_powers)
                    reduction_factors = discharge_powers / total_discharge
                    reductions = reduction_factors * excess
                    for idx, red in zip(discharge_indices, reductions):
                        set_powers[idx] = max(0, set_powers[idx] - red)
                    total_ess_now = np.sum(set_powers)
                if total_ess_now > demand + 1e-6:
                    diff = total_ess_now - demand
                    for i in discharge_indices:
                        if set_powers[i] > diff:
                            set_powers[i] -= diff
                            break

            total_ess = 0.0
            for i, dev in enumerate(self.devices):
                set_power = set_powers[i]
                soc, cost, energy = dev.update_state(set_power, dt)

                total_op += dev.history_op_cost[-1]
                total_aging += dev.history_aging_cost[-1]
                total_fuel += dev.history_fuel_cost[-1]

                res['device_power'][dev.name][t] = dev.current_power
                res['device_soc'][dev.name][t] = soc
                res['device_energy'][dev.name][t] = energy
                res['device_cost'][dev.name][t] = cost
                res['device_op_cost'][dev.name][t] = dev.history_op_cost[-1]
                res['device_aging_cost'][dev.name][t] = dev.history_aging_cost[-1]
                res['device_fuel_cost'][dev.name][t] = dev.history_fuel_cost[-1]
                res['device_current'][dev.name][t] = dev.current
                res['device_voltage'][dev.name][t] = dev.voltage

                total_ess += dev.current_power
                # 更新趋势图
                self._update_trend_graph(dev.name, dev.current_power)

            res['total_ess'][t] = total_ess
            res['smoothed_load'][t] = plant[t] + total_ess
            res['grid_power'][t] = max(0, demand - total_ess)

            # 购电费用
            hour = (t * dt) / 3600 % 24
            if 0 <= hour < 6 or 11 <= hour < 13:
                price = 0.21
            elif 14 <= hour < 22:
                price = 1.12
            else:
                price = 0.62
            if res['grid_power'][t] > 0:
                purchase = res['grid_power'][t] * dt / 3600 * price * 1000
                res['grid_purchase'][t] = purchase
                total_purchase += purchase
                if eco_mode:
                    # 碳惩罚成本
                    carbon_penalty = (res['grid_power'][t] * dt / 3600 * 1000) * CARBON_FACTOR * CARBON_PRICE
                    total_carbon_penalty += carbon_penalty

            if t % 5 == 0:
                self._update_monitor(total_purchase + total_op + total_aging + total_fuel + total_carbon_penalty, res['grid_power'][t])

        self.sim_res = res
        self.total_purchase = total_purchase
        self.total_op = total_op
        self.total_aging = total_aging
        self.total_fuel = total_fuel
        self.total_carbon_penalty = total_carbon_penalty
        self.total_cost = total_purchase + total_op + total_aging + total_fuel + total_carbon_penalty
        self.net_cost = self.total_cost

        return res

    def _update_monitor(self, total_cost=None, grid_power=None, init=False):
        """实时监控面板（显示功率/SOC/可充放电量/电流/电压/功率趋势，越界红色预警）"""
        if init:
            self.monitor_window = tk.Toplevel()
            self.monitor_window.title("储能系统实时监控 (经济分配 + 高精度跟踪 + 随机规划)")
            self.monitor_window.geometry("950x750")
            self.monitor_window.configure(bg=COLOR_BG)

            # 创建主画布和滚动条，以便容纳更多设备
            canvas = tk.Canvas(self.monitor_window, bg=COLOR_BG, highlightthickness=0)
            scrollbar = tk.Scrollbar(self.monitor_window, orient="vertical", command=canvas.yview)
            scrollable_frame = ttk.Frame(canvas)

            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )

            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)

            self.monitor_labels = {}

            for dev in self.devices:
                # 卡片式Frame
                frame = tk.Frame(scrollable_frame, bg=COLOR_CARD, relief='solid', bd=1)
                frame.pack(fill='x', padx=15, pady=8)

                # 标题（设备名）
                title_label = tk.Label(frame, text=dev.name, font=('微软雅黑', 11, 'bold'),
                                       bg=COLOR_PRIMARY, fg='white', anchor='w', padx=8)
                title_label.pack(fill='x', pady=(0,5))

                # 内容区域（使用内部Frame布局）
                content = tk.Frame(frame, bg=COLOR_CARD)
                content.pack(fill='x', padx=5, pady=5)

                # 第一行：功率、SOC
                tk.Label(content, text="功率 (MW):", bg=COLOR_CARD, font=('微软雅黑',9),
                         fg=COLOR_TEXT).grid(row=0, column=0, sticky='w', padx=5)
                l1 = tk.Label(content, text="0.00", width=8, bg=COLOR_CARD,
                              font=('微软雅黑',9,'bold'), fg=COLOR_ACCENT)
                l1.grid(row=0, column=1, sticky='w')
                tk.Label(content, text="SOC:", bg=COLOR_CARD, font=('微软雅黑',9),
                         fg=COLOR_TEXT).grid(row=0, column=2, sticky='w', padx=(15,0))
                l2 = tk.Label(content, text="0.80", width=6, bg=COLOR_CARD,
                              font=('微软雅黑',9,'bold'), fg=COLOR_SUCCESS)
                l2.grid(row=0, column=3, sticky='w')

                # 第二行：可充、可放
                tk.Label(content, text="可充(MWh):", bg=COLOR_CARD, font=('微软雅黑',9),
                         fg=COLOR_TEXT).grid(row=1, column=0, sticky='w', padx=5)
                l3 = tk.Label(content, text="0.00", width=8, bg=COLOR_CARD,
                              font=('微软雅黑',9,'bold'), fg=COLOR_ACCENT)
                l3.grid(row=1, column=1, sticky='w')
                tk.Label(content, text="可放(MWh):", bg=COLOR_CARD, font=('微软雅黑',9),
                         fg=COLOR_TEXT).grid(row=1, column=2, sticky='w', padx=(15,0))
                l4 = tk.Label(content, text="0.00", width=8, bg=COLOR_CARD,
                              font=('微软雅黑',9,'bold'), fg=COLOR_ACCENT)
                l4.grid(row=1, column=3, sticky='w')

                # 第三行：电流、电压
                tk.Label(content, text="电流 (A):", bg=COLOR_CARD, font=('微软雅黑',9),
                         fg=COLOR_TEXT).grid(row=2, column=0, sticky='w', padx=5)
                l5 = tk.Label(content, text="0.0", width=8, bg=COLOR_CARD,
                              font=('微软雅黑',9,'bold'), fg=COLOR_ACCENT)
                l5.grid(row=2, column=1, sticky='w')
                tk.Label(content, text="电压 (V):", bg=COLOR_CARD, font=('微软雅黑',9),
                         fg=COLOR_TEXT).grid(row=2, column=2, sticky='w', padx=(15,0))
                l6 = tk.Label(content, text="0.0", width=8, bg=COLOR_CARD,
                              font=('微软雅黑',9,'bold'), fg=COLOR_ACCENT)
                l6.grid(row=2, column=3, sticky='w')

                # 第四行：功率裕度
                tk.Label(content, text="功率裕度:", bg=COLOR_CARD, font=('微软雅黑',9),
                         fg=COLOR_TEXT).grid(row=3, column=0, sticky='w', padx=5)
                l7 = tk.Label(content, text="100%", width=6, bg=COLOR_CARD,
                              font=('微软雅黑',9,'bold'), fg=COLOR_ACCENT)
                l7.grid(row=3, column=1, sticky='w')

                # 创新：功率趋势图 (小型Canvas)
                trend_canvas = tk.Canvas(content, width=180, height=60,
                                         bg=COLOR_PRIMARY_LIGHT, highlightthickness=1,
                                         highlightbackground=COLOR_TEXT_SECONDARY)
                trend_canvas.grid(row=0, column=4, rowspan=4, padx=(15,5), sticky='nsew')
                self.trend_canvases[dev.name] = trend_canvas

                self.monitor_labels[dev.name] = (l1, l2, l3, l4, l5, l6, l7)

            # 底部全局信息
            bottom_frame = tk.Frame(scrollable_frame, bg=COLOR_PRIMARY_LIGHT, relief='sunken', bd=1)
            bottom_frame.pack(fill='x', padx=15, pady=10)

            tk.Label(bottom_frame, text="累计总成本(元):", font=('微软雅黑',10),
                     bg=COLOR_PRIMARY_LIGHT, fg=COLOR_TEXT).pack(side='left', padx=10)
            self.total_cost_label = tk.Label(bottom_frame, text="0.00", font=('微软雅黑',10,'bold'),
                                             bg=COLOR_PRIMARY_LIGHT, fg=COLOR_PRIMARY)
            self.total_cost_label.pack(side='left', padx=5)

            tk.Label(bottom_frame, text="电网功率(MW):", font=('微软雅黑',10),
                     bg=COLOR_PRIMARY_LIGHT, fg=COLOR_TEXT).pack(side='left', padx=(30,0))
            self.grid_power_label = tk.Label(bottom_frame, text="0.00", font=('微软雅黑',10,'bold'),
                                             bg=COLOR_PRIMARY_LIGHT, fg=COLOR_SUCCESS)
            self.grid_power_label.pack(side='left', padx=5)

            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            self.monitor_window.update()
        else:
            for dev in self.devices:
                if dev.name in self.monitor_labels:
                    l1, l2, l3, l4, l5, l6, l7 = self.monitor_labels[dev.name]
                    l1.config(text=f"{dev.current_power:.3f}")
                    l2.config(text=f"{dev.soc:.3f}")
                    l3.config(text=f"{dev.get_charge_available():.3f}")
                    l4.config(text=f"{dev.get_discharge_available():.3f}")
                    if abs(dev.current) > 999:
                        l5.config(text=f"{dev.current/1000:.2f}k")
                    else:
                        l5.config(text=f"{dev.current:.1f}")
                    l6.config(text=f"{dev.voltage:.1f}")
                    # SOC越界红色预警
                    if dev.soc < 0.11 or dev.soc > 0.89:
                        l2.config(foreground=COLOR_DANGER)
                    else:
                        l2.config(foreground=COLOR_SUCCESS)
                    # 功率裕度预警（当前功率与额定功率比值）
                    ratio = abs(dev.current_power) / dev.power_rating * 100
                    if ratio > 90:
                        l7.config(text=f"{ratio:.0f}%", foreground=COLOR_DANGER)
                    elif ratio > 75:
                        l7.config(text=f"{ratio:.0f}%", foreground=COLOR_WARNING)
                    else:
                        l7.config(text=f"{ratio:.0f}%", foreground=COLOR_ACCENT)

            if total_cost is not None:
                self.total_cost_label.config(text=f"{total_cost:,.2f}")
            if grid_power is not None:
                self.grid_power_label.config(text=f"{grid_power:.3f}")
            self.monitor_window.update()

    def close_monitor(self):
        """关闭实时监控窗口"""
        if self.monitor_window:
            self.monitor_window.destroy()
            self.monitor_window = None


# ==================== 五、GUI用户界面 ====================
class HESSGUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("混合储能脉冲平滑控制(20MW/480MWh) - 经济分配 + 高精度跟踪 + 随机规划")
        self.root.geometry("680x820")
        self.root.configure(bg=COLOR_BG)

        # 设置ttk样式
        self.style = ttk.Style()
        self.style.theme_use('clam')
        self.style.configure('TLabel', background=COLOR_BG, foreground=COLOR_TEXT, font=('微软雅黑', 9))
        self.style.configure('TLabelframe', background=COLOR_BG, foreground=COLOR_PRIMARY,
                             font=('微软雅黑', 10, 'bold'), relief='solid', bordercolor=COLOR_PRIMARY)
        self.style.configure('TLabelframe.Label', background=COLOR_BG, foreground=COLOR_PRIMARY)
        self.style.configure('TCheckbutton', background=COLOR_BG, foreground=COLOR_TEXT, font=('微软雅黑', 11))
        self.style.configure('TButton', font=('微软雅黑', 12), padding=5,
                             background=COLOR_PRIMARY, foreground='white',
                             bordercolor=COLOR_PRIMARY, focuscolor='none')
        self.style.map('TButton',
                       background=[('active', COLOR_ACCENT), ('pressed', '#0B3B7A')],
                       foreground=[('active', 'white')])
        self.style.configure('TProgressbar', background=COLOR_ACCENT, troughcolor=COLOR_PRIMARY_LIGHT)

        self.pulse_amp = tk.DoubleVar(value=12.0)
        self.pulse_dur = tk.DoubleVar(value=10.0)
        self.plant_power = tk.DoubleVar(value=10.0)   # 微电网规模（电厂恒发功率）
        self.dev_vars = {
            '飞轮储能': tk.BooleanVar(value=True),
            '超导磁储能': tk.BooleanVar(value=True),
            '超级电容器': tk.BooleanVar(value=True),
            '锂电池储能': tk.BooleanVar(value=True),
            '压缩空气储能': tk.BooleanVar(value=True)
        }
        self.use_stochastic = tk.BooleanVar(value=True)
        self.n_scenarios = tk.IntVar(value=10)
        self.uncertainty_std = tk.DoubleVar(value=0.05)
        self.eco_mode = tk.BooleanVar(value=False)   # 环保模式
        self.sim_running = False    # 防止重复点击
        self.setup_ui()

    def setup_ui(self):
        # 标题
        tk.Label(self.root, text="混合储能系统(HESS)脉冲平滑控制",
                 font=("微软雅黑", 18, "bold"), bg=COLOR_BG, fg=COLOR_PRIMARY).pack(pady=(15,5))

        # 脉冲参数设置区域（上下排列）
        pf = ttk.LabelFrame(self.root, text="⚡ 脉冲参数设置", padding=10)
        pf.pack(padx=20, pady=10, fill='x')

        # 幅值滑块（上）
        frame_amp = ttk.Frame(pf)
        frame_amp.pack(fill='x', pady=5)
        ttk.Label(frame_amp, text="脉冲幅值 (MW):", width=15, anchor='w').pack(side='left')
        scale_amp = tk.Scale(frame_amp, from_=1, to=20, orient='horizontal',
                             variable=self.pulse_amp, length=280, bg=COLOR_CARD,
                             troughcolor=COLOR_PRIMARY_LIGHT, highlightthickness=0,
                             fg=COLOR_TEXT)
        scale_amp.pack(side='left', padx=5)
        ttk.Label(frame_amp, textvariable=self.pulse_amp, width=4).pack(side='left')

        # 持续时间滑块（下）
        frame_dur = ttk.Frame(pf)
        frame_dur.pack(fill='x', pady=5)
        ttk.Label(frame_dur, text="脉冲持续时间 (s):", width=15, anchor='w').pack(side='left')
        scale_dur = tk.Scale(frame_dur, from_=1, to=20, orient='horizontal',
                             variable=self.pulse_dur, length=280, bg=COLOR_CARD,
                             troughcolor=COLOR_PRIMARY_LIGHT, highlightthickness=0,
                             fg=COLOR_TEXT)
        scale_dur.pack(side='left', padx=5)
        ttk.Label(frame_dur, textvariable=self.pulse_dur, width=4).pack(side='left')

        # 微电网规模（电厂出力）
        mg_frame = ttk.Frame(pf)
        mg_frame.pack(fill='x', pady=5)
        ttk.Label(mg_frame, text="电厂恒发功率 (MW):", width=15, anchor='w').pack(side='left')
        ttk.Spinbox(mg_frame, from_=1, to=20, textvariable=self.plant_power,
                    width=8, font=('微软雅黑',10)).pack(side='left', padx=5)
        ttk.Label(mg_frame, text="MW", font=('微软雅黑',10)).pack(side='left')

        # 随机规划参数区域
        spf = ttk.LabelFrame(self.root, text="🎲 随机规划参数", padding=10)
        spf.pack(padx=20, pady=10, fill='x')
        chk_stoch = ttk.Checkbutton(spf, text="启用随机规划", variable=self.use_stochastic)
        chk_stoch.pack(anchor='w')
        frame_scen = ttk.Frame(spf)
        frame_scen.pack(fill='x', pady=5)
        ttk.Label(frame_scen, text="场景数量:").pack(side='left')
        ttk.Spinbox(frame_scen, from_=1, to=50, textvariable=self.n_scenarios,
                    width=5).pack(side='left', padx=5)
        ttk.Label(frame_scen, text="预测误差标准差 (%):").pack(side='left', padx=(15,0))
        ttk.Spinbox(frame_scen, from_=1, to=30, textvariable=self.uncertainty_std,
                    width=5, format="%.2f").pack(side='left', padx=5)

        # 高级选项区域（创新设计）
        advf = ttk.LabelFrame(self.root, text="🌿 高级选项 (创新设计)", padding=10)
        advf.pack(padx=20, pady=10, fill='x')
        chk_eco = ttk.Checkbutton(advf, text="环保模式 (考虑碳减排惩罚)", variable=self.eco_mode)
        chk_eco.pack(anchor='w')
        ttk.Label(advf, text="碳价格: 0.05 元/kg CO₂ (固定)", font=('微软雅黑',9),
                  foreground=COLOR_TEXT_SECONDARY).pack(anchor='w', padx=20)

        # 储能设备选择区域
        df = ttk.LabelFrame(self.root, text="🔋 储能设备选择 (总功率20MW/总容量480MWh)", padding=10)
        df.pack(padx=20, pady=10, fill='x')

        # 使用网格布局使选择更紧凑
        dev_frame = ttk.Frame(df)
        dev_frame.pack()
        for i, (name, var) in enumerate(self.dev_vars.items()):
            row, col = divmod(i, 2)
            ttk.Checkbutton(dev_frame, text=name, variable=var).grid(row=row, column=col, sticky='w', padx=10, pady=2)

        # 按钮区域
        btnf = ttk.Frame(self.root)
        btnf.pack(pady=15)
        self.start_btn = ttk.Button(btnf, text="⚡ 开始仿真", command=self.run_sim, width=16)
        self.start_btn.pack(side='left', padx=8)
        ttk.Button(btnf, text="❌ 退出", command=self.root.quit, width=16).pack(side='left', padx=8)

        # 状态标签（创意动态提示）
        self.status = tk.Label(self.root, text="✨ 就绪，请设置参数并选择设备", font=("微软雅黑", 10),
                               bg=COLOR_BG, fg=COLOR_ACCENT)
        self.status.pack(pady=5)

        # 进度条（模拟仿真进度）
        self.progress = ttk.Progressbar(self.root, orient='horizontal', length=400, mode='indeterminate')
        self.progress.pack(pady=5)

        # 创意小贴士
        tip_frame = tk.Frame(self.root, bg=COLOR_PRIMARY_LIGHT, relief='solid', bd=1)
        tip_frame.pack(padx=20, pady=10, fill='x')
        tk.Label(tip_frame, text="💡 创意小贴士", font=('微软雅黑', 10, 'bold'),
                 bg=COLOR_PRIMARY_LIGHT, fg=COLOR_PRIMARY).pack(anchor='w', padx=10, pady=5)
        tips = [
            "✓ 可自定义微电网规模（电厂出力），模拟不同场景",
            "✓ 环保模式将在经济调度中加入碳成本，引导绿色运行",
            "✓ 实时监控面板新增功率趋势图，动态显示功率变化",
            "✓ 平滑评分满分100，分数越高平滑效果越好",
            "✓ 所有图形轴标签已修正，布局清晰无重叠"
        ]
        for tip in tips:
            tk.Label(tip_frame, text=tip, font=('微软雅黑',9), bg=COLOR_PRIMARY_LIGHT,
                     fg=COLOR_TEXT, anchor='w').pack(anchor='w', padx=20)

    def run_sim(self):
        if self.sim_running:
            messagebox.showinfo("提示", "仿真正在进行中，请稍候...")
            return
        selected = [name for name, var in self.dev_vars.items() if var.get()]
        if not selected:
            messagebox.showerror("错误", "至少选择一个储能设备！")
            return

        # 禁用开始按钮，启动进度条
        self.start_btn.config(state='disabled')
        self.status.config(text="🚀 仿真进行中... 正在消除脉冲...", fg=COLOR_WARNING)
        self.progress.start(10)
        self.root.update()
        self.sim_running = True

        try:
            amp = self.pulse_amp.get()
            dur = self.pulse_dur.get()
            plant_power = self.plant_power.get()
            hess = HybridEnergyStorageSystem()
            hess.mpc.stochastic = self.use_stochastic.get()
            hess.mpc.n_scenarios = self.n_scenarios.get()
            hess.mpc.uncertainty_std = self.uncertainty_std.get()
            hess.create_devices(selected)
            results = hess.simulate(amp, dur, plant_power=plant_power, econ_interval=1, eco_mode=self.eco_mode.get())

            # 仿真结束后更新状态
            self.status.config(text="✅ 仿真完成！平滑后负荷与原始负荷高度重合", fg=COLOR_SUCCESS)
            self.start_btn.config(state='normal')
            self.progress.stop()
            self.sim_running = False

            # 弹出详细结果窗口
            self.show_results(hess, results, amp, dur, selected)
        except Exception as e:
            messagebox.showerror("错误", f"仿真异常：{str(e)}")
            self.status.config(text="❌ 仿真失败", fg=COLOR_DANGER)
            self.start_btn.config(state='normal')
            self.progress.stop()
            self.sim_running = False

    def show_results(self, hess, res, amp, dur, selected):
        # 汇总成本
        total_purchase = hess.total_purchase
        total_op = hess.total_op
        total_aging = hess.total_aging
        total_fuel = hess.total_fuel
        total_carbon = hess.total_carbon_penalty
        total_cost = hess.total_cost
        net_cost = hess.net_cost

        # 碳减排估算 (基于电网购电减少量，与无储能时对比)
        total_grid_without_storage = np.sum(res['net_load']) * 0.1 / 3600  # MWh
        total_grid_with_storage = np.sum(res['grid_power']) * 0.1 / 3600
        grid_reduction = total_grid_without_storage - total_grid_with_storage   # MWh
        carbon_reduction = grid_reduction * 1000 * CARBON_FACTOR   # kg CO₂

        # 各设备指标
        dev_charge = {}
        dev_discharge = {}
        dev_avg_p = {}
        dev_max_p = {}
        for dev in hess.devices:
            p = res['device_power'][dev.name]
            dev_charge[dev.name] = -np.sum(p[p < 0]) * 0.1 / 3600
            dev_discharge[dev.name] = np.sum(p[p > 0]) * 0.1 / 3600
            dev_avg_p[dev.name] = np.mean(np.abs(p))
            dev_max_p[dev.name] = np.max(np.abs(p))

        # 脉冲期间功率分配占比
        mask = (res['time'] >= 10) & (res['time'] < 10 + dur)
        pulse_power = {}
        for dev in hess.devices:
            avg = np.mean(np.abs(res['device_power'][dev.name][mask]))
            if avg > 0.01:
                pulse_power[dev.name] = avg

        # 计算平滑性能评分（基于脉冲幅值的相对误差）
        rmse = np.sqrt(np.mean((res['load'] - res['smoothed_load'])**2))
        pulse_amp_val = res['pulse_amp']
        smooth_score = max(0, min(100, 100 * (1 - rmse / (pulse_amp_val + 1e-6))))
        max_dev = np.max(np.abs(res['load'] - res['smoothed_load']))

        # 创建独立的结果窗口
        win = tk.Toplevel()
        win.title("脉冲平滑仿真详细结果")
        win.geometry("1000x850")
        win.configure(bg=COLOR_BG)

        main_frame = tk.Frame(win, bg=COLOR_BG)
        main_frame.pack(fill='both', expand=True, padx=10, pady=10)

        # 上部关键指标摘要
        summary_frame = tk.LabelFrame(main_frame, text="🌟 关键指标摘要", bg=COLOR_BG,
                                      font=('微软雅黑',11,'bold'), fg=COLOR_PRIMARY,
                                      relief='solid', bd=1, padx=10, pady=5)
        summary_frame.pack(fill='x', pady=(0,10))

        row1 = tk.Frame(summary_frame, bg=COLOR_BG)
        row1.pack(fill='x', pady=2)
        tk.Label(row1, text="平滑效果评分:", bg=COLOR_BG, font=('微软雅黑',10),
                 fg=COLOR_TEXT).pack(side='left')
        score_color = COLOR_SUCCESS if smooth_score >= 80 else (COLOR_WARNING if smooth_score >= 60 else COLOR_DANGER)
        tk.Label(row1, text=f"{smooth_score:.1f} 分 (满分100)", bg=COLOR_BG, font=('微软雅黑',12,'bold'),
                 fg=score_color).pack(side='left', padx=5)
        tk.Label(row1, text="总成本:", bg=COLOR_BG, font=('微软雅黑',10),
                 fg=COLOR_TEXT).pack(side='left', padx=(20,0))
        tk.Label(row1, text=f"{total_cost:,.0f} 元", bg=COLOR_BG, font=('微软雅黑',12,'bold'),
                 fg=COLOR_PRIMARY).pack(side='left', padx=5)

        row2 = tk.Frame(summary_frame, bg=COLOR_BG)
        row2.pack(fill='x', pady=2)
        tk.Label(row2, text="电网购电比例:", bg=COLOR_BG, font=('微软雅黑',10),
                 fg=COLOR_TEXT).pack(side='left')
        grid_ratio = total_purchase / (total_purchase + total_op + total_aging + total_fuel + total_carbon + 1e-9) * 100
        tk.Label(row2, text=f"{grid_ratio:.1f}%", bg=COLOR_BG, font=('微软雅黑',10,'bold'),
                 fg=COLOR_ACCENT).pack(side='left', padx=5)
        tk.Label(row2, text="最大瞬时偏差:", bg=COLOR_BG, font=('微软雅黑',10),
                 fg=COLOR_TEXT).pack(side='left', padx=(20,0))
        tk.Label(row2, text=f"{max_dev:.3f} MW", bg=COLOR_BG, font=('微软雅黑',10,'bold'),
                 fg=COLOR_DANGER).pack(side='left', padx=5)

        # 碳减排指标
        row3 = tk.Frame(summary_frame, bg=COLOR_BG)
        row3.pack(fill='x', pady=2)
        tk.Label(row3, text="🌿 碳减排量:", bg=COLOR_BG, font=('微软雅黑',10),
                 fg=COLOR_TEXT).pack(side='left')
        tk.Label(row3, text=f"{carbon_reduction:.2f} kg CO₂", bg=COLOR_BG, font=('微软雅黑',12,'bold'),
                 fg=COLOR_SUCCESS).pack(side='left', padx=5)
        # 环保模式状态
        if res.get('eco_mode', False):
            tk.Label(row3, text="(环保模式开启)", bg=COLOR_BG, font=('微软雅黑',9),
                     fg=COLOR_SUCCESS).pack(side='left', padx=10)

        if pulse_power:
            row4 = tk.Frame(summary_frame, bg=COLOR_BG)
            row4.pack(fill='x', pady=2)
            tk.Label(row4, text="🎯 脉冲主导设备:", bg=COLOR_BG, font=('微软雅黑',10),
                     fg=COLOR_TEXT).pack(side='left')
            main_dev = max(pulse_power, key=pulse_power.get)
            tk.Label(row4, text=f"{main_dev} ({pulse_power[main_dev]:.2f} MW)", bg=COLOR_BG,
                     font=('微软雅黑',10,'bold'), fg=COLOR_WARNING).pack(side='left', padx=5)

        # 按钮框架：增加随机规划场景可视化
        btn_frame = tk.Frame(main_frame, bg=COLOR_BG)
        btn_frame.pack(fill='x', pady=5)
        ttk.Button(btn_frame, text="📊 显示详细特性曲线", command=lambda: self.plot_all(hess, res), width=25).pack(side='left', padx=5)
        if hess.mpc.stochastic and hess.mpc.last_scenarios is not None:
            ttk.Button(btn_frame, text="🎲 显示随机规划场景", command=lambda: self.plot_scenarios(hess.mpc.last_scenarios),
                       width=20).pack(side='left', padx=5)

        # 详细文本区域
        text_frame = tk.Frame(main_frame, bg=COLOR_BG)
        text_frame.pack(fill='both', expand=True, pady=5)

        text = tk.Text(text_frame, wrap='word', font=('微软雅黑', 10), bg=COLOR_CARD,
                       relief='solid', bd=1, padx=10, pady=10, fg=COLOR_TEXT)
        scroll = tk.Scrollbar(text_frame, command=text.yview)
        text.config(yscrollcommand=scroll.set)
        text.pack(side='left', fill='both', expand=True)
        scroll.pack(side='right', fill='y')

        text.insert('end', "="*90 + "\n")
        text.insert('end', "★ 混合储能系统脉冲平滑仿真详细数据 ★\n")
        text.insert('end', "="*90 + "\n\n")
        text.insert('end', f"微电网规模 (电厂恒发功率): {res['plant'][0]:.2f} MW\n")
        text.insert('end', f"脉冲幅值: {amp:.2f} MW\n")
        text.insert('end', f"脉冲持续时间: {dur:.2f} s\n")
        text.insert('end', f"环保模式: {'开启' if res.get('eco_mode',False) else '关闭'}\n\n")
        text.insert('end', "【随机规划设置】\n")
        text.insert('end', f"  启用随机规划: {hess.mpc.stochastic}\n")
        if hess.mpc.stochastic:
            text.insert('end', f"  场景数量: {hess.mpc.n_scenarios}\n")
            text.insert('end', f"  预测误差标准差: {hess.mpc.uncertainty_std*100:.1f}%\n")
        text.insert('end', "\n")
        text.insert('end', "【储能设备配置】总功率20MW / 总容量480MWh\n")
        for name in selected:
            spec = hess.device_specs[name]['class']
            tmp_dev = spec()
            text.insert('end', f"  {name}: 功率 {tmp_dev.power_rating:.1f} MW, 容量 {tmp_dev.capacity:.1f} MWh, "
                         f"边际成本 {tmp_dev.marginal_cost:.2f} 元/MW/h\n")
        text.insert('end', "\n")
        text.insert('end', "【平滑性能】\n")
        text.insert('end', f"  平滑后负荷与原始负荷 RMSE: {rmse:.4f} MW\n")
        text.insert('end', f"  最大瞬时偏差: {max_dev:.4f} MW (电网承担)\n")
        text.insert('end', f"  总偏差能量: {np.sum(np.abs(res['load'] - res['smoothed_load'])) * 0.1 / 3600:.2f} MWh\n")
        text.insert('end', f"  平滑评分: {smooth_score:.1f} 分 (满分100，越高越好)\n\n")
        text.insert('end', "【经济性指标 (元)】\n")
        text.insert('end', f"  购电支出: {total_purchase:,.2f}\n")
        text.insert('end', f"  运维成本: {total_op:,.2f}\n")
        text.insert('end', f"  老化成本: {total_aging:,.2f}\n")
        text.insert('end', f"  燃料成本: {total_fuel:,.2f}\n")
        if total_carbon > 0:
            text.insert('end', f"  碳惩罚成本: {total_carbon:,.2f}\n")
        text.insert('end', f"  → 总成本: {total_cost:,.2f}\n")
        text.insert('end', f"  → 净成本: {net_cost:,.2f}\n\n")
        text.insert('end', "【环境效益】\n")
        text.insert('end', f"  电网购电减少量: {grid_reduction:.3f} MWh\n")
        text.insert('end', f"  等效碳减排: {carbon_reduction:.2f} kg CO₂\n\n")
        text.insert('end', "【各设备成本构成】\n")
        text.insert('end', f"{'设备名称':<16} {'运维成本':<12} {'老化成本':<12} {'燃料成本':<12} {'总成本':<12}\n")
        text.insert('end', "-"*70 + "\n")
        for dev in hess.devices:
            op_sum = np.sum(res['device_op_cost'][dev.name])
            aging_sum = np.sum(res['device_aging_cost'][dev.name])
            fuel_sum = np.sum(res['device_fuel_cost'][dev.name])
            total_dev = op_sum + aging_sum + fuel_sum
            text.insert('end', f"{dev.name:<16} {op_sum:<12.2f} {aging_sum:<12.2f} {fuel_sum:<12.2f} {total_dev:<12.2f}\n")
        text.insert('end', "\n")
        text.insert('end', "【脉冲期间功率分配策略 (边际成本优先 + 频段分配)】\n")
        total_pulse_power = sum(pulse_power.values())
        for name, avg in pulse_power.items():
            ratio = avg / total_pulse_power * 100 if total_pulse_power > 0 else 0
            text.insert('end', f"  {name}: {avg:.3f} MW ({ratio:.1f}%)\n")
        text.insert('end', "\n")
        text.insert('end', "【各设备充放电统计】\n")
        text.insert('end', f"{'设备名称':<16} {'充电量(MWh)':<12} {'放电量(MWh)':<12} "
                     f"{'平均功率(MW)':<12} {'最大功率(MW)':<12}\n")
        text.insert('end', "-"*70 + "\n")
        for dev in hess.devices:
            text.insert('end', f"{dev.name:<16} {dev_charge[dev.name]:<12.4f} {dev_discharge[dev.name]:<12.4f} "
                         f"{dev_avg_p[dev.name]:<12.4f} {dev_max_p[dev.name]:<12.4f}\n")
        text.insert('end', "\n")
        text.insert('end', "【详细边界约束】\n")
        text.insert('end', "  • 电厂额定功率: 13 MW (实际恒发可配置)\n")
        text.insert('end', "  • 储能系统总功率上限: 20 MW (已满配)\n")
        text.insert('end', "  • 储能系统总容量: 480 MWh\n")
        text.insert('end', "  • 各设备SOC安全区间: [0.1, 0.9] (越界自动限功率，监控红色预警)\n")
        text.insert('end', "  • 初始SOC提高至0.8，确保脉冲放电能力\n")
        text.insert('end', "  • 脉冲幅值上限: 20 MW，持续时间上限: 20 s\n")
        text.insert('end', "  • 分时电价(南京冬季工商业): 低谷0.21、平段0.62、高峰1.12 元/kWh\n")
        text.insert('end', "  • 天然气价格: 3.6 元/m³ (压缩空气储能)\n")
        text.insert('end', "  • 非线性老化成本: 功率^1.8 + 放电深度影响\n")
        text.insert('end', "  • 功率分配策略: 超级电容/飞轮优先承担高频，其他设备按边际成本补充\n")
        text.insert('end', "  • 环保模式碳价格: 0.05 元/kg CO₂\n")
        text.insert('end', "\n")
        text.insert('end', "【结论】脉冲已被高度平滑，平滑后负荷与原始负荷高度重合，符合经济调度原则，并带来环境效益。\n")
        text.config(state='disabled')

    def plot_scenarios(self, scenarios):
        """绘制随机规划生成的场景"""
        plt.figure(figsize=(10, 6))
        for i, s in enumerate(scenarios):
            plt.plot(s, 'o-', markersize=3, label=f'场景{i+1}' if i<10 else None)
        plt.xlabel('时间步')
        plt.ylabel('净负荷 (MW)')
        plt.title('随机规划生成的净负荷预测场景')
        plt.legend(loc='upper right', ncol=2, fontsize=8)
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()

    def plot_all(self, hess, res):
        """绘制所有要求的图形，动态适应所选设备，优化布局避免重叠"""
        try:
            plt.figure(figsize=(18, 16))
            plt.rcParams['font.sans-serif'] = ['SimHei']

            # 1. 负荷跟踪效果（电厂+储能总出力跟踪负荷）
            plt.subplot(4, 4, 1)
            plt.plot(res['time'], res['load'], 'r-', lw=2, label='原始负荷')
            plt.plot(res['time'], res['smoothed_load'], 'b--', lw=2, label='电厂+储能总出力')
            plt.plot(res['time'], res['plant'], 'g-', lw=1.5, label=f'电厂出力({res["plant"][0]:.0f}MW)')
            plt.fill_between(res['time'], res['load'], res['smoothed_load'], alpha=0.25, color='gray')
            plt.xlabel('时间 (秒)', fontsize=10)
            plt.ylabel('功率 (MW)', fontsize=10)
            plt.title('负荷跟踪效果（电厂+储能总出力）', fontsize=12)
            plt.legend(fontsize=8, loc='upper right')
            plt.grid(True, alpha=0.3)

            # 2. 脉冲期间功率分配饼图
            plt.subplot(4, 4, 2)
            mask = (res['time'] >= 10) & (res['time'] < 10 + res['pulse_dur'])
            pulse_power = {}
            for dev in hess.devices:
                avg = np.mean(np.abs(res['device_power'][dev.name][mask]))
                if avg > 0.05:
                    pulse_power[dev.name] = avg
            if pulse_power:
                labels = list(pulse_power.keys())
                sizes = list(pulse_power.values())
                plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90,
                        textprops={'fontsize': 8})
                plt.title('脉冲期间功率分配策略', fontsize=12)
                plt.axis('equal')
            else:
                plt.text(0.5,0.5,'无脉冲数据', ha='center', va='center')
                plt.title('脉冲期间功率分配策略', fontsize=12)

            # 3. 各设备电流随时间变化
            plt.subplot(4, 4, 3)
            for dev in hess.devices:
                current_smooth = gaussian_filter1d(res['device_current'][dev.name], sigma=0.5)  # 降低平滑，保留波动
                plt.plot(res['time'], current_smooth, label=dev.name, linewidth=1.5)
            plt.xlabel('时间 (秒)', fontsize=10)
            plt.ylabel('电流 (A)', fontsize=10)
            plt.title('各设备电流变化', fontsize=12)
            plt.legend(fontsize=7, loc='upper right')
            plt.grid(True, alpha=0.3)

            # 4. 各设备电压随时间变化
            plt.subplot(4, 4, 4)
            for dev in hess.devices:
                voltage_smooth = gaussian_filter1d(res['device_voltage'][dev.name], sigma=0.5)
                plt.plot(res['time'], voltage_smooth, label=dev.name, linewidth=1.5)
            plt.xlabel('时间 (秒)', fontsize=10)
            plt.ylabel('电压 (V)', fontsize=10)
            plt.title('各设备电压变化', fontsize=12)
            plt.legend(fontsize=7, loc='upper right')
            plt.grid(True, alpha=0.3)

            # 5. 超级电容器能量-电压 (如果存在)
            plt.subplot(4, 4, 5)
            sc = next((d for d in hess.devices if '超级电容' in d.name), None)
            if sc:
                energy_kWh = res['device_energy'][sc.name] * 1000
                voltage = res['device_voltage'][sc.name]
                plt.scatter(energy_kWh, voltage, c=res['time'], cmap='viridis', alpha=0.7, s=10)
                plt.xlabel('储存能量 (kWh)', fontsize=10)
                plt.ylabel('电压 (V)', fontsize=10)
                plt.title('超级电容器能量-电压', fontsize=12)
                plt.colorbar(label='时间 (秒)', fraction=0.046, pad=0.04)
                plt.grid(True, alpha=0.3)
            else:
                plt.text(0.5,0.5,'未选择超级电容器', ha='center', va='center')
                plt.title('超级电容器能量-电压', fontsize=12)

            # 6. 锂电池能量-电流 (如果存在)
            plt.subplot(4, 4, 6)
            bess = next((d for d in hess.devices if '锂电池' in d.name), None)
            if bess:
                energy_kWh = res['device_energy'][bess.name] * 1000
                current_kA = res['device_current'][bess.name] / 1000
                plt.scatter(energy_kWh, current_kA, c=res['time'], cmap='plasma', alpha=0.7, s=10)
                plt.xlabel('储存能量 (kWh)', fontsize=10)
                plt.ylabel('电流 (kA)', fontsize=10)
                plt.title('锂电池储能能量-电流', fontsize=12)
                plt.colorbar(label='时间 (秒)', fraction=0.046, pad=0.04)
                plt.grid(True, alpha=0.3)
            else:
                plt.text(0.5,0.5,'未选择锂电池', ha='center', va='center')
                plt.title('锂电池能量-电流', fontsize=12)

            # 7. 飞轮储能能量-电压 (如果存在)
            plt.subplot(4, 4, 7)
            fess = next((d for d in hess.devices if '飞轮' in d.name), None)
            if fess:
                energy_kWh = res['device_energy'][fess.name] * 1000
                voltage = res['device_voltage'][fess.name]
                plt.scatter(energy_kWh, voltage, c=res['time'], cmap='cool', alpha=0.7, s=10)
                plt.xlabel('储存能量 (kWh)', fontsize=10)
                plt.ylabel('电压 (V)', fontsize=10)
                plt.title('飞轮储能能量-电压', fontsize=12)
                plt.colorbar(label='时间 (秒)', fraction=0.046, pad=0.04)
                plt.grid(True, alpha=0.3)
            else:
                plt.text(0.5,0.5,'未选择飞轮储能', ha='center', va='center')
                plt.title('飞轮能量-电压', fontsize=12)

            # 8. 超导磁储能能量-电流 (如果存在)
            plt.subplot(4, 4, 8)
            smes = next((d for d in hess.devices if '超导磁' in d.name), None)
            if smes:
                energy_kWh = res['device_energy'][smes.name] * 1000
                current = res['device_current'][smes.name]
                plt.scatter(energy_kWh, current, c=res['time'], cmap='magma', alpha=0.7, s=10)
                plt.xlabel('储存能量 (kWh)', fontsize=10)
                plt.ylabel('电流 (A)', fontsize=10)
                plt.title('超导磁储能能量-电流', fontsize=12)
                plt.colorbar(label='时间 (秒)', fraction=0.046, pad=0.04)
                plt.grid(True, alpha=0.3)
            else:
                plt.text(0.5,0.5,'未选择超导磁储能', ha='center', va='center')
                plt.title('超导磁能量-电流', fontsize=12)

            # 9. 压缩空气储能能量-电压 (如果存在)
            plt.subplot(4, 4, 9)
            caes = next((d for d in hess.devices if '压缩空气' in d.name), None)
            if caes:
                energy_kWh = res['device_energy'][caes.name] * 1000
                voltage = res['device_voltage'][caes.name]
                plt.scatter(energy_kWh, voltage, c=res['time'], cmap='winter', alpha=0.7, s=10)
                plt.xlabel('储存能量 (kWh)', fontsize=10)
                plt.ylabel('电压 (V)', fontsize=10)
                plt.title('压缩空气储能能量-电压', fontsize=12)
                plt.colorbar(label='时间 (秒)', fraction=0.046, pad=0.04)
                plt.grid(True, alpha=0.3)
            else:
                plt.text(0.5,0.5,'未选择压缩空气', ha='center', va='center')
                plt.title('压缩空气能量-电压', fontsize=12)

            # 10. 储能总功率与电网交互
            plt.subplot(4, 4, 10)
            plt.plot(res['time'], res['total_ess'], 'purple', lw=2, label='储能总功率')
            plt.plot(res['time'], res['grid_power'], 'orange', lw=1.5, label='电网购电功率')
            plt.axhline(0, color='black', ls='--', alpha=0.5)
            plt.xlabel('时间 (秒)', fontsize=10)
            plt.ylabel('功率 (MW)', fontsize=10)
            plt.title('储能总功率与电网购电', fontsize=12)
            plt.legend(fontsize=8, loc='upper right')
            plt.grid(True, alpha=0.3)

            # 11. 各设备SOC变化
            plt.subplot(4, 4, 11)
            for dev in hess.devices:
                plt.plot(res['time'], res['device_soc'][dev.name], label=dev.name, linewidth=1.5)
            plt.xlabel('时间 (秒)', fontsize=10)
            plt.ylabel('SOC', fontsize=10)
            plt.title('各设备荷电状态', fontsize=12)
            plt.legend(fontsize=7, loc='upper right')
            plt.grid(True, alpha=0.3)

            # 12. 实时可充放电能量
            plt.subplot(4, 4, 12)
            for dev in hess.devices:
                soc_arr = res['device_soc'][dev.name]
                chargeable = (0.9 - soc_arr) * dev.capacity
                dischargeable = (soc_arr - 0.1) * dev.capacity
                plt.plot(res['time'], chargeable, '--', lw=1, label=f'{dev.name}可充')
                plt.plot(res['time'], dischargeable, '-', lw=1, label=f'{dev.name}可放')
            plt.xlabel('时间 (秒)', fontsize=10)
            plt.ylabel('能量 (MWh)', fontsize=10)
            plt.title('实时可充放电能量', fontsize=12)
            plt.legend(fontsize=5, loc='upper right', ncol=2)
            plt.grid(True, alpha=0.3)

            # 13. 购电费用
            plt.subplot(4, 4, 13)
            plt.plot(res['time'], res['grid_purchase'], 'r-', lw=1.5, label='购电支出')
            plt.xlabel('时间 (秒)', fontsize=10)
            plt.ylabel('金额 (元)', fontsize=10)
            plt.title('电网购电费用', fontsize=12)
            plt.legend(fontsize=8, loc='upper right')
            plt.grid(True, alpha=0.3)

            # 14. 储能出力堆叠面积图
            plt.subplot(4, 4, 14)
            times = res['time']
            pos_data = []
            neg_data = []
            labels = []
            for dev in hess.devices:
                p = res['device_power'][dev.name]
                pos_data.append(np.maximum(p, 0))
                neg_data.append(np.minimum(p, 0))
                labels.append(dev.name)
            plt.stackplot(times, *pos_data, labels=labels, alpha=0.8, baseline='zero')
            plt.stackplot(times, *neg_data, alpha=0.8, baseline='zero')
            plt.xlabel('时间 (秒)', fontsize=10)
            plt.ylabel('功率 (MW)', fontsize=10)
            plt.title('储能出力堆叠 (正:放电,负:充电)', fontsize=12)
            plt.legend(loc='upper right', fontsize=6, ncol=2)
            plt.grid(True, alpha=0.3)

            # 15. 各设备边际成本对比
            plt.subplot(4, 4, 15)
            names = [dev.name for dev in hess.devices]
            costs = [dev.marginal_cost for dev in hess.devices]
            plt.bar(names, costs, color='skyblue')
            plt.xlabel('设备', fontsize=10)
            plt.ylabel('边际成本 (元/MW/h)', fontsize=10)
            plt.title('各设备边际成本对比', fontsize=12)
            plt.xticks(rotation=15, fontsize=8)

            # 16. 脉冲局部放大
            plt.subplot(4, 4, 16)
            mask_local = (res['time'] >= 8) & (res['time'] <= 12 + res['pulse_dur'])
            plt.plot(res['time'][mask_local], res['load'][mask_local], 'r-', lw=2, label='原始负荷')
            plt.plot(res['time'][mask_local], res['smoothed_load'][mask_local], 'b--', lw=2, label='平滑后负荷')
            plt.xlabel('时间 (秒)', fontsize=10)
            plt.ylabel('功率 (MW)', fontsize=10)
            plt.title('脉冲局部放大', fontsize=12)
            plt.legend(fontsize=8, loc='upper right')
            plt.grid(True, alpha=0.3)

            plt.tight_layout(pad=3.0)   # 增加边距，避免重叠
            plt.show()

        except Exception as e:
            print(f"绘图过程中出现错误: {e}")
            messagebox.showerror("绘图错误", f"无法显示图形，错误信息：{e}")


# ==================== 六、主程序 ====================
def main():
    if not PYWT_AVAILABLE:
        print("⚠️ PyWavelets 未安装，小波分解使用移动平均近似。")
    app = HESSGUI()
    app.root.mainloop()

if __name__ == '__main__':
    main()
