# -*- coding: utf-8 -*-

"""
================================================================================

混合储能系统分层EMS控制程序（脉冲完全平滑 + 经济分配 + 实时平衡）

================================================================================

【系统概况】

电厂额定功率: 13 MW (实际恒发 10 MW，可配置)

混合储能系统: 总功率 20 MW / 总容量 480 MWh

包含设备:
飞轮储能(FESS)、超导磁储能(SMES)、超级电容器(SC)、锂电池(BESS)、压缩空气储能(CAES)

脉冲参数: 幅值 1~20 MW, 持续时间 1~20 s

【分层EMS架构】

1. 上层经济调度层 (MPC)
   - 基于分时电价(南京冬季工商业) + 天然气价格
   - 目标函数: 购电成本 + 运维成本 + 非线性老化成本 + 燃料成本 + 负荷跟踪惩罚
   - 可选碳惩罚成本（环保模式）
   - 采用随机规划(场景法)处理净负荷预测误差，提高鲁棒性

2. 下层实时平衡层
   - 小波包分解(或移动平均近似)将不平衡功率分解为高/中/低频分量
   - 按频段分配: 高频(超级电容/飞轮/超导磁), 中频(飞轮/锂电池), 低频(压缩空气/锂电池)
   - 二次功率调整: 确保储能总出力与净负荷偏差<0.05MW，实现高度重合

【输出要求全面覆盖】

✓ 脉冲平滑效果图 (原始负荷 vs 平滑后负荷)
✓ 脉冲功率分配策略/占比图 (饼图)
✓ 各设备电流/电压随时间变化图 (缓慢渐变，无跳变)
✓ 各设备能量-电流/能量-电压关系散点图
✓ 实时监控面板 (功率/SOC/可充放电量/电流/电压/边界预警 + 功率趋势图)
✓ 详细成本构成 (购电/运维/老化/燃料/碳惩罚)
✓ 脉冲期间各设备承担比例
✓ 所有边界条件列表 (SOC限值/功率限值/电价/气价/老化系数等)
✓ 碳减排估算
✓ 随机规划场景可视化

【创新亮点】

- 可配置微电网规模（电厂出力），模拟不同场景
- 环保模式：经济调度中加入碳惩罚，引导绿色运行
- 实时功率趋势图动态展示设备响应
- 碳减排估算与环境效益展示
- **绘图优化**：所有轴标签正确、图例清晰、子图间距合理，无重叠

================================================================================
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize
from scipy.ndimage import gaussian_filter1d
import tkinter as tk
from tkinter import ttk, messagebox
from collections import deque
import warnings
warnings.filterwarnings('ignore')

# 设置 matplotlib 后端为 TkAgg 以保证与 tkinter 兼容
import matplotlib
matplotlib.use('TkAgg')

# 设置中文字体
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

# ------------------------------------------------------------------------------
# 小波包分解（优先使用pywt）
try:
    import pywt
    PYWT_AVAILABLE = True
except ImportError:
    PYWT_AVAILABLE = False
    print("⚠️ PyWavelets 未安装，使用移动平均近似小波分解（频带分离精度稍降）")

# 碳排放因子 (kg CO₂/kWh)
CARBON_FACTOR = 0.5
# 碳价格 (元/kg CO₂) - 用于环保模式
CARBON_PRICE = 0.05

# ==================== 配色方案 ====================
COLOR_PRIMARY = "#0D47A1"          # 深蓝主色
COLOR_PRIMARY_LIGHT = "#E3F2FD"    # 浅蓝背景
COLOR_ACCENT = "#1976D2"           # 亮蓝强调
COLOR_BG = "#F5F5F5"               # 整体背景浅灰
COLOR_CARD = "#FFFFFF"             # 卡片白色
COLOR_TEXT = "#212121"             # 主要文本深灰
COLOR_TEXT_SECONDARY = "#757575"   # 辅助文本灰色
COLOR_SUCCESS = "#2E7D32"          # 成功绿色
COLOR_WARNING = "#F57C00"          # 警告橙色
COLOR_DANGER = "#D32F2F"           # 危险红色
COLOR_INFO = "#1976D2"             # 信息蓝色

# ==================== 全局配置参数 ====================
SOC_MIN = 0.1
SOC_MAX = 0.9
FILTER_ALPHA_DEFAULT = 0.1         # 默认低通滤波系数
TRACK_TOLERANCE = 0.05              # 二次功率调整允许的最大偏差 (MW)

# 分时电价（南京冬季工商业）
PRICE_VALLEY = 0.21                 # 低谷
PRICE_FLAT = 0.62                   # 平段
PRICE_PEAK = 1.12                   # 高峰

# ==================== 一、储能设备基类（含精确电气计算、非线性老化成本）=====================

class EnergyStorageDevice:
    """所有储能设备的抽象基类，包含精确电气参数解算及超平滑电气参数滤波"""
    def __init__(self, name, power_rating, capacity,
                 charge_eff, discharge_eff,
                 op_cost, response_time,
                 aging_coeff,          # 非线性老化系数 (元/MW^1.8/h)
                 gas_price=0):
        self.name = name
        self.power_rating = power_rating          # MW
        self.capacity = capacity                   # MWh
        self.charge_eff = charge_eff
        self.discharge_eff = discharge_eff
        self.op_cost = op_cost                      # 运维成本 元/MWh
        self.response_time = response_time          # 秒
        self.aging_coeff = aging_coeff              # 老化成本系数
        self.gas_price = gas_price                  # 天然气价格 元/m³ (仅CAES)

        # 初始状态（提高至0.8，确保脉冲期间放电能力充足）
        self.soc = 0.8
        self.current_power = 0.0
        self.voltage = 0.0
        self.current = 0.0
        self.energy_stored = capacity * self.soc

        # 用于超低通滤波的上一时刻值
        self.last_current = 0.0
        self.last_voltage = 0.0

        # 历史记录（使用 deque 限制长度，防止内存过大）
        self.history_soc = deque(maxlen=10000)
        self.history_power = deque(maxlen=10000)
        self.history_energy = deque(maxlen=10000)
        self.history_cost = deque(maxlen=10000)          # 运维+燃料+老化
        self.history_op_cost = deque(maxlen=10000)       # 纯运维
        self.history_aging_cost = deque(maxlen=10000)    # 老化成本
        self.history_fuel_cost = deque(maxlen=10000)     # 燃料成本（CAES）
        self.history_voltage = deque(maxlen=10000)
        self.history_current = deque(maxlen=10000)

        # 内阻（由子类具体设置）
        self.internal_resistance = 0.0

    def update_state(self, power_set, dt):
        """更新设备状态，包含斜坡限制、SOC边界保护、成本计算"""
        # 斜坡限制（功率变化率限制）
        max_change = self.power_rating * dt / self.response_time
        delta = power_set - self.current_power
        if abs(delta) > max_change:
            delta = np.sign(delta) * max_change
        power = self.current_power + delta
        power = np.clip(power, -self.power_rating, self.power_rating)
        self.current_power = power

        # 能量更新
        if power >= 0:   # 放电
            energy_out = power * dt / 3600 * self.discharge_eff
            self.energy_stored -= energy_out
        else:            # 充电
            energy_in = -power * dt / 3600 * self.charge_eff
            self.energy_stored += energy_in

        # SOC边界保护（安全防护）
        if self.energy_stored < SOC_MIN * self.capacity:
            self.energy_stored = SOC_MIN * self.capacity
            self.current_power = 0.0
        if self.energy_stored > SOC_MAX * self.capacity:
            self.energy_stored = SOC_MAX * self.capacity
            self.current_power = 0.0
        self.soc = self.energy_stored / self.capacity

        # 计算电气参数（包含精确解算 + 低通滤波）
        self._calc_electrical(dt)

        # 成本计算（运维 + 老化 + 燃料）
        op_cost_val = self._calc_op_cost(power, dt)
        aging_cost_val = self._calc_aging_cost(power, dt, self.soc)
        fuel_cost_val = self._calc_fuel_cost(power, dt) if hasattr(self, '_calc_fuel_cost') else 0.0
        total_cost = op_cost_val + aging_cost_val + fuel_cost_val

        # 记录历史
        self.history_soc.append(self.soc)
        self.history_power.append(self.current_power)
        self.history_energy.append(self.energy_stored)
        self.history_cost.append(total_cost)
        self.history_op_cost.append(op_cost_val)
        self.history_aging_cost.append(aging_cost_val)
        self.history_fuel_cost.append(fuel_cost_val)
        self.history_voltage.append(self.voltage)
        self.history_current.append(self.current)

        return self.soc, total_cost, self.energy_stored

    def _calc_electrical(self, dt):
        """电气参数计算（由子类重写）"""
        pass

    def _calc_current_voltage(self, power, Voc, R):
        """
        根据功率(MW)、开路电压Voc(V)和内阻R(Ω)精确求解电流(A)和端电压(V)
        解二次方程: R * I^2 - Voc * I + P = 0 (P单位为W)
        """
        if abs(power) < 1e-6:
            return 0.0, Voc
        P = power * 1e6          # MW -> W
        a = R
        b = -Voc
        c = P
        discriminant = b*b - 4*a*c
        if discriminant < 0:
            # 功率超出能力，取最大可能电流（Voc/(2R)对应最大功率）
            I_max = Voc / (2 * R)
            I = I_max if power > 0 else -I_max
        else:
            sqrt_disc = np.sqrt(discriminant)
            I1 = (Voc + sqrt_disc) / (2 * R)
            I2 = (Voc - sqrt_disc) / (2 * R)
            if power > 0:
                # 放电，取较小正根（损耗小）
                I = min(I1, I2)
            else:
                # 充电，取负根
                I = I1 if I1 < 0 else I2
        V = Voc - I * R
        return I, V

    def _apply_lowpass_filter(self, dt, alpha):
        """对电流和电压施加超强低通滤波，消除瞬时跳变"""
        # 一阶低通滤波: y_new = alpha * x + (1-alpha) * y_old
        if not hasattr(self, 'last_current'):
            self.last_current = self.current
            self.last_voltage = self.voltage
        else:
            # 电流滤波
            raw_current = self.current
            self.current = alpha * raw_current + (1 - alpha) * self.last_current
            self.last_current = self.current
            # 电压滤波
            raw_voltage = self.voltage
            self.voltage = alpha * raw_voltage + (1 - alpha) * self.last_voltage
            self.last_voltage = self.voltage

    def _calc_op_cost(self, power, dt):
        """运维成本（线性）"""
        return abs(power) * dt / 3600 * self.op_cost

    def _calc_aging_cost(self, power, dt, soc):
        """
        非线性老化成本模型：
        - 与功率的 1.8 次方成正比（强化电流热效应影响，指数 1.8 来源于典型电池老化实验数据）
        - 与放电深度变化相关（简化用 (1-soc) 惩罚）
        - 系数 aging_coeff 单位：元/MW^1.8/h
        """
        if abs(power) < 1e-6:
            return 0.0
        non_linear = abs(power) ** 1.8
        dod_factor = 1.0 + 0.5 * (1 - soc) if power > 0 else 0.5
        return self.aging_coeff * non_linear * dt / 3600 * dod_factor

    def _calc_fuel_cost(self, power, dt):
        """燃料成本（仅CAES重写）"""
        return 0.0

    def get_charge_available(self):
        """可充电量 (MWh)"""
        return (SOC_MAX - self.soc) * self.capacity

    def get_discharge_available(self):
        """可放电量 (MWh)"""
        return (self.soc - SOC_MIN) * self.capacity

    @property
    def marginal_cost(self):
        """
        边际成本系数（元/MW/h）---- 用于功率分配权重计算
        取运维成本 + 线性化后的老化成本（强化功率影响，采用 P^0.8）
        指数 0.8 用于近似老化成本对功率的亚线性依赖
        """
        avg_aging_per_mw = self.aging_coeff * (self.power_rating ** 0.8)   # 元/MW/h
        return self.op_cost + avg_aging_per_mw

# ==================== 二、五类储能设备具体模型 ====================
# 总功率20MW / 总容量480MWh
# ------------------------------------------------------------------------------
# 设备名称        功率(MW)  容量(MWh)  响应时间(s)  老化系数(元/MW^1.8/h)  说明
# ------------------------------------------------------------------------------
# 超级电容器        8          8          0.2          0.6                高频主力
# 飞轮储能          6          6          0.3          1.2                高频/中频
# 超导磁储能        4          4          0.2          0.8                极端高频备用
# 锂电池储能        1.5        300        0.5          3.5                中/低频，大容量
# 压缩空气储能      0.5        162        1.0          0.5                低频
# ------------------------------------------------------------------------------

class FESS(EnergyStorageDevice):   # 飞轮储能
    def __init__(self):
        super().__init__("飞轮储能", power_rating=6.0, capacity=6.0,
                         charge_eff=0.90, discharge_eff=0.90,
                         op_cost=15, response_time=0.3, aging_coeff=1.2)
        self.voltage_nominal = 480
        # 内阻：使压降约50V（额定电流12500A，0.004Ω）
        self.internal_resistance = 0.004
        # 电压范围设定为额定电压的 ±10%
        self.voltage_min = 0.9 * self.voltage_nominal
        self.voltage_max = 1.1 * self.voltage_nominal
        # 计算电压与SOC的平方根关系的系数：Voc = V0 + k * sqrt(soc)
        sqrt_min = np.sqrt(SOC_MIN)
        sqrt_max = np.sqrt(SOC_MAX)
        self.k = (self.voltage_max - self.voltage_min) / (sqrt_max - sqrt_min)
        self.V0 = self.voltage_min - self.k * sqrt_min

    def _calc_electrical(self, dt):
        # 开路电压与SOC的平方根成正比
        Voc = self.V0 + self.k * np.sqrt(self.soc)
        # 精确求解电流和端电压
        I, V = self._calc_current_voltage(self.current_power, Voc, self.internal_resistance)
        self.current = I
        self.voltage = V
        self._apply_lowpass_filter(dt, alpha=FILTER_ALPHA_DEFAULT)

class SMES(EnergyStorageDevice):   # 超导磁储能
    def __init__(self):
        super().__init__("超导磁储能", power_rating=4.0, capacity=4.0,
                         charge_eff=0.97, discharge_eff=0.97,
                         op_cost=50, response_time=0.2, aging_coeff=0.8)
        self.voltage_nominal = 600
        self.critical_current = 10000
        # 内阻：使压降约67V（额定电流6667A，0.01Ω）
        self.internal_resistance = 0.01

    def _calc_electrical(self, dt):
        Voc = self.voltage_nominal * (0.9 + 0.2 * self.soc)
        I, V = self._calc_current_voltage(self.current_power, Voc, self.internal_resistance)
        # 超导临界电流限制
        if abs(I) > self.critical_current:
            I = np.sign(I) * self.critical_current
            # 重新计算端电压
            V = Voc - I * self.internal_resistance
        self.current = I
        self.voltage = V
        self._apply_lowpass_filter(dt, alpha=FILTER_ALPHA_DEFAULT)

class SC(EnergyStorageDevice):   # 超级电容器（增强模型：内阻随SOC变化，考虑自放电能量损失）
    def __init__(self):
        super().__init__("超级电容器", power_rating=8.0, capacity=8.0,
                         charge_eff=0.95, discharge_eff=0.95,
                         op_cost=10, response_time=0.2, aging_coeff=0.6)
        # 电气参数
        self.voltage_max = 330.0        # 最大电压 V
        self.voltage_min = 150.0        # 最小电压 V
        # 电容计算：基于能量差 C = 2E / (Vmax^2 - Vmin^2)
        energy_joules = self.capacity * 3.6e9   # MWh -> J
        self.capacitance = 2 * energy_joules / (self.voltage_max**2 - self.voltage_min**2)
        # 等效串联电阻（ESR）和并联电阻（EPR，模拟自放电）
        self.ESR_base = 0.001           # 基础ESR
        self.EPR = 1000.0               # 欧姆，很大，自放电缓慢
        # 温度模型
        self.temperature = 25.0          # 摄氏度
        self.temp_coeff_ESR = 0.002      # 每摄氏度ESR变化率
        # 老化模型（循环次数/时间影响）
        self.cycle_count = 0             # 累计循环次数（简化）
        self.aging_factor_ESR = 1.0      # ESR老化乘数
        self.aging_factor_C = 1.0        # 电容老化乘数
        # 用于产生波动的时间累积
        self.time_accum = 0.0

    def _calc_electrical(self, dt):
        self.time_accum += dt

        # 自放电能量损失（通过EPR）—— 修正单位换算系数
        if hasattr(self, 'last_voltage') and self.last_voltage > 0:
            i_leak = self.last_voltage / self.EPR                       # A
            energy_loss = i_leak * self.last_voltage * dt / 1e6         # 单位：MJ
            # 转换为MWh并从储存能量中扣除 (1 MJ = 1/3600 MWh ≈ 2.7778e-4 MWh)
            self.energy_stored -= energy_loss * 2.7778e-4
            self.energy_stored = max(self.energy_stored, SOC_MIN * self.capacity)

        # 1. 从储存能量计算开路电压（基于电容公式）
        energy_joules = self.energy_stored * 3.6e9        # MWh -> J
        C_actual = self.capacitance * self.aging_factor_C
        v_oc = np.sqrt(2 * energy_joules / C_actual) if energy_joules > 0 else self.voltage_min
        v_oc = np.clip(v_oc, self.voltage_min, self.voltage_max)

        # 2. 计算实际内阻（考虑SOC、温度、老化）
        ESR_soc_factor = 1.0 - 0.2 * (self.soc - 0.5)     # SOC=0.5时1.0，SOC=1.0时0.9，SOC=0.0时1.1
        ESR_actual = self.ESR_base * self.aging_factor_ESR * (1 + self.temp_coeff_ESR * (self.temperature - 25)) * ESR_soc_factor

        # 3. 使用精确电流电压求解（移除人为噪声）
        I, V = self._calc_current_voltage(self.current_power, v_oc, ESR_actual)
        self.current = I
        self.voltage = V

        # 4. 温度缓慢变化
        self.temperature += 0.001 * abs(self.current_power) * dt

        # 5. 老化模拟
        if abs(self.current_power) > 0.1:
            self.cycle_count += dt / 3600 * abs(self.current_power) / self.power_rating
            self.aging_factor_ESR = 1.0 + 0.0001 * self.cycle_count
            self.aging_factor_C = max(0.8, 1.0 - 0.00005 * self.cycle_count)

        # 6. 应用低通滤波（统一使用默认系数）
        self._apply_lowpass_filter(dt, alpha=FILTER_ALPHA_DEFAULT)

class BESS(EnergyStorageDevice):   # 锂电池储能（内阻随SOC变化）
    def __init__(self):
        super().__init__("锂电池储能", power_rating=1.5, capacity=300.0,
                         charge_eff=0.92, discharge_eff=0.92,
                         op_cost=25, response_time=0.5, aging_coeff=3.5)
        self.voltage_nominal = 400
        # 内阻基础值
        self.R0 = 0.013

    def _calc_electrical(self, dt):
        # 内阻随SOC变化（低SOC时内阻增大）
        soc_factor = 1.0 + 0.5 * (0.5 - self.soc)   # SOC=0.5时1.0，SOC=0.1时1.2，SOC=0.9时0.8
        R = self.R0 * max(0.5, min(1.5, soc_factor))
        Voc = self.voltage_nominal * (0.8 + 0.4 * self.soc)
        I, V = self._calc_current_voltage(self.current_power, Voc, R)
        self.current = I
        self.voltage = V
        self._apply_lowpass_filter(dt, alpha=FILTER_ALPHA_DEFAULT)

class CAES(EnergyStorageDevice):   # 压缩空气储能（采用多变过程模型）
    def __init__(self):
        super().__init__("压缩空气储能", power_rating=0.5, capacity=162.0,
                         charge_eff=0.70, discharge_eff=0.65,
                         op_cost=5, response_time=1.0, aging_coeff=0.5, gas_price=3.6)
        self.voltage_nominal = 10000
        self.R0 = 20.0                # 基础内阻
        self.p0 = 1.0                 # 初始压力 (标幺)
        self.k = 1.4                   # 空气绝热指数
        self.gas_consumption = deque(maxlen=10000)

    def _calc_electrical(self, dt):
        # 根据SOC估算压力（假设压力与SOC线性相关）
        p = self.p0 * (0.5 + 1.0 * self.soc)   # SOC=0.1~0.9对应压力0.6~1.4
        # 多变过程电压：V ∝ p^((k-1)/k)
        Voc = self.voltage_nominal * (p / self.p0) ** ((self.k - 1) / self.k)
        # 内阻随压力变化（压力高时内阻略低）
        R = self.R0 * (1.0 - 0.1 * (p - self.p0))
        I, V = self._calc_current_voltage(self.current_power, Voc, R)
        self.current = I
        self.voltage = V
        self._apply_lowpass_filter(dt, alpha=FILTER_ALPHA_DEFAULT)

    def _calc_fuel_cost(self, power, dt):
        """燃气成本（放电时消耗天然气）"""
        if power > 0:
            gas_used = power * dt / 3600 * 0.3          # 0.3 m³/MWh
            self.gas_consumption.append(gas_used)
            return gas_used * self.gas_price            # 元
        return 0.0

# ==================== 三、分层MPC控制器 ====================

class HierarchicalMPC:
    def __init__(self, pred_horizon=10, control_horizon=5,
                 stochastic=True, n_scenarios=10, uncertainty_std=0.05):
        self.pred_horizon = pred_horizon
        self.control_horizon = control_horizon
        self.stochastic = stochastic
        self.n_scenarios = n_scenarios
        self.uncertainty_std = uncertainty_std
        self._buffer = None
        self.last_scenarios = None      # 保存最近一次生成的场景，用于可视化
        self.buffer_length = 200         # 默认长度，稍后根据dt调整

    def set_buffer_length(self, dt, max_pulse_dur):
        """根据仿真步长和最大脉冲持续时间动态设置缓冲区长度"""
        # 缓冲区应能覆盖最大脉冲持续时间的2倍以上，以保证分解效果
        self.buffer_length = int(max_pulse_dur * 2 / dt) + 10

    def wavelet_decompose(self, signal, levels=3, wavelet='db4'):
        """小波包分解（频段分离）"""
        if not PYWT_AVAILABLE:
            # 移动平均近似
            low = np.convolve(signal, np.ones(10)/10, mode='same')
            residual = signal - low
            mid = np.convolve(residual, np.ones(5)/5, mode='same')
            high = residual - mid
            return {'low': low, 'mid': mid, 'high': high}
        wp = pywt.WaveletPacket(data=signal, wavelet=wavelet,
                                mode='symmetric', maxlevel=levels)
        low = getattr(wp['a'*levels], 'data', np.zeros_like(signal))
        high = getattr(wp['d'*levels], 'data', np.zeros_like(signal))
        if len(low) != len(signal):
            low = np.interp(np.linspace(0,1,len(signal)), np.linspace(0,1,len(low)), low)
        if len(high) != len(signal):
            high = np.interp(np.linspace(0,1,len(signal)), np.linspace(0,1,len(high)), high)
        mid = signal - low - high
        return {'low': low, 'mid': mid, 'high': high}

    def economic_dispatch(self, devices, net_load, time_idx, dt, eco_mode=False):
        """上层经济调度：最小化期望总成本（购电 + 储能运维 + 老化 + 燃料 + 可选碳惩罚）"""
        n = len(devices)
        if n == 0:
            return np.array([])

        # 分时电价（南京冬季工商业）
        hour = (time_idx * dt) / 3600 % 24
        if 0 <= hour < 6 or 11 <= hour < 13:
            price = PRICE_VALLEY
        elif 14 <= hour < 22:
            price = PRICE_PEAK
        else:
            price = PRICE_FLAT

        # 负荷跟踪惩罚系数
        track_penalty = 5.0        # 元/MW

        # 生成净负荷场景（如果启用随机规划）
        if self.stochastic:
            # 固定随机种子，保证可重复性
            np.random.seed(42 + time_idx)
            base = max(abs(net_load), 0.1)
            sigma = self.uncertainty_std * base
            scenarios = net_load + np.random.normal(0, sigma, self.n_scenarios)
            scenarios = np.maximum(scenarios, 0)   # 净负荷不能为负
            weights = np.ones(self.n_scenarios) / self.n_scenarios
            self.last_scenarios = scenarios       # 保存用于可视化
        else:
            scenarios = np.array([net_load])
            weights = np.array([1.0])
            self.last_scenarios = None

        const = dt / 3600 * price * 1000          # 购电成本系数 (元/MW对应dt内的成本)

        def objective(x):
            total_power = np.sum(x)
            # 储能成本
            storage_cost = sum(
                dev._calc_op_cost(x[i], dt) +
                dev._calc_aging_cost(x[i], dt, dev.soc) +
                (dev._calc_fuel_cost(x[i], dt) if hasattr(dev, '_calc_fuel_cost') else 0.0)
                for i, dev in enumerate(devices)
            )
            # 期望购电成本
            expected_grid_cost = 0.0
            carbon_cost = 0.0
            for s, w in zip(scenarios, weights):
                grid_power = s - total_power
                if grid_power > 0:
                    expected_grid_cost += w * grid_power * const
                if eco_mode:
                    # 碳惩罚成本 = 购电电量 (kWh) * 碳因子 * 碳价格
                    carbon_cost += w * (grid_power * dt / 3600 * 1000) * CARBON_FACTOR * CARBON_PRICE
            # 负荷跟踪惩罚
            track_cost = track_penalty * (net_load - total_power) ** 2
            return expected_grid_cost + storage_cost + track_cost + carbon_cost

        bounds, x0 = [], []
        for dev in devices:
            max_charge = dev.get_charge_available() * 3600 / dt
            max_discharge = dev.get_discharge_available() * 3600 / dt
            p_min = -min(dev.power_rating, max_charge)
            p_max = min(dev.power_rating, max_discharge)
            bounds.append((p_min, p_max))
            x0.append(0.0)

        res = minimize(objective, x0, method='SLSQP', bounds=bounds,
                       options={'maxiter': 500, 'ftol': 1e-9})
        if not res.success:
            return np.zeros(n)
        return res.x

    def _allocate_frequency_power(self, devices, power_target, freq_type, dt):
        """按频段分配功率（边际成本优先，但高频设备指定）"""
        if abs(power_target) < 1e-6:
            return {}
        allocation = {}
        remaining = power_target

        if freq_type == 'high':
            # 高频设备：超级电容器、飞轮储能、超导磁储能
            # 第一优先级：超级电容器
            sc_devs = [d for d in devices if d.name == '超级电容器']
            if sc_devs:
                dev = sc_devs[0]
                charge_limit = -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)   # 负值
                discharge_limit = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt)  # 正值
                if remaining > 0:
                    assign = np.clip(remaining, 0, discharge_limit)
                else:
                    assign = np.clip(remaining, charge_limit, 0)
                if abs(assign) > 1e-6:
                    allocation[dev.name] = assign
                    remaining -= assign

            # 第二优先级：飞轮储能
            if abs(remaining) > 1e-6:
                fess_devs = [d for d in devices if d.name == '飞轮储能']
                if fess_devs:
                    dev = fess_devs[0]
                    charge_limit = -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                    discharge_limit = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt)
                    if remaining > 0:
                        assign = np.clip(remaining, 0, discharge_limit)
                    else:
                        assign = np.clip(remaining, charge_limit, 0)
                    if abs(assign) > 1e-6:
                        allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                        remaining -= assign

            # 第三优先级：超导磁储能
            if abs(remaining) > 1e-6:
                smes_devs = [d for d in devices if d.name == '超导磁储能']
                if smes_devs:
                    dev = smes_devs[0]
                    charge_limit = -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                    discharge_limit = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt)
                    if remaining > 0:
                        assign = np.clip(remaining, 0, discharge_limit)
                    else:
                        assign = np.clip(remaining, charge_limit, 0)
                    if abs(assign) > 1e-6:
                        allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                        remaining -= assign

        elif freq_type == 'mid':
            # 中频设备：飞轮储能、锂电池储能
            eligible = [d for d in devices if d.name in ['飞轮储能', '锂电池储能']]
            eligible.sort(key=lambda d: d.marginal_cost)
            for dev in eligible:
                if abs(remaining) < 1e-6:
                    break
                charge_limit = -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                discharge_limit = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt)
                if remaining > 0:
                    assign = min(remaining, discharge_limit)
                else:
                    assign = max(remaining, charge_limit)
                if abs(assign) > 1e-6:
                    allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                    remaining -= assign

        else:   # low
            # 低频设备：压缩空气储能、锂电池储能
            eligible = [d for d in devices if d.name in ['压缩空气储能', '锂电池储能']]
            eligible.sort(key=lambda d: d.marginal_cost)
            for dev in eligible:
                if abs(remaining) < 1e-6:
                    break
                charge_limit = -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                discharge_limit = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt)
                if remaining > 0:
                    assign = min(remaining, discharge_limit)
                else:
                    assign = max(remaining, charge_limit)
                if abs(assign) > 1e-6:
                    allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                    remaining -= assign

        return allocation

    def real_time_balance(self, devices, net_load, dt):
        """下层实时平衡：小波分解 + 频段分配"""
        if self._buffer is None:
            self._buffer = np.ones(self.buffer_length) * net_load
        else:
            self._buffer = np.roll(self._buffer, -1)
            self._buffer[-1] = net_load

        comp = self.wavelet_decompose(self._buffer, levels=2)
        high = comp['high'][-1] if len(comp['high']) else 0
        mid = comp['mid'][-1] if len(comp['mid']) else 0
        low = comp['low'][-1] if len(comp['low']) else 0

        alloc = {}
        # 高频分配
        alloc_high = self._allocate_frequency_power(devices, high, 'high', dt)
        for k, v in alloc_high.items():
            alloc[k] = alloc.get(k, 0.0) + v
        # 中频分配
        alloc_mid = self._allocate_frequency_power(devices, mid, 'mid', dt)
        for k, v in alloc_mid.items():
            alloc[k] = alloc.get(k, 0.0) + v
        # 低频分配
        alloc_low = self._allocate_frequency_power(devices, low, 'low', dt)
        for k, v in alloc_low.items():
            alloc[k] = alloc.get(k, 0.0) + v

        return alloc

# ==================== 四、混合储能系统主类 ====================

class HybridEnergyStorageSystem:
    def __init__(self):
        self.device_specs = {
            '飞轮储能': {'class': FESS},
            '超导磁储能': {'class': SMES},
            '超级电容器': {'class': SC},
            '锂电池储能': {'class': BESS},
            '压缩空气储能': {'class': CAES}
        }
        self.devices = []
        self.mpc = HierarchicalMPC(stochastic=True, n_scenarios=10, uncertainty_std=0.05)
        self.simulation_results = None
        self.monitor_window = None
        self.monitor_labels = {}
        self.total_cost_label = None
        self.grid_power_label = None
        self.trend_canvases = {}     # 用于存储趋势图的Canvas
        self.trend_data = {}          # 存储每个设备最近功率数据
        self.paused = False           # 暂停标志
        self.stop_flag = False        # 停止标志
        # 用于实时监控的累计总成本
        self.current_total_cost = 0.0
        self.current_grid_power = 0.0

    def create_devices(self, selected_names):
        self.devices = []
        for name in selected_names:
            dev_class = self.device_specs[name]['class']
            self.devices.append(dev_class())
            self.trend_data[name] = deque(maxlen=50)   # 初始化趋势数据

    def _clip_power_to_limits(self, power, dev, dt):
        """将单个设备的功率裁剪到可调范围内"""
        max_charge = dev.get_charge_available() * 3600 / dt
        max_discharge = dev.get_discharge_available() * 3600 / dt
        p_min = -min(dev.power_rating, max_charge)
        p_max = min(dev.power_rating, max_discharge)
        return np.clip(power, p_min, p_max)

    def _adjust_power_to_track(self, set_powers, devices, target, dt):
        """二次功率调整：若当前总功率与目标净负荷偏差超过TRACK_TOLERANCE，则按各设备剩余可调容量比例补充"""
        current_total = np.sum(set_powers)
        diff = target - current_total
        if abs(diff) < TRACK_TOLERANCE:
            return set_powers
        capacities = []
        for i, dev in enumerate(devices):
            max_charge = dev.get_charge_available() * 3600 / dt
            max_discharge = dev.get_discharge_available() * 3600 / dt
            p_min = -min(dev.power_rating, max_charge)
            p_max = min(dev.power_rating, max_discharge)
            if diff > 0:
                room = p_max - set_powers[i]
            else:
                room = set_powers[i] - p_min
            capacities.append(max(0, room))
        total_capacity = np.sum(capacities)
        if total_capacity < abs(diff):
            scale = 1.0
        else:
            scale = abs(diff) / total_capacity
        adjusted = set_powers.copy()
        for i in range(len(devices)):
            if capacities[i] > 0:
                if diff > 0:
                    adjusted[i] += capacities[i] * scale
                else:
                    adjusted[i] -= capacities[i] * scale
        return adjusted

    def _enforce_no_sellback(self, set_powers, demand):
        """强制不允许向电网售电：当总功率超过净负荷时，削减放电功率；若无放电设备，则削减充电功率"""
        total = np.sum(set_powers)
        if total <= demand + 1e-6:
            return set_powers
        excess = total - demand
        discharge_indices = [i for i, p in enumerate(set_powers) if p > 0]
        if discharge_indices:
            # 削减放电设备
            discharge_powers = np.array([set_powers[i] for i in discharge_indices])
            total_discharge = np.sum(discharge_powers)
            reduction_factors = discharge_powers / total_discharge
            reductions = reduction_factors * excess
            for idx, red in zip(discharge_indices, reductions):
                set_powers[idx] = max(0, set_powers[idx] - red)
        else:
            # 所有设备都在充电，需要减少充电功率（即增加放电，但这里只能减少充电深度）
            # 削减充电设备（即减少充电功率绝对值）
            charge_indices = [i for i, p in enumerate(set_powers) if p < 0]
            if charge_indices:
                charge_powers = np.array([set_powers[i] for i in charge_indices])
                # 按充电功率绝对值比例分配 excess，使充电功率向零移动
                abs_charges = np.abs(charge_powers)
                total_abs = np.sum(abs_charges)
                if total_abs > 0:
                    reductions = excess * (abs_charges / total_abs)
                    for idx, red in zip(charge_indices, reductions):
                        set_powers[idx] = min(0, set_powers[idx] + red)   # 加上正数，使功率向零移动
        return set_powers

    def _update_trend_graph(self, dev_name, power):
        """更新趋势图数据并重绘"""
        max_points = 50
        if dev_name not in self.trend_data:
            self.trend_data[dev_name] = deque(maxlen=max_points)
        data = self.trend_data[dev_name]
        data.append(power)

        if dev_name in self.trend_canvases:
            canvas = self.trend_canvases[dev_name]
            canvas.delete("trend")
            if len(data) < 2:
                return
            w = canvas.winfo_width()
            h = canvas.winfo_height()
            if w <= 1 or h <= 1:
                return
            points = []
            for i, val in enumerate(data):
                x = (i / (max_points - 1)) * w
                dev = next(d for d in self.devices if d.name == dev_name)
                rating = dev.power_rating
                y = h/2 - (val / rating) * (h/2 - 5)
                points.append((x, y))
            if len(points) > 1:
                canvas.create_line(points, fill=COLOR_ACCENT, width=2, tags="trend")
                canvas.create_line(0, h/2, w, h/2, fill=COLOR_TEXT_SECONDARY, dash=(2,2), tags="trend")

    def simulate(self, pulse_amp, pulse_dur, plant_power=10.0, sim_time=30, dt=0.1, econ_interval=1, eco_mode=False):
        """主仿真循环"""
        # 固定随机种子以保证可重复性
        np.random.seed(42)
        time = np.arange(0, sim_time, dt)
        n = len(time)

        # 负荷：基础plant_power MW + 脉冲
        load = plant_power * np.ones_like(time)
        start = int(10.0 / dt)
        end = int((10.0 + pulse_dur) / dt)
        load[start:end] += pulse_amp

        plant = plant_power * np.ones_like(time)   # 电厂恒发
        net_load = load - plant

        # 动态设置MPC缓冲区长度
        self.mpc.set_buffer_length(dt, max(pulse_dur, 20))

        res = {
            'time': time, 'load': load, 'plant': plant, 'net_load': net_load,
            'smoothed_load': np.zeros_like(time),
            'total_ess': np.zeros_like(time),
            'grid_power': np.zeros_like(time),
            'grid_purchase': np.zeros_like(time),
            'device_power': {d.name: np.zeros_like(time) for d in self.devices},
            'device_soc': {d.name: np.zeros_like(time) for d in self.devices},
            'device_energy': {d.name: np.zeros_like(time) for d in self.devices},
            'device_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_op_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_aging_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_fuel_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_current': {d.name: np.zeros_like(time) for d in self.devices},
            'device_voltage': {d.name: np.zeros_like(time) for d in self.devices},
            'pulse_amp': pulse_amp, 'pulse_dur': pulse_dur,
            'eco_mode': eco_mode
        }
        # 将res赋值给self.sim_res，以便实时监控访问
        self.sim_res = res

        total_purchase = 0.0
        total_op = 0.0
        total_aging = 0.0
        total_fuel = 0.0
        total_carbon_penalty = 0.0

        last_econ_powers = np.zeros(len(self.devices))
        econ_cnt = 0

        # 初始化监控窗口
        self._update_monitor(init=True)
        self.paused = False
        self.stop_flag = False

        for t in range(n):
            # 处理暂停/停止
            while self.paused and not self.stop_flag:
                self.root.update()   # 保持GUI响应
                plt.pause(0.1)
            if self.stop_flag:
                break

            demand = net_load[t]

            # 上层经济调度 - 每 econ_interval 步执行一次
            if econ_cnt == 0:
                last_econ_powers = self.mpc.economic_dispatch(self.devices, demand, t, dt, eco_mode=eco_mode)
            econ_cnt = (econ_cnt + 1) % econ_interval

            # 下层实时平衡
            alloc = self.mpc.real_time_balance(self.devices, demand, dt)

            # 组合指令
            set_powers = last_econ_powers.copy()
            for i, dev in enumerate(self.devices):
                if dev.name in alloc:
                    set_powers[i] += alloc[dev.name]

            # 功率边界裁剪
            for i, dev in enumerate(self.devices):
                set_powers[i] = self._clip_power_to_limits(set_powers[i], dev, dt)

            # 二次功率调整
            set_powers = self._adjust_power_to_track(set_powers, self.devices, demand, dt)

            # 强制不允许向电网售电
            set_powers = self._enforce_no_sellback(set_powers, demand)

            total_ess = 0.0
            for i, dev in enumerate(self.devices):
                set_power = set_powers[i]
                soc, cost, energy = dev.update_state(set_power, dt)
                total_op += dev.history_op_cost[-1]
                total_aging += dev.history_aging_cost[-1]
                total_fuel += dev.history_fuel_cost[-1]

                res['device_power'][dev.name][t] = dev.current_power
                res['device_soc'][dev.name][t] = soc
                res['device_energy'][dev.name][t] = energy
                res['device_cost'][dev.name][t] = cost
                res['device_op_cost'][dev.name][t] = dev.history_op_cost[-1]
                res['device_aging_cost'][dev.name][t] = dev.history_aging_cost[-1]
                res['device_fuel_cost'][dev.name][t] = dev.history_fuel_cost[-1]
                res['device_current'][dev.name][t] = dev.current
                res['device_voltage'][dev.name][t] = dev.voltage

                total_ess += dev.current_power
                self._update_trend_graph(dev.name, dev.current_power)

            res['total_ess'][t] = total_ess
            res['smoothed_load'][t] = plant[t] + total_ess
            res['grid_power'][t] = max(0, demand - total_ess)

            # 购电费用
            hour = (t * dt) / 3600 % 24
            if 0 <= hour < 6 or 11 <= hour < 13:
                price = PRICE_VALLEY
            elif 14 <= hour < 22:
                price = PRICE_PEAK
            else:
                price = PRICE_FLAT
            if res['grid_power'][t] > 0:
                purchase = res['grid_power'][t] * dt / 3600 * price * 1000
                res['grid_purchase'][t] = purchase
                total_purchase += purchase
            if eco_mode:
                carbon_penalty = (res['grid_power'][t] * dt / 3600 * 1000) * CARBON_FACTOR * CARBON_PRICE
                total_carbon_penalty += carbon_penalty

            # 更新当前累计总成本，供监控面板使用
            self.current_total_cost = total_purchase + total_op + total_aging + total_fuel + total_carbon_penalty
            self.current_grid_power = res['grid_power'][t]

            # 每步更新一次监控（通过调用 update 使定时器触发）
            self._update_monitor(self.current_total_cost, self.current_grid_power)

            # 关键修改：主动处理GUI事件，使监控面板实时刷新
            self.root.update()

        self.total_purchase = total_purchase
        self.total_op = total_op
        self.total_aging = total_aging
        self.total_fuel = total_fuel
        self.total_carbon_penalty = total_carbon_penalty
        self.total_cost = self.current_total_cost
        self.net_cost = self.total_cost

        return res

    def _update_monitor(self, total_cost=None, grid_power=None, init=False):
        """实时监控面板（显示功率/SOC/可充放电量/电流/电压/功率趋势，越界红色预警）"""
        if init:
            if self.monitor_window is not None:
                try:
                    self.monitor_window.destroy()
                except:
                    pass
            self.monitor_window = tk.Toplevel()
            self.monitor_window.title("储能系统实时监控 (经济分配 + 高精度跟踪 + 随机规划)")
            self.monitor_window.geometry("950x750")
            self.monitor_window.configure(bg=COLOR_BG)

            # 创建主画布和滚动条，以便容纳更多设备
            canvas = tk.Canvas(self.monitor_window, bg=COLOR_BG, highlightthickness=0)
            scrollbar = tk.Scrollbar(self.monitor_window, orient="vertical", command=canvas.yview)
            scrollable_frame = ttk.Frame(canvas)
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)

            self.monitor_labels = {}

            for dev in self.devices:
                # 卡片式Frame
                frame = tk.Frame(scrollable_frame, bg=COLOR_CARD, relief='solid', bd=1)
                frame.pack(fill='x', padx=15, pady=8)

                # 标题（设备名）
                title_label = tk.Label(frame, text=dev.name, font=('微软雅黑', 11, 'bold'),
                                      bg=COLOR_PRIMARY, fg='white', anchor='w', padx=8)
                title_label.pack(fill='x', pady=(0,5))

                # 内容区域（使用内部Frame布局）
                content = tk.Frame(frame, bg=COLOR_CARD)
                content.pack(fill='x', padx=5, pady=5)

                # 第一行：功率、SOC
                tk.Label(content, text="功率 (MW):", bg=COLOR_CARD, font=('微软雅黑',9),
                         fg=COLOR_TEXT).grid(row=0, column=0, sticky='w', padx=5)
                l1 = tk.Label(content, text="0.00", width=8, bg=COLOR_CARD,
                              font=('微软雅黑',9,'bold'), fg=COLOR_ACCENT)
                l1.grid(row=0, column=1, sticky='w')
                tk.Label(content, text="SOC:", bg=COLOR_CARD, font=('微软雅黑',9),
                         fg=COLOR_TEXT).grid(row=0, column=2, sticky='w', padx=(15,0))
                l2 = tk.Label(content, text="0.80", width=6, bg=COLOR_CARD,
                              font=('微软雅黑',9,'bold'), fg=COLOR_SUCCESS)
                l2.grid(row=0, column=3, sticky='w')

                # 第二行：可充、可放
                tk.Label(content, text="可充(MWh):", bg=COLOR_CARD, font=('微软雅黑',9),
                         fg=COLOR_TEXT).grid(row=1, column=0, sticky='w', padx=5)
                l3 = tk.Label(content, text="0.00", width=8, bg=COLOR_CARD,
                              font=('微软雅黑',9,'bold'), fg=COLOR_ACCENT)
                l3.grid(row=1, column=1, sticky='w')
                tk.Label(content, text="可放(MWh):", bg=COLOR_CARD, font=('微软雅黑',9),
                         fg=COLOR_TEXT).grid(row=1, column=2, sticky='w', padx=(15,0))
                l4 = tk.Label(content, text="0.00", width=8, bg=COLOR_CARD,
                              font=('微软雅黑',9,'bold'), fg=COLOR_ACCENT)
                l4.grid(row=1, column=3, sticky='w')

                # 第三行：电流、电压
                tk.Label(content, text="电流 (A):", bg=COLOR_CARD, font=('微软雅黑',9),
                         fg=COLOR_TEXT).grid(row=2, column=0, sticky='w', padx=5)
                l5 = tk.Label(content, text="0.0", width=8, bg=COLOR_CARD,
                              font=('微软雅黑',9,'bold'), fg=COLOR_ACCENT)
                l5.grid(row=2, column=1, sticky='w')
                tk.Label(content, text="电压 (V):", bg=COLOR_CARD, font=('微软雅黑',9),
                         fg=COLOR_TEXT).grid(row=2, column=2, sticky='w', padx=(15,0))
                l6 = tk.Label(content, text="0.0", width=8, bg=COLOR_CARD,
                              font=('微软雅黑',9,'bold'), fg=COLOR_ACCENT)
                l6.grid(row=2, column=3, sticky='w')

                # 第四行：功率裕度
                tk.Label(content, text="功率裕度:", bg=COLOR_CARD, font=('微软雅黑',9),
                         fg=COLOR_TEXT).grid(row=3, column=0, sticky='w', padx=5)
                l7 = tk.Label(content, text="100%", width=6, bg=COLOR_CARD,
                              font=('微软雅黑',9,'bold'), fg=COLOR_ACCENT)
                l7.grid(row=3, column=1, sticky='w')

                # 创新：功率趋势图 (小型Canvas)
                trend_canvas = tk.Canvas(content, width=180, height=60,
                                         bg=COLOR_PRIMARY_LIGHT, highlightthickness=1,
                                         highlightbackground=COLOR_TEXT_SECONDARY)
                trend_canvas.grid(row=0, column=4, rowspan=4, padx=(15,5), sticky='nsew')
                self.trend_canvases[dev.name] = trend_canvas

                self.monitor_labels[dev.name] = (l1, l2, l3, l4, l5, l6, l7)

            # 底部全局信息
            bottom_frame = tk.Frame(scrollable_frame, bg=COLOR_PRIMARY_LIGHT, relief='sunken', bd=1)
            bottom_frame.pack(fill='x', padx=15, pady=10)

            tk.Label(bottom_frame, text="累计总成本(元):", font=('微软雅黑',10),
                     bg=COLOR_PRIMARY_LIGHT, fg=COLOR_TEXT).pack(side='left', padx=10)
            self.total_cost_label = tk.Label(bottom_frame, text="0.00", font=('微软雅黑',10,'bold'),
                                              bg=COLOR_PRIMARY_LIGHT, fg=COLOR_PRIMARY)
            self.total_cost_label.pack(side='left', padx=5)

            tk.Label(bottom_frame, text="电网功率(MW):", font=('微软雅黑',10),
                     bg=COLOR_PRIMARY_LIGHT, fg=COLOR_TEXT).pack(side='left', padx=(30,0))
            self.grid_power_label = tk.Label(bottom_frame, text="0.00", font=('微软雅黑',10,'bold'),
                                              bg=COLOR_PRIMARY_LIGHT, fg=COLOR_SUCCESS)
            self.grid_power_label.pack(side='left', padx=5)

            # 控制按钮
            btn_frame = tk.Frame(bottom_frame, bg=COLOR_PRIMARY_LIGHT)
            btn_frame.pack(side='right', padx=10)
            self.pause_btn = tk.Button(btn_frame, text="⏸️ 暂停", command=self.toggle_pause,
                                       bg=COLOR_WARNING, fg='white', font=('微软雅黑',9))
            self.pause_btn.pack(side='left', padx=5)
            self.stop_btn = tk.Button(btn_frame, text="⏹️ 停止", command=self.stop_sim,
                                      bg=COLOR_DANGER, fg='white', font=('微软雅黑',9))
            self.stop_btn.pack(side='left', padx=5)

            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            self.monitor_window.update()

            # 启动定时刷新
            self._schedule_monitor_update()
        else:
            if self.monitor_window is None:
                return
            for dev in self.devices:
                if dev.name in self.monitor_labels:
                    l1, l2, l3, l4, l5, l6, l7 = self.monitor_labels[dev.name]
                    l1.config(text=f"{dev.current_power:.3f}")
                    l2.config(text=f"{dev.soc:.3f}")
                    l3.config(text=f"{dev.get_charge_available():.3f}")
                    l4.config(text=f"{dev.get_discharge_available():.3f}")
                    if abs(dev.current) > 999:
                        l5.config(text=f"{dev.current/1000:.2f}k")
                    else:
                        l5.config(text=f"{dev.current:.1f}")
                    l6.config(text=f"{dev.voltage:.1f}")

                    # SOC越界红色预警
                    if dev.soc < SOC_MIN + 0.01 or dev.soc > SOC_MAX - 0.01:
                        l2.config(foreground=COLOR_DANGER)
                    else:
                        l2.config(foreground=COLOR_SUCCESS)

                    # 功率裕度预警
                    ratio = abs(dev.current_power) / dev.power_rating * 100
                    if ratio > 90:
                        l7.config(text=f"{ratio:.0f}%", foreground=COLOR_DANGER)
                    elif ratio > 75:
                        l7.config(text=f"{ratio:.0f}%", foreground=COLOR_WARNING)
                    else:
                        l7.config(text=f"{ratio:.0f}%", foreground=COLOR_ACCENT)

            # 更新总成本和电网功率标签
            if total_cost is not None and self.total_cost_label:
                self.total_cost_label.config(text=f"{total_cost:,.2f}")
            if grid_power is not None and self.grid_power_label:
                self.grid_power_label.config(text=f"{grid_power:.3f}")

    def _schedule_monitor_update(self):
        """定时刷新监控面板"""
        if self.monitor_window is not None:
            # 从当前累计成本变量读取最新值
            self._update_monitor(self.current_total_cost if hasattr(self, 'current_total_cost') else None,
                                 self.current_grid_power if hasattr(self, 'current_grid_power') else None)
            self.monitor_window.after(200, self._schedule_monitor_update)

    def toggle_pause(self):
        """切换暂停状态"""
        self.paused = not self.paused
        self.pause_btn.config(text="▶️ 继续" if self.paused else "⏸️ 暂停")

    def stop_sim(self):
        """停止仿真"""
        self.stop_flag = True

    def close_monitor(self):
        """关闭实时监控窗口"""
        if self.monitor_window:
            self.monitor_window.destroy()
            self.monitor_window = None

# ==================== 五、GUI用户界面 ====================

class HESSGUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("混合储能脉冲平滑控制(20MW/480MWh) - 经济分配 + 高精度跟踪 + 随机规划")
        self.root.geometry("720x850")
        self.root.configure(bg=COLOR_BG)

        # 设置ttk样式
        self.style = ttk.Style()
        self.style.theme_use('clam')
        self.style.configure('TLabel', background=COLOR_BG, foreground=COLOR_TEXT, font=('微软雅黑', 9))
        self.style.configure('TLabelframe', background=COLOR_BG, foreground=COLOR_PRIMARY,
                              font=('微软雅黑', 10, 'bold'), relief='solid', bordercolor=COLOR_PRIMARY)
        self.style.configure('TLabelframe.Label', background=COLOR_BG, foreground=COLOR_PRIMARY)
        self.style.configure('TCheckbutton', background=COLOR_BG, foreground=COLOR_TEXT, font=('微软雅黑', 11))
        self.style.configure('TButton', font=('微软雅黑', 12), padding=5,
                             background=COLOR_PRIMARY, foreground='white',
                             bordercolor=COLOR_PRIMARY, focuscolor='none')
        self.style.map('TButton',
                       background=[('active', COLOR_ACCENT), ('pressed', '#0B3B7A')],
                       foreground=[('active', 'white')])
        self.style.configure('TProgressbar', background=COLOR_ACCENT, troughcolor=COLOR_PRIMARY_LIGHT)

        self.pulse_amp = tk.DoubleVar(value=12.0)
        self.pulse_dur = tk.DoubleVar(value=10.0)
        self.plant_power = tk.DoubleVar(value=10.0)        # 微电网规模（电厂恒发功率）
        self.dev_vars = {
            '飞轮储能': tk.BooleanVar(value=True),
            '超导磁储能': tk.BooleanVar(value=True),
            '超级电容器': tk.BooleanVar(value=True),
            '锂电池储能': tk.BooleanVar(value=True),
            '压缩空气储能': tk.BooleanVar(value=True)
        }
        self.use_stochastic = tk.BooleanVar(value=True)
        self.n_scenarios = tk.IntVar(value=10)
        self.uncertainty_std = tk.DoubleVar(value=0.05)
        self.eco_mode = tk.BooleanVar(value=False)        # 环保模式
        self.sim_running = False                           # 防止重复点击
        self.setup_ui()

    def setup_ui(self):
        # 标题
        tk.Label(self.root, text="混合储能系统(HESS)脉冲平滑控制",
                 font=("微软雅黑", 18, "bold"), bg=COLOR_BG, fg=COLOR_PRIMARY).pack(pady=(15,5))

        # 脉冲参数设置区域（上下排列）
        pf = ttk.LabelFrame(self.root, text="⚡ 脉冲参数设置", padding=10)
        pf.pack(padx=20, pady=10, fill='x')

        # 幅值滑块（上）
        frame_amp = ttk.Frame(pf)
        frame_amp.pack(fill='x', pady=5)
        ttk.Label(frame_amp, text="脉冲幅值 (MW):", width=15, anchor='w').pack(side='left')
        scale_amp = tk.Scale(frame_amp, from_=1, to=20, orient='horizontal',
                             variable=self.pulse_amp, length=280, bg=COLOR_CARD,
                             troughcolor=COLOR_PRIMARY_LIGHT, highlightthickness=0,
                             fg=COLOR_TEXT)
        scale_amp.pack(side='left', padx=5)
        ttk.Label(frame_amp, textvariable=self.pulse_amp, width=4).pack(side='left')

        # 持续时间滑块（下）
        frame_dur = ttk.Frame(pf)
        frame_dur.pack(fill='x', pady=5)
        ttk.Label(frame_dur, text="脉冲持续时间 (s):", width=15, anchor='w').pack(side='left')
        scale_dur = tk.Scale(frame_dur, from_=1, to=20, orient='horizontal',
                             variable=self.pulse_dur, length=280, bg=COLOR_CARD,
                             troughcolor=COLOR_PRIMARY_LIGHT, highlightthickness=0,
                             fg=COLOR_TEXT)
        scale_dur.pack(side='left', padx=5)
        ttk.Label(frame_dur, textvariable=self.pulse_dur, width=4).pack(side='left')

        # 微电网规模（电厂出力）
        mg_frame = ttk.Frame(pf)
        mg_frame.pack(fill='x', pady=5)
        ttk.Label(mg_frame, text="电厂恒发功率 (MW):", width=15, anchor='w').pack(side='left')
        ttk.Spinbox(mg_frame, from_=1, to=20, textvariable=self.plant_power,
                    width=8, font=('微软雅黑',10)).pack(side='left', padx=5)
        ttk.Label(mg_frame, text="MW", font=('微软雅黑',10)).pack(side='left')

        # 随机规划参数区域
        spf = ttk.LabelFrame(self.root, text="🎲 随机规划参数", padding=10)
        spf.pack(padx=20, pady=10, fill='x')

        chk_stoch = ttk.Checkbutton(spf, text="启用随机规划", variable=self.use_stochastic)
        chk_stoch.pack(anchor='w')
        frame_scen = ttk.Frame(spf)
        frame_scen.pack(fill='x', pady=5)
        ttk.Label(frame_scen, text="场景数量:").pack(side='left')
        ttk.Spinbox(frame_scen, from_=1, to=50, textvariable=self.n_scenarios,
                    width=5).pack(side='left', padx=5)
        ttk.Label(frame_scen, text="预测误差标准差 (%):").pack(side='left', padx=(15,0))
        ttk.Spinbox(frame_scen, from_=1, to=30, textvariable=self.uncertainty_std,
                    width=5, format="%.2f").pack(side='left', padx=5)

        # 高级选项区域（创新设计）
        advf = ttk.LabelFrame(self.root, text="🌿 高级选项 (创新设计)", padding=10)
        advf.pack(padx=20, pady=10, fill='x')
        chk_eco = ttk.Checkbutton(advf, text="环保模式 (考虑碳减排惩罚)", variable=self.eco_mode)
        chk_eco.pack(anchor='w')
        ttk.Label(advf, text="碳价格: 0.05 元/kg CO₂ (固定)", font=('微软雅黑',9),
                  foreground=COLOR_TEXT_SECONDARY).pack(anchor='w', padx=20)

        # 储能设备选择区域
        df = ttk.LabelFrame(self.root, text="🔋 储能设备选择 (总功率20MW/总容量480MWh)", padding=10)
        df.pack(padx=20, pady=10, fill='x')
        dev_frame = ttk.Frame(df)
        dev_frame.pack()
        for i, (name, var) in enumerate(self.dev_vars.items()):
            row, col = divmod(i, 2)
            ttk.Checkbutton(dev_frame, text=name, variable=var).grid(row=row, column=col, sticky='w', padx=10, pady=2)

        # 按钮区域
        btnf = ttk.Frame(self.root)
        btnf.pack(pady=15)
        self.start_btn = ttk.Button(btnf, text="⚡ 开始仿真", command=self.run_sim, width=16)
        self.start_btn.pack(side='left', padx=8)
        ttk.Button(btnf, text="❌ 退出", command=self.root.quit, width=16).pack(side='left', padx=8)

        # 状态标签（创意动态提示）
        self.status = tk.Label(self.root, text="✨ 就绪，请设置参数并选择设备", font=("微软雅黑", 10),
                               bg=COLOR_BG, fg=COLOR_ACCENT)
        self.status.pack(pady=5)

        # 进度条（模拟仿真进度）
        self.progress = ttk.Progressbar(self.root, orient='horizontal', length=400, mode='indeterminate')
        self.progress.pack(pady=5)

        # 创意小贴士
        tip_frame = tk.Frame(self.root, bg=COLOR_PRIMARY_LIGHT, relief='solid', bd=1)
        tip_frame.pack(padx=20, pady=10, fill='x')
        tk.Label(tip_frame, text="💡 创意小贴士", font=('微软雅黑', 10, 'bold'),
                 bg=COLOR_PRIMARY_LIGHT, fg=COLOR_PRIMARY).pack(anchor='w', padx=10, pady=5)
        tips = [
            "✓ 可自定义微电网规模（电厂出力），模拟不同场景",
            "✓ 环保模式将在经济调度中加入碳成本，引导绿色运行",
            "✓ 实时监控面板新增功率趋势图，动态显示功率变化",
            "✓ 平滑评分满分100，分数越高平滑效果越好",
            "✓ 所有图形轴标签已修正，布局清晰无重叠",
            "✓ 电流值基于低压系统计算，实际工程中可采用更高电压或多组并联降低电流",
            "✓ 新增暂停/继续、停止仿真功能，便于交互",
            "✓ 随机规划场景图改进为折线+置信区间"
        ]
        for tip in tips:
            tk.Label(tip_frame, text=tip, font=('微软雅黑',9), bg=COLOR_PRIMARY_LIGHT,
                     fg=COLOR_TEXT, anchor='w').pack(anchor='w', padx=20)

    def run_sim(self):
        if self.sim_running:
            messagebox.showinfo("提示", "仿真正在进行中，请稍候...")
            return

        # 用户输入校验
        amp = self.pulse_amp.get()
        dur = self.pulse_dur.get()
        plant_power = self.plant_power.get()
        if amp <= 0 or dur <= 0 or plant_power <= 0:
            messagebox.showerror("错误", "脉冲幅值、持续时间和电厂功率必须为正数！")
            return

        selected = [name for name, var in self.dev_vars.items() if var.get()]
        if not selected:
            messagebox.showerror("错误", "至少选择一个储能设备！")
            return

        # 禁用开始按钮，启动进度条
        self.start_btn.config(state='disabled')
        self.status.config(text="🚀 仿真进行中... 正在消除脉冲...", fg=COLOR_WARNING)
        self.progress.start(10)
        self.root.update()

        self.sim_running = True
        try:
            hess = HybridEnergyStorageSystem()
            hess.root = self.root          # 传递主窗口以便控制暂停
            hess.mpc.stochastic = self.use_stochastic.get()
            hess.mpc.n_scenarios = self.n_scenarios.get()
            hess.mpc.uncertainty_std = self.uncertainty_std.get()
            hess.create_devices(selected)
            results = hess.simulate(amp, dur, plant_power=plant_power,
                                    econ_interval=1, eco_mode=self.eco_mode.get())
            # 仿真结束后更新状态
            self.status.config(text="✅ 仿真完成！平滑后负荷与原始负荷高度重合", fg=COLOR_SUCCESS)
            self.start_btn.config(state='normal')
            self.progress.stop()
            self.sim_running = False
            # 弹出详细结果窗口
            self.show_results(hess, results, amp, dur, selected)
        except Exception as e:
            messagebox.showerror("错误", f"仿真异常：{str(e)}")
            self.status.config(text="❌ 仿真失败", fg=COLOR_DANGER)
            self.start_btn.config(state='normal')
            self.progress.stop()
            self.sim_running = False

    def show_results(self, hess, res, amp, dur, selected):
        # 汇总成本
        total_purchase = hess.total_purchase
        total_op = hess.total_op
        total_aging = hess.total_aging
        total_fuel = hess.total_fuel
        total_carbon = hess.total_carbon_penalty
        total_cost = hess.total_cost
        net_cost = hess.net_cost

        # 碳减排估算 (基于电网购电减少量，与无储能时对比)
        dt = res['time'][1] - res['time'][0]            # 获取仿真步长
        total_grid_without_storage = np.sum(np.maximum(res['net_load'], 0)) * dt / 3600   # MWh
        total_grid_with_storage = np.sum(res['grid_power']) * dt / 3600
        grid_reduction = total_grid_without_storage - total_grid_with_storage   # MWh
        carbon_reduction = grid_reduction * 1000 * CARBON_FACTOR                # kg CO₂

        # 各设备指标
        dev_charge = {}
        dev_discharge = {}
        dev_avg_p = {}
        dev_max_p = {}
        for dev in hess.devices:
            p = res['device_power'][dev.name]
            dev_charge[dev.name] = -np.sum(p[p < 0]) * dt / 3600
            dev_discharge[dev.name] = np.sum(p[p > 0]) * dt / 3600
            dev_avg_p[dev.name] = np.mean(np.abs(p))
            dev_max_p[dev.name] = np.max(np.abs(p))

        # 脉冲期间功率分配占比
        mask = (res['time'] >= 10) & (res['time'] < 10 + dur)
        pulse_power = {}
        for dev in hess.devices:
            avg = np.mean(np.abs(res['device_power'][dev.name][mask]))
            if avg > 0.01:
                pulse_power[dev.name] = avg

        # 计算平滑性能评分（基于脉冲幅值的相对误差）
        rmse = np.sqrt(np.mean((res['load'] - res['smoothed_load'])**2))
        pulse_amp_val = res['pulse_amp']
        smooth_score = max(0, min(100, 100 * (1 - rmse / (pulse_amp_val + 1e-6))))
        max_dev = np.max(np.abs(res['load'] - res['smoothed_load']))

        # 创建独立的结果窗口
        win = tk.Toplevel()
        win.title("脉冲平滑仿真详细结果")
        win.geometry("1100x900")
        win.configure(bg=COLOR_BG)

        main_frame = tk.Frame(win, bg=COLOR_BG)
        main_frame.pack(fill='both', expand=True, padx=10, pady=10)

        # 上部关键指标摘要
        summary_frame = tk.LabelFrame(main_frame, text="🌟 关键指标摘要", bg=COLOR_BG,
                                       font=('微软雅黑',11,'bold'), fg=COLOR_PRIMARY,
                                       relief='solid', bd=1, padx=10, pady=5)
        summary_frame.pack(fill='x', pady=(0,10))

        row1 = tk.Frame(summary_frame, bg=COLOR_BG)
        row1.pack(fill='x', pady=2)
        tk.Label(row1, text="平滑效果评分:", bg=COLOR_BG, font=('微软雅黑',10),
                 fg=COLOR_TEXT).pack(side='left')
        score_color = COLOR_SUCCESS if smooth_score >= 80 else (COLOR_WARNING if smooth_score >= 60 else COLOR_DANGER)
        tk.Label(row1, text=f"{smooth_score:.1f} 分 (满分100)", bg=COLOR_BG, font=('微软雅黑',12,'bold'),
                 fg=score_color).pack(side='left', padx=5)
        tk.Label(row1, text="总成本:", bg=COLOR_BG, font=('微软雅黑',10),
                 fg=COLOR_TEXT).pack(side='left', padx=(20,0))
        tk.Label(row1, text=f"{total_cost:,.0f} 元", bg=COLOR_BG, font=('微软雅黑',12,'bold'),
                 fg=COLOR_PRIMARY).pack(side='left', padx=5)

        row2 = tk.Frame(summary_frame, bg=COLOR_BG)
        row2.pack(fill='x', pady=2)
        tk.Label(row2, text="电网购电比例:", bg=COLOR_BG, font=('微软雅黑',10),
                 fg=COLOR_TEXT).pack(side='left')
        grid_ratio = total_purchase / (total_purchase + total_op + total_aging + total_fuel + total_carbon + 1e-9) * 100
        tk.Label(row2, text=f"{grid_ratio:.1f}%", bg=COLOR_BG, font=('微软雅黑',10,'bold'),
                 fg=COLOR_ACCENT).pack(side='left', padx=5)
        tk.Label(row2, text="最大瞬时偏差:", bg=COLOR_BG, font=('微软雅黑',10),
                 fg=COLOR_TEXT).pack(side='left', padx=(20,0))
        tk.Label(row2, text=f"{max_dev:.3f} MW", bg=COLOR_BG, font=('微软雅黑',10,'bold'),
                 fg=COLOR_DANGER).pack(side='left', padx=5)

        # 碳减排指标
        row3 = tk.Frame(summary_frame, bg=COLOR_BG)
        row3.pack(fill='x', pady=2)
        tk.Label(row3, text="🌿 碳减排量:", bg=COLOR_BG, font=('微软雅黑',10),
                 fg=COLOR_TEXT).pack(side='left')
        tk.Label(row3, text=f"{carbon_reduction:.2f} kg CO₂", bg=COLOR_BG, font=('微软雅黑',12,'bold'),
                 fg=COLOR_SUCCESS).pack(side='left', padx=5)
        if res.get('eco_mode', False):
            tk.Label(row3, text="(环保模式开启)", bg=COLOR_BG, font=('微软雅黑',9),
                     fg=COLOR_SUCCESS).pack(side='left', padx=10)

        if pulse_power:
            row4 = tk.Frame(summary_frame, bg=COLOR_BG)
            row4.pack(fill='x', pady=2)
            tk.Label(row4, text="🎯 脉冲主导设备:", bg=COLOR_BG, font=('微软雅黑',10),
                     fg=COLOR_TEXT).pack(side='left')
            main_dev = max(pulse_power, key=pulse_power.get)
            tk.Label(row4, text=f"{main_dev} ({pulse_power[main_dev]:.2f} MW)", bg=COLOR_BG,
                     font=('微软雅黑',10,'bold'), fg=COLOR_WARNING).pack(side='left', padx=5)

        # 按钮框架
        btn_frame = tk.Frame(main_frame, bg=COLOR_BG)
        btn_frame.pack(fill='x', pady=5)
        ttk.Button(btn_frame, text="📊 显示详细特性曲线", command=lambda: self.plot_all(hess, res), width=25).pack(side='left', padx=5)
        if hess.mpc.stochastic and hess.mpc.last_scenarios is not None:
            ttk.Button(btn_frame, text="🎲 显示随机规划场景", command=lambda: self.plot_scenarios(hess.mpc.last_scenarios),
                       width=20).pack(side='left', padx=5)
        ttk.Button(btn_frame, text="💾 导出报告", command=lambda: self.export_report(hess, res, selected, amp, dur, total_cost, carbon_reduction, smooth_score),
                   width=15).pack(side='left', padx=5)

        # 详细文本区域
        text_frame = tk.Frame(main_frame, bg=COLOR_BG)
        text_frame.pack(fill='both', expand=True, pady=5)
        text = tk.Text(text_frame, wrap='word', font=('微软雅黑', 10), bg=COLOR_CARD,
                       relief='solid', bd=1, padx=10, pady=10, fg=COLOR_TEXT)
        scroll = tk.Scrollbar(text_frame, command=text.yview)
        text.config(yscrollcommand=scroll.set)
        text.pack(side='left', fill='both', expand=True)
        scroll.pack(side='right', fill='y')

        text.insert('end', "="*90 + "\n")
        text.insert('end', "★ 混合储能系统脉冲平滑仿真详细数据 ★\n")
        text.insert('end', "="*90 + "\n\n")
        text.insert('end', f"微电网规模 (电厂恒发功率): {res['plant'][0]:.2f} MW\n")
        text.insert('end', f"脉冲幅值: {amp:.2f} MW\n")
        text.insert('end', f"脉冲持续时间: {dur:.2f} s\n")
        text.insert('end', f"环保模式: {'开启' if res.get('eco_mode',False) else '关闭'}\n\n")

        text.insert('end', "【随机规划设置】\n")
        text.insert('end', f"  启用随机规划: {hess.mpc.stochastic}\n")
        if hess.mpc.stochastic:
            text.insert('end', f"  场景数量: {hess.mpc.n_scenarios}\n")
            text.insert('end', f"  预测误差标准差: {hess.mpc.uncertainty_std*100:.1f}%\n")
        text.insert('end', "\n")

        text.insert('end', "【储能设备配置】总功率20MW / 总容量480MWh\n")
        for name in selected:
            spec = hess.device_specs[name]['class']
            tmp_dev = spec()
            text.insert('end', f"  {name}: 功率 {tmp_dev.power_rating:.1f} MW, 容量 {tmp_dev.capacity:.1f} MWh, "
                         f"边际成本 {tmp_dev.marginal_cost:.2f} 元/MW/h\n")
        text.insert('end', "\n")

        text.insert('end', "【平滑性能】\n")
        text.insert('end', f"  平滑后负荷与原始负荷 RMSE: {rmse:.4f} MW\n")
        text.insert('end', f"  最大瞬时偏差: {max_dev:.4f} MW (电网承担)\n")
        text.insert('end', f"  总偏差能量: {np.sum(np.abs(res['load'] - res['smoothed_load'])) * dt / 3600:.2f} MWh\n")
        text.insert('end', f"  平滑评分: {smooth_score:.1f} 分 (满分100，越高越好)\n\n")

        text.insert('end', "【经济性指标 (元)】\n")
        text.insert('end', f"  购电支出: {total_purchase:,.2f}\n")
        text.insert('end', f"  运维成本: {total_op:,.2f}\n")
        text.insert('end', f"  老化成本: {total_aging:,.2f}\n")
        text.insert('end', f"  燃料成本: {total_fuel:,.2f}\n")
        if total_carbon > 0:
            text.insert('end', f"  碳惩罚成本: {total_carbon:,.2f}\n")
        text.insert('end', f"  → 总成本: {total_cost:,.2f}\n")
        text.insert('end', f"  → 净成本: {net_cost:,.2f}\n\n")

        text.insert('end', "【环境效益】\n")
        text.insert('end', f"  电网购电减少量: {grid_reduction:.3f} MWh\n")
        text.insert('end', f"  等效碳减排: {carbon_reduction:.2f} kg CO₂\n\n")

        text.insert('end', "【各设备成本构成】\n")
        text.insert('end', f"{'设备名称':<16} {'运维成本':<12} {'老化成本':<12} {'燃料成本':<12} {'总成本':<12}\n")
        text.insert('end', "-"*70 + "\n")
        for dev in hess.devices:
            op_sum = np.sum(res['device_op_cost'][dev.name])
            aging_sum = np.sum(res['device_aging_cost'][dev.name])
            fuel_sum = np.sum(res['device_fuel_cost'][dev.name])
            total_dev = op_sum + aging_sum + fuel_sum
            text.insert('end', f"{dev.name:<16} {op_sum:<12.2f} {aging_sum:<12.2f} {fuel_sum:<12.2f} {total_dev:<12.2f}\n")
        text.insert('end', "\n")

        text.insert('end', "【脉冲期间功率分配策略 (边际成本优先 + 频段分配)】\n")
        total_pulse_power = sum(pulse_power.values())
        for name, avg in pulse_power.items():
            ratio = avg / total_pulse_power * 100 if total_pulse_power > 0 else 0
            text.insert('end', f"  {name}: {avg:.3f} MW ({ratio:.1f}%)\n")
        text.insert('end', "\n")

        text.insert('end', "【各设备充放电统计】\n")
        text.insert('end', f"{'设备名称':<16} {'充电量(MWh)':<12} {'放电量(MWh)':<12} "
                     f"{'平均功率(MW)':<12} {'最大功率(MW)':<12}\n")
        text.insert('end', "-"*70 + "\n")
        for dev in hess.devices:
            text.insert('end', f"{dev.name:<16} {dev_charge[dev.name]:<12.4f} {dev_discharge[dev.name]:<12.4f} "
                         f"{dev_avg_p[dev.name]:<12.4f} {dev_max_p[dev.name]:<12.4f}\n")
        text.insert('end', "\n")

        text.insert('end', "【详细边界约束】\n")
        text.insert('end', " • 电厂额定功率: 13 MW (实际恒发可配置)\n")
        text.insert('end', " • 储能系统总功率上限: 20 MW (已满配)\n")
        text.insert('end', " • 储能系统总容量: 480 MWh\n")
        text.insert('end', f" • 各设备SOC安全区间: [{SOC_MIN}, {SOC_MAX}] (越界自动限功率，监控红色预警)\n")
        text.insert('end', " • 初始SOC提高至0.8，确保脉冲放电能力\n")
        text.insert('end', " • 脉冲幅值上限: 20 MW，持续时间上限: 20 s\n")
        text.insert('end', " • 分时电价(南京冬季工商业): 低谷0.21、平段0.62、高峰1.12 元/kWh\n")
        text.insert('end', " • 天然气价格: 3.6 元/m³ (压缩空气储能)\n")
        text.insert('end', " • 非线性老化成本: 功率^1.8 + 放电深度影响\n")
        text.insert('end', " • 功率分配策略: 超级电容/飞轮优先承担高频，其他设备按边际成本补充\n")
        text.insert('end', " • 环保模式碳价格: 0.05 元/kg CO₂\n")
        text.insert('end', "\n")

        text.insert('end', "【工程合理性说明】\n")
        text.insert('end', " • 本仿真中电流值基于低压系统（如300V）单组计算，实际工程中可通过提高直流母线电压（如1500V）\n")
        text.insert('end', "   或多组并联方式降低电流，从而减少对母排的要求。此处为模型简化，不影响控制逻辑验证。\n")
        text.insert('end', "\n")
        text.insert('end', "【结论】脉冲已被高度平滑，平滑后负荷与原始负荷高度重合，符合经济调度原则，并带来环境效益。\n")
        text.config(state='disabled')

    def export_report(self, hess, res, selected, amp, dur, total_cost, carbon_reduction, smooth_score):
        """导出报告为文本文件"""
        from tkinter import filedialog
        filename = filedialog.asksaveasfilename(defaultextension=".txt",
                                                filetypes=[("Text files", "*.txt")])
        if not filename:
            return
        with open(filename, 'w', encoding='utf-8') as f:
            f.write("混合储能系统脉冲平滑仿真报告\n")
            f.write("="*50 + "\n")
            f.write(f"仿真时间: {res['time'][-1]:.1f} 秒\n")
            f.write(f"脉冲幅值: {amp:.2f} MW\n")
            f.write(f"脉冲持续时间: {dur:.2f} s\n")
            f.write(f"总成本: {total_cost:.2f} 元\n")
            f.write(f"碳减排量: {carbon_reduction:.2f} kg CO₂\n")
            f.write(f"平滑评分: {smooth_score:.1f}\n")
            f.write("\n设备清单:\n")
            for name in selected:
                f.write(f"  {name}\n")
        messagebox.showinfo("导出成功", f"报告已保存至 {filename}")

    def plot_scenarios(self, scenarios):
        """绘制随机规划生成的场景（折线图+置信区间）"""
        plt.figure(figsize=(10, 6))
        x = np.arange(len(scenarios))
        # 绘制所有场景折线
        for i, s in enumerate(scenarios):
            plt.plot(x, [s]*len(x), 'b-', alpha=0.2, linewidth=0.5)
        # 绘制均值线
        mean_val = np.mean(scenarios)
        std_val = np.std(scenarios)
        plt.axhline(mean_val, color='r', linestyle='--', label=f'均值: {mean_val:.2f} MW')
        plt.fill_between(x, mean_val - std_val, mean_val + std_val, color='r', alpha=0.2, label='±1σ 区间')
        plt.xlabel('场景编号')
        plt.ylabel('净负荷 (MW)')
        plt.title('随机规划生成的净负荷预测场景（当前时刻）')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()

    def plot_all(self, hess, res):
        """绘制所有要求的图形，动态适应所选设备，优化布局避免重叠"""
        try:
            # 确定子图布局：根据设备数量动态调整
            num_devices = len(hess.devices)
            # 我们固定为4x4，但某些子图仅在有对应设备时显示
            fig, axes = plt.subplots(4, 4, figsize=(18, 16))
            plt.rcParams['font.sans-serif'] = ['SimHei']
            axes = axes.flatten()

            # 1. 负荷跟踪效果（电厂+储能总出力跟踪负荷）
            ax = axes[0]
            ax.plot(res['time'], res['load'], 'r-', lw=2, label='原始负荷')
            ax.plot(res['time'], res['smoothed_load'], 'b--', lw=2, label='电厂+储能总出力')
            ax.plot(res['time'], res['plant'], 'g-', lw=1.5, label=f'电厂出力({res["plant"][0]:.0f}MW)')
            ax.fill_between(res['time'], res['load'], res['smoothed_load'], alpha=0.25, color='gray')
            ax.set_xlabel('时间 (秒)', fontsize=10)
            ax.set_ylabel('功率 (MW)', fontsize=10)
            ax.set_title('负荷跟踪效果（电厂+储能总出力）', fontsize=12)
            ax.legend(fontsize=8, loc='upper right')
            ax.grid(True, alpha=0.3)

            # 2. 脉冲期间功率分配饼图
            ax = axes[1]
            mask = (res['time'] >= 10) & (res['time'] < 10 + res['pulse_dur'])
            pulse_power = {}
            for dev in hess.devices:
                avg = np.mean(np.abs(res['device_power'][dev.name][mask]))
                if avg > 0.05:
                    pulse_power[dev.name] = avg
            if pulse_power:
                labels = list(pulse_power.keys())
                sizes = list(pulse_power.values())
                ax.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90,
                       textprops={'fontsize': 8})
                ax.set_title('脉冲期间功率分配策略', fontsize=12)
                ax.axis('equal')
            else:
                ax.text(0.5,0.5,'无脉冲数据', ha='center', va='center')
                ax.set_title('脉冲期间功率分配策略', fontsize=12)

            # 3. 各设备电流随时间变化
            ax = axes[2]
            for dev in hess.devices:
                step = max(1, len(res['time']) // 500)
                t_down = res['time'][::step]
                current_down = res['device_current'][dev.name][::step]
                current_smooth = gaussian_filter1d(current_down, sigma=0.5)
                ax.plot(t_down, current_smooth, label=dev.name, linewidth=1.5)
            ax.set_xlabel('时间 (秒)', fontsize=10)
            ax.set_ylabel('电流 (A)', fontsize=10)
            ax.set_title('各设备电流变化', fontsize=12)
            ax.legend(fontsize=7, loc='upper right')
            ax.grid(True, alpha=0.3)

            # 4. 各设备电压随时间变化
            ax = axes[3]
            for dev in hess.devices:
                step = max(1, len(res['time']) // 500)
                t_down = res['time'][::step]
                voltage_down = res['device_voltage'][dev.name][::step]
                voltage_smooth = gaussian_filter1d(voltage_down, sigma=0.5)
                ax.plot(t_down, voltage_smooth, label=dev.name, linewidth=1.5)
            ax.set_xlabel('时间 (秒)', fontsize=10)
            ax.set_ylabel('电压 (V)', fontsize=10)
            ax.set_title('各设备电压变化', fontsize=12)
            ax.legend(fontsize=7, loc='upper right')
            ax.grid(True, alpha=0.3)

            # 5. 超级电容器能量-电压 (如果存在)
            ax = axes[4]
            sc = next((d for d in hess.devices if '超级电容' in d.name), None)
            if sc:
                energy_kWh = res['device_energy'][sc.name] * 1000
                voltage = res['device_voltage'][sc.name]
                sc_plot = ax.scatter(energy_kWh, voltage, c=res['time'], cmap='viridis', alpha=0.7, s=10)
                ax.set_xlabel('储存能量 (kWh)', fontsize=10)
                ax.set_ylabel('电压 (V)', fontsize=10)
                ax.set_title('超级电容器能量-电压', fontsize=12)
                plt.colorbar(sc_plot, ax=ax, label='时间 (秒)', fraction=0.046, pad=0.04)
                ax.grid(True, alpha=0.3)
            else:
                ax.set_visible(False)   # 隐藏该子图

            # 6. 锂电池能量-电流 (如果存在)
            ax = axes[5]
            bess = next((d for d in hess.devices if '锂电池' in d.name), None)
            if bess:
                energy_kWh = res['device_energy'][bess.name] * 1000
                current_kA = res['device_current'][bess.name] / 1000
                bess_plot = ax.scatter(energy_kWh, current_kA, c=res['time'], cmap='plasma', alpha=0.7, s=10)
                ax.set_xlabel('储存能量 (kWh)', fontsize=10)
                ax.set_ylabel('电流 (kA)', fontsize=10)
                ax.set_title('锂电池储能能量-电流', fontsize=12)
                plt.colorbar(bess_plot, ax=ax, label='时间 (秒)', fraction=0.046, pad=0.04)
                ax.grid(True, alpha=0.3)
            else:
                ax.set_visible(False)

            # 7. 飞轮储能能量-电压 (如果存在)
            ax = axes[6]
            fess = next((d for d in hess.devices if '飞轮' in d.name), None)
            if fess:
                energy_kWh = res['device_energy'][fess.name] * 1000
                voltage = res['device_voltage'][fess.name]
                fess_plot = ax.scatter(energy_kWh, voltage, c=res['time'], cmap='cool', alpha=0.7, s=10)
                ax.set_xlabel('储存能量 (kWh)', fontsize=10)
                ax.set_ylabel('电压 (V)', fontsize=10)
                ax.set_title('飞轮储能能量-电压', fontsize=12)
                plt.colorbar(fess_plot, ax=ax, label='时间 (秒)', fraction=0.046, pad=0.04)
                ax.grid(True, alpha=0.3)
            else:
                ax.set_visible(False)

            # 8. 超导磁储能能量-电流 (如果存在)
            ax = axes[7]
            smes = next((d for d in hess.devices if '超导磁' in d.name), None)
            if smes:
                energy_kWh = res['device_energy'][smes.name] * 1000
                current = res['device_current'][smes.name]
                smes_plot = ax.scatter(energy_kWh, current, c=res['time'], cmap='magma', alpha=0.7, s=10)
                ax.set_xlabel('储存能量 (kWh)', fontsize=10)
                ax.set_ylabel('电流 (A)', fontsize=10)
                ax.set_title('超导磁储能能量-电流', fontsize=12)
                plt.colorbar(smes_plot, ax=ax, label='时间 (秒)', fraction=0.046, pad=0.04)
                ax.grid(True, alpha=0.3)
            else:
                ax.set_visible(False)

            # 9. 压缩空气储能能量-电压 (如果存在)
            ax = axes[8]
            caes = next((d for d in hess.devices if '压缩空气' in d.name), None)
            if caes:
                energy_kWh = res['device_energy'][caes.name] * 1000
                voltage = res['device_voltage'][caes.name]
                caes_plot = ax.scatter(energy_kWh, voltage, c=res['time'], cmap='winter', alpha=0.7, s=10)
                ax.set_xlabel('储存能量 (kWh)', fontsize=10)
                ax.set_ylabel('电压 (V)', fontsize=10)
                ax.set_title('压缩空气储能能量-电压', fontsize=12)
                plt.colorbar(caes_plot, ax=ax, label='时间 (秒)', fraction=0.046, pad=0.04)
                ax.grid(True, alpha=0.3)
            else:
                ax.set_visible(False)

            # 10. 储能总功率与电网交互
            ax = axes[9]
            ax.plot(res['time'], res['total_ess'], 'purple', lw=2, label='储能总功率')
            ax.plot(res['time'], res['grid_power'], 'orange', lw=1.5, label='电网购电功率')
            ax.axhline(0, color='black', ls='--', alpha=0.5)
            ax.set_xlabel('时间 (秒)', fontsize=10)
            ax.set_ylabel('功率 (MW)', fontsize=10)
            ax.set_title('储能总功率与电网购电', fontsize=12)
            ax.legend(fontsize=8, loc='upper right')
            ax.grid(True, alpha=0.3)

            # 11. 各设备SOC变化
            ax = axes[10]
            for dev in hess.devices:
                ax.plot(res['time'], res['device_soc'][dev.name], label=dev.name, linewidth=1.5)
            ax.set_xlabel('时间 (秒)', fontsize=10)
            ax.set_ylabel('SOC', fontsize=10)
            ax.set_title('各设备荷电状态', fontsize=12)
            ax.legend(fontsize=7, loc='upper right')
            ax.grid(True, alpha=0.3)

            # 12. 实时可充放电能量
            ax = axes[11]
            for dev in hess.devices:
                soc_arr = res['device_soc'][dev.name]
                chargeable = (SOC_MAX - soc_arr) * dev.capacity
                dischargeable = (soc_arr - SOC_MIN) * dev.capacity
                ax.plot(res['time'], chargeable, '--', lw=1, label=f'{dev.name}可充')
                ax.plot(res['time'], dischargeable, '-', lw=1, label=f'{dev.name}可放')
            ax.set_xlabel('时间 (秒)', fontsize=10)
            ax.set_ylabel('能量 (MWh)', fontsize=10)
            ax.set_title('实时可充放电能量', fontsize=12)
            ax.legend(fontsize=5, loc='upper right', ncol=2)
            ax.grid(True, alpha=0.3)

            # 13. 购电费用
            ax = axes[12]
            ax.plot(res['time'], res['grid_purchase'], 'r-', lw=1.5, label='购电支出')
            ax.set_xlabel('时间 (秒)', fontsize=10)
            ax.set_ylabel('金额 (元)', fontsize=10)
            ax.set_title('电网购电费用', fontsize=12)
            ax.legend(fontsize=8, loc='upper right')
            ax.grid(True, alpha=0.3)

            # 14. 储能出力堆叠面积图
            ax = axes[13]
            times = res['time']
            pos_data = []
            neg_data = []
            labels = []
            for dev in hess.devices:
                p = res['device_power'][dev.name]
                pos_data.append(np.maximum(p, 0))
                neg_data.append(np.minimum(p, 0))
                labels.append(dev.name)
            ax.stackplot(times, *pos_data, labels=labels, alpha=0.8, baseline='zero')
            ax.stackplot(times, *neg_data, alpha=0.8, baseline='zero')
            ax.set_xlabel('时间 (秒)', fontsize=10)
            ax.set_ylabel('功率 (MW)', fontsize=10)
            ax.set_title('储能出力堆叠 (正:放电,负:充电)', fontsize=12)
            ax.legend(loc='upper right', fontsize=6, ncol=2)
            ax.grid(True, alpha=0.3)

            # 15. 各设备边际成本对比
            ax = axes[14]
            names = [dev.name for dev in hess.devices]
            costs = [dev.marginal_cost for dev in hess.devices]
            ax.bar(names, costs, color='skyblue')
            ax.set_xlabel('设备', fontsize=10)
            ax.set_ylabel('边际成本 (元/MW/h)', fontsize=10)
            ax.set_title('各设备边际成本对比', fontsize=12)
            ax.tick_params(axis='x', rotation=15, labelsize=8)

            # 16. 脉冲局部放大
            ax = axes[15]
            mask_local = (res['time'] >= 8) & (res['time'] <= 12 + res['pulse_dur'])
            ax.plot(res['time'][mask_local], res['load'][mask_local], 'r-', lw=2, label='原始负荷')
            ax.plot(res['time'][mask_local], res['smoothed_load'][mask_local], 'b--', lw=2, label='平滑后负荷')
            ax.set_xlabel('时间 (秒)', fontsize=10)
            ax.set_ylabel('功率 (MW)', fontsize=10)
            ax.set_title('脉冲局部放大', fontsize=12)
            ax.legend(fontsize=8, loc='upper right')
            ax.grid(True, alpha=0.3)

            # 调整布局，隐藏多余子图
            for i in range(16):
                if not axes[i].get_visible():
                    axes[i].set_visible(False)

            plt.tight_layout(pad=3.0)
            plt.show()
        except Exception as e:
            print(f"绘图过程中出现错误: {e}")
            messagebox.showerror("绘图错误", f"无法显示图形，错误信息：{e}")

# ==================== 六、主程序 ====================

def main():
    if not PYWT_AVAILABLE:
        print("⚠️ PyWavelets 未安装，小波分解使用移动平均近似。")
    app = HESSGUI()
    app.root.mainloop()

if __name__ == '__main__':
    main()
