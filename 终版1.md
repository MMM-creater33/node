import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize
from scipy.ndimage import gaussian_filter1d
import tkinter as tk
from tkinter import ttk, messagebox
import warnings
warnings.filterwarnings('ignore')

# ---------- 小波包分解 ----------
try:
    import pywt
    PYWT_AVAILABLE = True
except ImportError:
    PYWT_AVAILABLE = False
    print("警告：未安装PyWavelets，小波分解使用移动平均近似（频带分离精度下降）")

# 中文字体
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False


# ==================== 储能设备基类（成本仅含运维/燃料）====================
class EnergyStorageDevice:
    def __init__(self, name, power_rating, capacity,
                 charge_eff, discharge_eff,
                 op_cost, response_time, gas_price=0):
        self.name = name
        self.power_rating = power_rating          # MW
        self.capacity = capacity                  # MWh
        self.charge_eff = charge_eff
        self.discharge_eff = discharge_eff
        self.op_cost = op_cost                    # 元/MWh
        self.response_time = response_time        # s
        self.gas_price = gas_price                # 元/m³（仅CAES）

        self.soc = 0.5
        self.current_power = 0.0
        self.voltage = 0.0
        self.current = 0.0
        self.energy_stored = capacity * 0.5

        # 历史记录
        self.history_soc = []
        self.history_power = []
        self.history_energy = []
        self.history_cost = []
        self.history_voltage = []
        self.history_current = []

    def update_state(self, power_set, dt):
        """功率正：放电；负：充电；返回 (SOC, 成本, 能量)"""
        # 斜坡限制
        max_change = self.power_rating * dt / self.response_time
        delta = power_set - self.current_power
        if abs(delta) > max_change:
            delta = np.sign(delta) * max_change
        power = self.current_power + delta
        power = np.clip(power, -self.power_rating, self.power_rating)
        self.current_power = power

        # 能量更新
        if power >= 0:   # 放电
            energy_out = power * dt / 3600 * self.discharge_eff
            self.energy_stored -= energy_out
        else:            # 充电
            energy_in = -power * dt / 3600 / self.charge_eff
            self.energy_stored -= energy_in   # 注意负号：充电时能量增加

        # SOC边界保护（安全防护）
        soc_min, soc_max = 0.1, 0.9
        if self.energy_stored < soc_min * self.capacity:
            self.energy_stored = soc_min * self.capacity
            self.current_power = 0.0
        if self.energy_stored > soc_max * self.capacity:
            self.energy_stored = soc_max * self.capacity
            self.current_power = 0.0

        self.soc = self.energy_stored / self.capacity
        self._calc_electrical()
        cost = self._calc_cost(power, dt)

        # 记录
        self.history_soc.append(self.soc)
        self.history_power.append(self.current_power)
        self.history_energy.append(self.energy_stored)
        self.history_cost.append(cost)
        self.history_voltage.append(self.voltage)
        self.history_current.append(self.current)

        return self.soc, cost, self.energy_stored

    def _calc_electrical(self):
        """子类重写"""
        pass

    def _calc_cost(self, power, dt):
        """运维成本 + 燃料成本（CAES重写）"""
        return abs(power) * dt / 3600 * self.op_cost

    def get_charge_available(self):
        return (0.9 - self.soc) * self.capacity          # MWh

    def get_discharge_available(self):
        return (self.soc - 0.1) * self.capacity


# -------------------- 具体储能模型 --------------------
class FESS(EnergyStorageDevice):   # 飞轮
    def __init__(self, power_rating, capacity):
        super().__init__("飞轮储能", power_rating, capacity,
                         charge_eff=0.90, discharge_eff=0.90,
                         op_cost=15, response_time=0.3)   # 0.3s斜坡
        self.voltage_nominal = 480

    def _calc_electrical(self):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
        else:
            self.current = 0
        self.voltage = self.voltage_nominal * (0.95 + 0.1 * self.soc)

class SMES(EnergyStorageDevice):  # 超导磁
    def __init__(self, power_rating, capacity):
        super().__init__("超导磁储能", power_rating, capacity,
                         charge_eff=0.97, discharge_eff=0.97,
                         op_cost=50, response_time=0.2)
        self.voltage_nominal = 600
        self.critical_current = 10000

    def _calc_electrical(self):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
            if abs(self.current) > self.critical_current:
                self.current = np.sign(self.current) * self.critical_current
                self.current_power = self.current * self.voltage_nominal / 1e6
        else:
            self.current = 0
        self.voltage = self.voltage_nominal

class SC(EnergyStorageDevice):   # 超级电容
    def __init__(self, power_rating, capacity):
        super().__init__("超级电容器", power_rating, capacity,
                         charge_eff=0.95, discharge_eff=0.95,
                         op_cost=10, response_time=0.2)
        self.voltage_nominal = 300
        self.max_voltage = 330
        self.min_voltage = 150

    def _calc_electrical(self):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
        else:
            self.current = 0
        # 电压与SOC平方根成正比（E=½CV²）
        self.voltage = self.min_voltage + (self.max_voltage - self.min_voltage) * np.sqrt(self.soc)

class BESS(EnergyStorageDevice):  # 锂电池
    def __init__(self, power_rating, capacity):
        super().__init__("锂电池储能", power_rating, capacity,
                         charge_eff=0.92, discharge_eff=0.92,
                         op_cost=25, response_time=0.5)
        self.voltage_nominal = 400
        self.internal_resistance = 0.001

    def _calc_electrical(self):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
        else:
            self.current = 0
        # 电压随SOC线性近似
        self.voltage = self.voltage_nominal * (0.8 + 0.4 * self.soc)
        vdrop = self.current * self.internal_resistance
        if self.current_power > 0:
            self.voltage -= vdrop
        elif self.current_power < 0:
            self.voltage += vdrop

class CAES(EnergyStorageDevice):  # 压缩空气
    def __init__(self, power_rating, capacity):
        super().__init__("压缩空气储能", power_rating, capacity,
                         charge_eff=0.70, discharge_eff=0.65,
                         op_cost=5, response_time=1.0, gas_price=3.6)
        self.voltage_nominal = 10000
        self.gas_consumption = []

    def _calc_electrical(self):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
        else:
            self.current = 0
        self.voltage = self.voltage_nominal

    def _calc_cost(self, power, dt):
        cost = super()._calc_cost(power, dt)
        if power > 0:   # 放电时耗气
            gas_used = power * dt / 3600 * 0.3   # 0.3 m³/MWh
            self.gas_consumption.append(gas_used)
            cost += gas_used * self.gas_price * 1000   # 元
        return cost


# ==================== 分层MPC控制器 ====================
class HierarchicalMPC:
    def __init__(self, pred_horizon=10, control_horizon=5):
        self.pred_horizon = pred_horizon
        self.control_horizon = control_horizon
        self._buffer = None   # 小波历史窗口

    def wavelet_decompose(self, signal, levels=3, wavelet='db4'):
        if not PYWT_AVAILABLE:
            low = np.convolve(signal, np.ones(10)/10, mode='same')
            residual = signal - low
            mid = np.convolve(residual, np.ones(5)/5, mode='same')
            high = residual - mid
            return {'low': low, 'mid': mid, 'high': high}
        wp = pywt.WaveletPacket(data=signal, wavelet=wavelet,
                                mode='symmetric', maxlevel=levels)
        low = getattr(wp['a'*levels], 'data', np.zeros_like(signal))
        high = getattr(wp['d'*levels], 'data', np.zeros_like(signal))
        # 长度对齐
        if len(low) != len(signal):
            low = np.interp(np.linspace(0,1,len(signal)),
                            np.linspace(0,1,len(low)), low)
        if len(high) != len(signal):
            high = np.interp(np.linspace(0,1,len(signal)),
                             np.linspace(0,1,len(high)), high)
        mid = signal - low - high
        return {'low': low, 'mid': mid, 'high': high}

    def economic_dispatch(self, devices, net_load, time_idx, dt):
        """
        上层经济调度：
        目标 = 购电成本 + 运维燃料成本 + 负荷跟踪偏差惩罚
        """
        n = len(devices)
        if n == 0:
            return np.array([])

        hour = (time_idx * dt) / 3600 % 24
        if 0 <= hour < 6 or 11 <= hour < 13:
            price = 0.21
        elif 14 <= hour < 22:
            price = 1.12
        else:
            price = 0.62

        def objective(x):
            total_power = np.sum(x)
            grid_power = net_load - total_power
            # 购电成本
            purchase = grid_power * dt / 3600 * price * 1000 if grid_power > 0 else 0.0
            # 运维+燃料
            op_fuel = sum(dev._calc_cost(x[i], dt) for i, dev in enumerate(devices))
            # 跟踪偏差惩罚（大幅提高跟踪精度）
            tracking_penalty = 1e6 * abs(net_load - total_power)
            return purchase + op_fuel + tracking_penalty

        # 功率平衡约束（尽量自平衡）
        cons = [{'type': 'eq', 'fun': lambda x: np.sum(x) - net_load}]

        bounds, x0 = [], []
        for dev in devices:
            max_charge = dev.get_charge_available() * 3600 / dt
            max_discharge = dev.get_discharge_available() * 3600 / dt
            p_min = -min(dev.power_rating, max_charge)
            p_max =  min(dev.power_rating, max_discharge)
            bounds.append((p_min, p_max))
            x0.append(0.0)

        res = minimize(objective, x0, method='SLSQP', bounds=bounds,
                       constraints=cons, options={'maxiter': 100, 'ftol': 1e-6})
        return res.x if res.success else np.zeros(n)

    def real_time_balance(self, devices, net_load, dt):
        """下层实时平衡：小波分解 + 频段分配"""
        if self._buffer is None:
            self._buffer = np.ones(16) * net_load
        else:
            self._buffer = np.roll(self._buffer, -1)
            self._buffer[-1] = net_load

        comp = self.wavelet_decompose(self._buffer, levels=2)
        high = comp['high'][-1] if len(comp['high']) else 0
        mid  = comp['mid'][-1]  if len(comp['mid'])  else 0
        low  = comp['low'][-1]  if len(comp['low'])  else 0

        alloc = {}
        # 高频 -> 超导磁 + 超级电容 + 飞轮
        if high != 0:
            smes = [d for d in devices if '超导磁' in d.name]
            sc   = [d for d in devices if '超级电容' in d.name]
            fess = [d for d in devices if '飞轮' in d.name]
            total_high = 0
            if smes: alloc['超导磁储能'] = high * 0.4; total_high += 0.4
            if sc:   alloc['超级电容器'] = high * 0.4; total_high += 0.4
            if fess: alloc['飞轮储能']   = high * 0.2; total_high += 0.2
            # 若某类缺失，重新分配
            if total_high < 1.0 and total_high > 0:
                scale = 1.0 / total_high
                for k in alloc: alloc[k] *= scale
        # 中频 -> 飞轮 + 锂电池
        if mid != 0:
            fess = [d for d in devices if '飞轮' in d.name]
            bess = [d for d in devices if '锂电池' in d.name]
            if fess and bess:
                alloc['飞轮储能'] = alloc.get('飞轮储能',0) + mid * 0.5
                alloc['锂电池储能'] = alloc.get('锂电池储能',0) + mid * 0.5
            elif fess:
                alloc['飞轮储能'] = alloc.get('飞轮储能',0) + mid
            elif bess:
                alloc['锂电池储能'] = alloc.get('锂电池储能',0) + mid
        # 低频 -> 压缩空气 + 锂电池
        if low != 0:
            caes = [d for d in devices if '压缩空气' in d.name]
            bess = [d for d in devices if '锂电池' in d.name]
            if caes:
                alloc['压缩空气储能'] = low * 0.7
                alloc['锂电池储能'] = alloc.get('锂电池储能',0) + low * 0.3
            elif bess:
                alloc['锂电池储能'] = alloc.get('锂电池储能',0) + low
        return alloc


# ==================== 混合储能系统 ====================
class HybridEnergyStorageSystem:
    def __init__(self):
        # 总功率20MW，总容量480MWh —— 按设备类型差异化分配（硬编码）
        self.device_specs = {
            '飞轮储能':       {'power': 3.0, 'capacity': 4.8},    # 15%, 1%
            '超导磁储能':     {'power': 3.0, 'capacity': 2.4},    # 15%, 0.5%
            '超级电容器':     {'power': 3.0, 'capacity': 2.4},    # 15%, 0.5%
            '锂电池储能':     {'power': 6.0, 'capacity': 230.4},  # 30%, 48%
            '压缩空气储能':   {'power': 5.0, 'capacity': 240.0},  # 25%, 50%
        }
        self.devices = []
        self.mpc = HierarchicalMPC()
        self.simulation_results = None
        self.monitor_window = None
        self.monitor_labels = {}

    def create_devices(self, selected_names):
        """根据勾选设备创建对应实例，功率/容量按预设spec"""
        self.devices = []
        for name in selected_names:
            spec = self.device_specs[name]
            p = spec['power']
            c = spec['capacity']
            if name == '飞轮储能':
                dev = FESS(p, c)
            elif name == '超导磁储能':
                dev = SMES(p, c)
            elif name == '超级电容器':
                dev = SC(p, c)
            elif name == '锂电池储能':
                dev = BESS(p, c)
            elif name == '压缩空气储能':
                dev = CAES(p, c)
            else:
                continue
            self.devices.append(dev)

    def simulate(self, pulse_amp, pulse_dur, sim_time=30, dt=0.1, econ_interval=50):
        """
        脉冲平滑仿真
        电厂：额定13MW，恒发10MW
        """
        time = np.arange(0, sim_time, dt)
        n = len(time)

        # 负荷 = 10MW + 脉冲
        load = 10.0 * np.ones_like(time)
        start = int(10.0 / dt)
        end = int((10.0 + pulse_dur) / dt)
        load[start:end] += pulse_amp

        plant = 10.0 * np.ones_like(time)          # 电厂恒发10MW
        net_load = load - plant                    # 需储能+电网平衡

        # 结果存储
        res = {
            'time': time,
            'load': load, 'plant': plant, 'net_load': net_load,
            'smoothed_load': np.zeros_like(time),
            'total_ess': np.zeros_like(time),
            'grid_power': np.zeros_like(time),
            'grid_purchase': np.zeros_like(time),
            'grid_income': np.zeros_like(time),
            'device_power': {d.name: np.zeros_like(time) for d in self.devices},
            'device_soc': {d.name: np.zeros_like(time) for d in self.devices},
            'device_energy': {d.name: np.zeros_like(time) for d in self.devices},
            'device_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_current': {d.name: np.zeros_like(time) for d in self.devices},
            'device_voltage': {d.name: np.zeros_like(time) for d in self.devices},
            'pulse_amp': pulse_amp, 'pulse_dur': pulse_dur
        }

        total_purchase = 0.0
        total_income = 0.0
        total_op_fuel = 0.0

        last_econ_powers = np.zeros(len(self.devices))
        econ_cnt = econ_interval + 1

        # 实时监控窗口更新
        self._update_monitor(init=True)

        for t in range(n):
            demand = net_load[t]

            # 上层经济调度（周期执行）
            if econ_cnt >= econ_interval:
                last_econ_powers = self.mpc.economic_dispatch(self.devices, demand, t, dt)
                econ_cnt = 0
            econ_cnt += 1

            # 下层实时平衡
            alloc = self.mpc.real_time_balance(self.devices, demand, dt)

            total_ess = 0.0
            for i, dev in enumerate(self.devices):
                base = last_econ_powers[i] if i < len(last_econ_powers) else 0
                adj = alloc.get(dev.name, 0.0)
                set_power = base + adj

                soc, cost, energy = dev.update_state(set_power, dt)
                total_op_fuel += cost

                res['device_power'][dev.name][t] = dev.current_power
                res['device_soc'][dev.name][t] = soc
                res['device_energy'][dev.name][t] = energy
                res['device_cost'][dev.name][t] = cost
                res['device_current'][dev.name][t] = dev.current
                res['device_voltage'][dev.name][t] = dev.voltage

                total_ess += dev.current_power

            res['total_ess'][t] = total_ess
            res['smoothed_load'][t] = plant[t] + total_ess
            res['grid_power'][t] = demand - total_ess

            # 电价
            hour = (t * dt) / 3600 % 24
            if 0 <= hour < 6 or 11 <= hour < 13:
                price = 0.21
            elif 14 <= hour < 22:
                price = 1.12
            else:
                price = 0.62

            if res['grid_power'][t] > 0:
                purchase = res['grid_power'][t] * dt / 3600 * price * 1000
                res['grid_purchase'][t] = purchase
                total_purchase += purchase
            if res['grid_power'][t] < 0:
                income = -res['grid_power'][t] * dt / 3600 * price * 1000
                res['grid_income'][t] = income
                total_income += income

            # 每0.5秒更新一次监控面板
            if t % 5 == 0:
                self._update_monitor()

        self.sim_res = res
        self.total_purchase = total_purchase
        self.total_income = total_income
        self.total_op_fuel = total_op_fuel
        self.total_cost = total_purchase + total_op_fuel
        self.net_cost = self.total_cost - total_income

        return res

    def _update_monitor(self, init=False):
        """更新或创建监控面板"""
        if init:
            self.monitor_window = tk.Toplevel()
            self.monitor_window.title("储能系统实时监控")
            self.monitor_window.geometry("600x500")
            self.monitor_labels = {}
            row = 0
            for dev in self.devices:
                frame = tk.LabelFrame(self.monitor_window, text=dev.name, padx=5, pady=5)
                frame.grid(row=row, column=0, padx=10, pady=5, sticky='ew')
                tk.Label(frame, text="功率 (MW):").grid(row=0, column=0, sticky='w')
                l1 = tk.Label(frame, text="0.00", width=10)
                l1.grid(row=0, column=1)
                tk.Label(frame, text="SOC:").grid(row=0, column=2, sticky='w', padx=(10,0))
                l2 = tk.Label(frame, text="0.50", width=6)
                l2.grid(row=0, column=3)
                tk.Label(frame, text="可充 (MWh):").grid(row=1, column=0, sticky='w')
                l3 = tk.Label(frame, text="0.00", width=10)
                l3.grid(row=1, column=1)
                tk.Label(frame, text="可放 (MWh):").grid(row=1, column=2, sticky='w', padx=(10,0))
                l4 = tk.Label(frame, text="0.00", width=10)
                l4.grid(row=1, column=3)
                tk.Label(frame, text="电流 (A):").grid(row=2, column=0, sticky='w')
                l5 = tk.Label(frame, text="0.0", width=10)
                l5.grid(row=2, column=1)
                tk.Label(frame, text="电压 (V):").grid(row=2, column=2, sticky='w', padx=(10,0))
                l6 = tk.Label(frame, text="0.0", width=10)
                l6.grid(row=2, column=3)
                self.monitor_labels[dev.name] = (l1, l2, l3, l4, l5, l6)
                row += 1
            self.monitor_window.update()
        else:
            # 更新数值
            for dev in self.devices:
                if dev.name in self.monitor_labels:
                    l1, l2, l3, l4, l5, l6 = self.monitor_labels[dev.name]
                    l1.config(text=f"{dev.current_power:.2f}")
                    l2.config(text=f"{dev.soc:.3f}")
                    l3.config(text=f"{dev.get_charge_available():.3f}")
                    l4.config(text=f"{dev.get_discharge_available():.3f}")
                    l5.config(text=f"{dev.current/1000:.1f}k" if abs(dev.current)>999 else f"{dev.current:.1f}")
                    l6.config(text=f"{dev.voltage:.1f}")
                    # 安全风险提示（SOC越界）
                    if dev.soc < 0.11 or dev.soc > 0.89:
                        l2.config(fg='red')
                    else:
                        l2.config(fg='black')
            self.monitor_window.update()


# ==================== GUI界面 ====================
class HESSGUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("混合储能系统脉冲平滑控制")
        self.root.geometry("500x450")

        self.pulse_amp = tk.DoubleVar(value=8.0)
        self.pulse_dur = tk.DoubleVar(value=10.0)

        self.dev_vars = {
            '飞轮储能': tk.BooleanVar(value=True),
            '超导磁储能': tk.BooleanVar(value=False),
            '超级电容器': tk.BooleanVar(value=True),
            '锂电池储能': tk.BooleanVar(value=True),
            '压缩空气储能': tk.BooleanVar(value=True),
        }
        self.setup_ui()

    def setup_ui(self):
        tk.Label(self.root, text="混合储能系统(HESS)脉冲平滑控制",
                 font=("宋体", 16, "bold")).pack(pady=10)

        pf = tk.LabelFrame(self.root, text="脉冲参数设置", padx=10, pady=10)
        pf.pack(padx=20, pady=10, fill='x')

        tk.Label(pf, text="脉冲幅值 (MW):", width=15, anchor='w').pack(side='left')
        tk.Scale(pf, from_=1, to=20, orient='horizontal',
                 variable=self.pulse_amp, length=300).pack(side='left', padx=10)
        tk.Label(pf, textvariable=self.pulse_amp, width=5).pack(side='left')

        tk.Label(pf, text="脉冲持续时间 (s):", width=15, anchor='w').pack(side='left')
        tk.Scale(pf, from_=1, to=20, orient='horizontal',
                 variable=self.pulse_dur, length=300).pack(side='left', padx=10)
        tk.Label(pf, textvariable=self.pulse_dur, width=5).pack(side='left')

        df = tk.LabelFrame(self.root, text="选择储能设备", padx=10, pady=10)
        df.pack(padx=20, pady=10, fill='x')
        for name, var in self.dev_vars.items():
            tk.Checkbutton(df, text=name, variable=var,
                           font=("宋体", 11)).pack(anchor='w', pady=2)

        btnf = tk.Frame(self.root)
        btnf.pack(pady=20)
        tk.Button(btnf, text="开始仿真", command=self.run_sim,
                  bg="green", fg="white", font=("宋体", 12), width=15).pack(side='left', padx=10)
        tk.Button(btnf, text="退出", command=self.root.quit,
                  bg="red", fg="white", font=("宋体", 12), width=15).pack(side='left', padx=10)

        self.status = tk.Label(self.root, text="等待开始仿真...", font=("宋体", 10), fg="blue")
        self.status.pack(pady=10)

    def run_sim(self):
        selected = [name for name, var in self.dev_vars.items() if var.get()]
        if not selected:
            messagebox.showerror("错误", "请至少选择一个储能设备！")
            return

        self.status.config(text="正在运行仿真...")
        self.root.update()

        try:
            amp = self.pulse_amp.get()
            dur = self.pulse_dur.get()

            hess = HybridEnergyStorageSystem()
            hess.create_devices(selected)
            results = hess.simulate(amp, dur)

            self.show_results(hess, results, amp, dur, selected)
            self.status.config(text="仿真完成！")
        except Exception as e:
            messagebox.showerror("错误", f"仿真过程中出现错误：\n{str(e)}")
            self.status.config(text="仿真失败！")

    def show_results(self, hess, res, amp, dur, selected):
        # ---- 成本与出力统计 ----
        total_purchase = hess.total_purchase
        total_income = hess.total_income
        total_op_fuel = hess.total_op_fuel
        total_cost = hess.total_cost
        net_cost = hess.net_cost

        dev_cost = {}
        dev_charge = {}
        dev_discharge = {}
        dev_avg_p = {}
        dev_max_p = {}
        for dev in hess.devices:
            p = res['device_power'][dev.name]
            c = res['device_cost'][dev.name]
            dev_cost[dev.name] = np.sum(c)
            dev_charge[dev.name] = -np.sum(p[p<0]) * 0.1 / 3600
            dev_discharge[dev.name] = np.sum(p[p>0]) * 0.1 / 3600
            dev_avg_p[dev.name] = np.mean(np.abs(p))
            dev_max_p[dev.name] = np.max(np.abs(p))

        # ---- 文本结果窗口 ----
        win = tk.Toplevel(self.root)
        win.title("仿真结果")
        win.geometry("850x650")
        text = tk.Text(win, wrap='word', font=('宋体', 10))
        scroll = tk.Scrollbar(win, command=text.yview)
        text.config(yscrollcommand=scroll.set)
        text.pack(side='left', fill='both', expand=True)
        scroll.pack(side='right', fill='y')

        text.insert('end', "="*80 + "\n")
        text.insert('end', "混合储能系统脉冲平滑仿真结果\n")
        text.insert('end', "="*80 + "\n\n")
        text.insert('end', f"脉冲幅值: {amp:.1f} MW\n")
        text.insert('end', f"脉冲持续时间: {dur:.1f} 秒\n\n")
        text.insert('end', "【储能设备配置】\n")
        for name in selected:
            spec = hess.device_specs[name]
            text.insert('end', f"  {name}: 功率 {spec['power']:.1f} MW, 容量 {spec['capacity']:.1f} MWh\n")

        text.insert('end', f"\n【平滑性能】\n")
        rmse = np.sqrt(np.mean((res['load'] - res['smoothed_load'])**2))
        overlap = 1 - np.sum(np.abs(res['load'] - res['smoothed_load'])) / np.sum(np.abs(res['load']))
        text.insert('end', f"  平滑后负荷RMSE: {rmse:.3f} MW\n")
        text.insert('end', f"  负荷重合度: {overlap*100:.2f}%\n\n")

        text.insert('end', "【经济性指标（元）】\n")
        text.insert('end', f"  购电支出: {total_purchase:.2f}\n")
        text.insert('end', f"  储能运维+燃料成本: {total_op_fuel:.2f}\n")
        text.insert('end', f"  → 总成本(支出): {total_cost:.2f}\n")
        text.insert('end', f"  售电收入: {total_income:.2f}\n")
        text.insert('end', f"  → 净成本(总成本-收入): {net_cost:.2f}\n\n")

        text.insert('end', "【各设备运维/燃料成本】\n")
        for name, cost in dev_cost.items():
            text.insert('end', f"  {name}: {cost:.2f} 元\n")

        text.insert('end', "\n【各设备充放电统计】\n")
        text.insert('end', f"{'设备名称':<16} {'充电量(MWh)':<12} {'放电量(MWh)':<12} "
                           f"{'平均功率(MW)':<12} {'最大功率(MW)':<12}\n")
        text.insert('end', "-"*70 + "\n")
        for dev in hess.devices:
            name = dev.name
            text.insert('end', f"{name:<16} {dev_charge[name]:<12.4f} {dev_discharge[name]:<12.4f} "
                               f"{dev_avg_p[name]:<12.4f} {dev_max_p[name]:<12.4f}\n")

        text.insert('end', "\n【脉冲期间功率分配策略】\n")
        mask = (res['time'] >= 10) & (res['time'] < 10+dur)
        if np.any(mask):
            total_pulse = 0
            pulse_avg = {}
            for dev in hess.devices:
                avg = np.mean(np.abs(res['device_power'][dev.name][mask]))
                pulse_avg[dev.name] = avg
                total_pulse += avg
            for name, avg in pulse_avg.items():
                if total_pulse > 0:
                    text.insert('end', f"  {name}: {avg/total_pulse*100:.1f}%\n")

        text.insert('end', "\n【边界约束】\n")
        text.insert('end', "  • 电厂额定功率: 13 MW，实际恒发 10 MW\n")
        text.insert('end', "  • 储能系统总功率上限: 20 MW\n")
        text.insert('end', "  • 储能系统总容量: 480 MWh\n")
        text.insert('end', "  • 各设备SOC运行区间: [0.1, 0.9]\n")
        text.insert('end', "  • 脉冲幅值上限: 20 MW，持续时间上限: 20 s\n")
        text.insert('end', "  • 购电/售电电价: 低谷0.21、平段0.62、高峰1.12 元/kWh\n")
        text.config(state='disabled')

        # ---- 绘图按钮 ----
        tk.Button(win, text="显示详细图表", command=lambda: self.plot_all(hess, res),
                  bg="blue", fg="white", font=("宋体", 12)).pack(pady=10)

    def plot_all(self, hess, res):
        """绘制所有要求的图表（11个子图）"""
        plt.figure(figsize=(20, 16))

        # 1. 脉冲平滑效果对比
        plt.subplot(4, 3, 1)
        plt.plot(res['time'], res['load'], 'r-', lw=2, label='原始负荷')
        plt.plot(res['time'], res['smoothed_load'], 'b--', lw=2, label='平滑后负荷')
        plt.plot(res['time'], res['plant'], 'g-', lw=1.5, label='电厂出力')
        plt.fill_between(res['time'], res['load'], res['smoothed_load'],
                         alpha=0.3, color='gray', label='平滑区域')
        plt.xlabel('时间 (秒)')
        plt.ylabel('功率 (MW)')
        plt.title('脉冲平滑效果对比')
        plt.legend()
        plt.grid(True, alpha=0.3)

        # 2. 各储能设备功率
        plt.subplot(4, 3, 2)
        for dev in hess.devices:
            p = gaussian_filter1d(res['device_power'][dev.name], sigma=2)
            plt.plot(res['time'], p, label=dev.name)
        plt.xlabel('时间 (秒)')
        plt.ylabel('功率 (MW)')
        plt.title('各储能设备功率')
        plt.legend()
        plt.grid(True, alpha=0.3)

        # 3. 储能总功率 & 电网交互功率
        plt.subplot(4, 3, 3)
        plt.plot(res['time'], res['total_ess'], 'purple', lw=2, label='储能总功率')
        plt.plot(res['time'], res['grid_power'], 'orange', lw=1.5, label='电网交互功率')
        plt.axhline(0, color='black', ls='--', alpha=0.5)
        plt.xlabel('时间 (秒)')
        plt.ylabel('功率 (MW)')
        plt.title('储能与电网功率')
        plt.legend()
        plt.grid(True, alpha=0.3)

        # 4. 各设备SOC
        plt.subplot(4, 3, 4)
        for dev in hess.devices:
            plt.plot(res['time'], res['device_soc'][dev.name], label=dev.name)
        plt.xlabel('时间 (秒)')
        plt.ylabel('SOC')
        plt.title('各设备荷电状态')
        plt.legend()
        plt.grid(True, alpha=0.3)

        # 5. 脉冲期间功率分配饼图（策略）
        plt.subplot(4, 3, 5)
        mask = (res['time'] >= 10) & (res['time'] < 10+res['pulse_dur'])
        pulse_power = {}
        for dev in hess.devices:
            avg = np.mean(np.abs(res['device_power'][dev.name][mask]))
            if avg > 0.01:
                pulse_power[dev.name] = avg
        if pulse_power:
            labels = list(pulse_power.keys())
            sizes = list(pulse_power.values())
            plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90)
            plt.title('脉冲期间功率分配策略')

        # 6. 储能出力堆叠面积图
        plt.subplot(4, 3, 6)
        times = res['time']
        stack_data = []
        labels = []
        for dev in hess.devices:
            stack_data.append(res['device_power'][dev.name])
            labels.append(dev.name)
        stack_data = np.array(stack_data)
        pos = np.maximum(stack_data, 0)
        neg = np.minimum(stack_data, 0)
        plt.stackplot(times, *pos, labels=labels, alpha=0.8, baseline='zero')
        plt.stackplot(times, *neg, alpha=0.8, baseline='zero')
        plt.xlabel('时间 (秒)')
        plt.ylabel('功率 (MW)')
        plt.title('各储能设备出力堆叠（正:放电,负:充电）')
        plt.legend(loc='upper right', fontsize=8)
        plt.grid(True, alpha=0.3)

        # 7. 电流随时间变化（以锂电池为例）
        plt.subplot(4, 3, 7)
        bess = next((d for d in hess.devices if '锂电池' in d.name), None)
        if bess:
            current = res['device_current'][bess.name] / 1000  # kA
            current_smooth = gaussian_filter1d(current, sigma=3)
            plt.plot(res['time'], current_smooth, 'b-', lw=2)
            plt.xlabel('时间 (秒)')
            plt.ylabel('电流 (kA)')
            plt.title('锂电池储能电流变化')
            plt.grid(True, alpha=0.3)

        # 8. 电压随时间变化（以锂电池为例）
        plt.subplot(4, 3, 8)
        if bess:
            voltage = res['device_voltage'][bess.name]
            voltage_smooth = gaussian_filter1d(voltage, sigma=3)
            plt.plot(res['time'], voltage_smooth, 'r-', lw=2)
            plt.xlabel('时间 (秒)')
            plt.ylabel('电压 (V)')
            plt.title('锂电池储能电压变化')
            plt.grid(True, alpha=0.3)

        # 9. 能量-电压关系（超级电容）
        plt.subplot(4, 3, 9)
        sc = next((d for d in hess.devices if '超级电容' in d.name), None)
        if sc:
            energy = res['device_energy'][sc.name] * 1000  # kWh
            voltage = res['device_voltage'][sc.name]
            plt.scatter(energy, voltage, c=res['time'], cmap='viridis', alpha=0.6, s=10)
            plt.xlabel('储存能量 (kWh)')
            plt.ylabel('电压 (V)')
            plt.title('超级电容器能量-电压关系')
            plt.colorbar(label='时间 (秒)')
            plt.grid(True, alpha=0.3)

        # 10. 能量-电流关系（锂电池）
        plt.subplot(4, 3, 10)
        if bess:
            energy = res['device_energy'][bess.name] * 1000  # kWh
            current = res['device_current'][bess.name] / 1000  # kA
            plt.scatter(energy, current, c=res['time'], cmap='plasma', alpha=0.6, s=10)
            plt.xlabel('储存能量 (kWh)')
            plt.ylabel('电流 (kA)')
            plt.title('锂电池储能能量-电流关系')
            plt.colorbar(label='时间 (秒)')
            plt.grid(True, alpha=0.3)

        # 11. 实时可充放电能量
        plt.subplot(4, 3, 11)
        for dev in hess.devices:
            soc_arr = res['device_soc'][dev.name]
            chargeable = (0.9 - soc_arr) * dev.capacity
            dischargeable = (soc_arr - 0.1) * dev.capacity
            plt.plot(res['time'], chargeable, '--', lw=1, label=f'{dev.name}可充电')
            plt.plot(res['time'], dischargeable, '-', lw=1, label=f'{dev.name}可放电')
        plt.xlabel('时间 (秒)')
        plt.ylabel('能量 (MWh)')
        plt.title('实时可充放电能量')
        plt.legend(fontsize=6, loc='upper right')
        plt.grid(True, alpha=0.3)

        # 12. 购电/售电费用
        plt.subplot(4, 3, 12)
        plt.plot(res['time'], res['grid_purchase'], 'r-', lw=1.5, label='购电支出')
        plt.plot(res['time'], res['grid_income'], 'g-', lw=1.5, label='售电收入')
        plt.xlabel('时间 (秒)')
        plt.ylabel('金额 (元)')
        plt.title('电网交互费用')
        plt.legend()
        plt.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()


# ==================== 主程序 ====================
def main():
    if not PYWT_AVAILABLE:
        print("⚠️  PyWavelets 未安装，小波分解使用移动平均近似（频带分离精度下降）")
    app = HESSGUI()
    app.root.mainloop()


if __name__ == '__main__':
    main()
