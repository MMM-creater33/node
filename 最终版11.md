# -*- coding: utf-8 -*-
"""
================================================================================
æ··åˆå‚¨èƒ½ç³»ç»Ÿåˆ†å±‚EMSæ§åˆ¶ç¨‹åºï¼ˆè„‰å†²å®Œå…¨å¹³æ»‘ + ç»æµåˆ†é… + å®æ—¶å¹³è¡¡ï¼‰
================================================================================
ã€ç³»ç»Ÿæ¦‚å†µã€‘
ç”µå‚é¢å®šåŠŸç‡: 13 MW (å®é™…æ’å‘ 10 MWï¼Œå¯é…ç½®)
æ··åˆå‚¨èƒ½ç³»ç»Ÿ: æ€»åŠŸç‡ 20 MW / æ€»å®¹é‡ 480 MWh
åŒ…å«è®¾å¤‡:
é£è½®å‚¨èƒ½(FESS)ã€è¶…å¯¼ç£å‚¨èƒ½(SMES)ã€è¶…çº§ç”µå®¹å™¨(SC)ã€é”‚ç”µæ± (BESS)ã€å‹ç¼©ç©ºæ°”å‚¨èƒ½(CAES)
è„‰å†²å‚æ•°: å¹…å€¼ 1~20 MW, æŒç»­æ—¶é—´ 1~20 s

ã€åˆ†å±‚EMSæ¶æ„ã€‘
1. ä¸Šå±‚ç»æµè°ƒåº¦å±‚ (MPC)
   - åŸºäºåˆ†æ—¶ç”µä»·(å—äº¬å†¬å­£å·¥å•†ä¸š) + å¤©ç„¶æ°”ä»·æ ¼
   - ç›®æ ‡å‡½æ•°: è´­ç”µæˆæœ¬ + è¿ç»´æˆæœ¬ + éçº¿æ€§è€åŒ–æˆæœ¬ + ç‡ƒæ–™æˆæœ¬ + è´Ÿè·è·Ÿè¸ªæƒ©ç½š
   - å¯é€‰ç¢³æƒ©ç½šæˆæœ¬ï¼ˆç¯ä¿æ¨¡å¼ï¼‰
   - é‡‡ç”¨éšæœºè§„åˆ’(åœºæ™¯æ³•)å¤„ç†å‡€è´Ÿè·é¢„æµ‹è¯¯å·®ï¼Œæé«˜é²æ£’æ€§
2. ä¸‹å±‚å®æ—¶å¹³è¡¡å±‚
   - å°æ³¢åŒ…åˆ†è§£(æˆ–ç§»åŠ¨å¹³å‡è¿‘ä¼¼)å°†ä¸å¹³è¡¡åŠŸç‡åˆ†è§£ä¸ºé«˜/ä¸­/ä½é¢‘åˆ†é‡
   - æŒ‰é¢‘æ®µåˆ†é…: é«˜é¢‘(è¶…çº§ç”µå®¹/é£è½®/è¶…å¯¼ç£), ä¸­é¢‘(é£è½®/é”‚ç”µæ± ), ä½é¢‘(å‹ç¼©ç©ºæ°”/é”‚ç”µæ± )
   - äºŒæ¬¡åŠŸç‡è°ƒæ•´: ç¡®ä¿å‚¨èƒ½æ€»å‡ºåŠ›ä¸å‡€è´Ÿè·åå·®<0.05MWï¼Œå®ç°é«˜åº¦é‡åˆ

ã€è¾“å‡ºè¦æ±‚å…¨é¢è¦†ç›–ã€‘
âœ“ è„‰å†²å¹³æ»‘æ•ˆæœå›¾ (åŸå§‹è´Ÿè· vs å¹³æ»‘åè´Ÿè·)
âœ“ è„‰å†²åŠŸç‡åˆ†é…ç­–ç•¥/å æ¯”å›¾ (é¥¼å›¾)
âœ“ å„è®¾å¤‡ç”µæµ/ç”µå‹éšæ—¶é—´å˜åŒ–å›¾ (ç¼“æ…¢æ¸å˜ï¼Œæ— è·³å˜)
âœ“ å„è®¾å¤‡èƒ½é‡-ç”µæµ/èƒ½é‡-ç”µå‹å…³ç³»æ•£ç‚¹å›¾
âœ“ å®æ—¶ç›‘æ§é¢æ¿ (åŠŸç‡/SOC/å¯å……æ”¾ç”µé‡/ç”µæµ/ç”µå‹/è¾¹ç•Œé¢„è­¦ + åŠŸç‡è¶‹åŠ¿å›¾)
âœ“ è¯¦ç»†æˆæœ¬æ„æˆ (è´­ç”µ/è¿ç»´/è€åŒ–/ç‡ƒæ–™/ç¢³æƒ©ç½š)
âœ“ è„‰å†²æœŸé—´å„è®¾å¤‡æ‰¿æ‹…æ¯”ä¾‹
âœ“ æ‰€æœ‰è¾¹ç•Œæ¡ä»¶åˆ—è¡¨ (SOCé™å€¼/åŠŸç‡é™å€¼/ç”µä»·/æ°”ä»·/è€åŒ–ç³»æ•°ç­‰)
âœ“ ç¢³å‡æ’ä¼°ç®—
âœ“ éšæœºè§„åˆ’åœºæ™¯å¯è§†åŒ–

ã€åˆ›æ–°äº®ç‚¹ã€‘
- å¯é…ç½®å¾®ç”µç½‘è§„æ¨¡ï¼ˆç”µå‚å‡ºåŠ›ï¼‰ï¼Œé€‚åº”ä¸åŒåœºæ™¯
- ç¯ä¿æ¨¡å¼ï¼šç»æµè°ƒåº¦ä¸­åŠ å…¥ç¢³æƒ©ç½šï¼Œå¼•å¯¼ç»¿è‰²è¿è¡Œ
- å®æ—¶åŠŸç‡è¶‹åŠ¿å›¾åŠ¨æ€å±•ç¤ºè®¾å¤‡å“åº”
- ç¢³å‡æ’ä¼°ç®—ä¸ç¯å¢ƒæ•ˆç›Šå±•ç¤º

ä½œè€…ï¼šæ·±åº¦é‡æ„æ»¡è¶³å…¨éƒ¨è¦æ±‚
æ—¥æœŸï¼š2026å¹´2æœˆ
================================================================================
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize
from scipy.ndimage import gaussian_filter1d
import tkinter as tk
from tkinter import ttk, messagebox
import warnings
warnings.filterwarnings('ignore')

# è®¾ç½® matplotlib åç«¯ä¸º TkAgg ä»¥ä¿è¯ä¸ tkinter å…¼å®¹
import matplotlib
matplotlib.use('TkAgg')

# è®¾ç½®ä¸­æ–‡å­—ä½“
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

# ----------------------------------------------------------------------
# å°æ³¢åŒ…åˆ†è§£ï¼ˆä¼˜å…ˆä½¿ç”¨pywtï¼‰
try:
    import pywt
    PYWT_AVAILABLE = True
except ImportError:
    PYWT_AVAILABLE = False
    print("âš ï¸ PyWavelets æœªå®‰è£…ï¼Œä½¿ç”¨ç§»åŠ¨å¹³å‡è¿‘ä¼¼å°æ³¢åˆ†è§£ï¼ˆé¢‘å¸¦åˆ†ç¦»ç²¾åº¦ç¨é™ï¼‰")

# ç¢³æ’æ”¾å› å­ (kg COâ‚‚/kWh)
CARBON_FACTOR = 0.5
# ç¢³ä»·æ ¼ (å…ƒ/kg COâ‚‚) - ç”¨äºç¯ä¿æ¨¡å¼
CARBON_PRICE = 0.05

# ==================== ä¸€ã€å‚¨èƒ½è®¾å¤‡åŸºç±»ï¼ˆå«ç»æµæƒé‡ã€ç”µæµç”µå‹è¶…å¹³æ»‘ï¼‰====================
class EnergyStorageDevice:
    """æ‰€æœ‰å‚¨èƒ½è®¾å¤‡çš„æŠ½è±¡åŸºç±»ï¼ŒåŒ…å«éçº¿æ€§è€åŒ–æˆæœ¬æ¨¡å‹åŠè¶…å¹³æ»‘ç”µæ°”å‚æ•°æ»¤æ³¢"""
    def __init__(self, name, power_rating, capacity,
                 charge_eff, discharge_eff,
                 op_cost, response_time,
                 aging_coeff,       # éçº¿æ€§è€åŒ–ç³»æ•° (å…ƒ/MW^1.8/h)
                 gas_price=0):
        self.name = name
        self.power_rating = power_rating          # MW
        self.capacity = capacity                  # MWh
        self.charge_eff = charge_eff
        self.discharge_eff = discharge_eff
        self.op_cost = op_cost                     # è¿ç»´æˆæœ¬ å…ƒ/MWh
        self.response_time = response_time         # ç§’
        self.aging_coeff = aging_coeff             # è€åŒ–æˆæœ¬ç³»æ•°
        self.gas_price = gas_price                  # å¤©ç„¶æ°”ä»·æ ¼ å…ƒ/mÂ³ (ä»…CAES)

        # åˆå§‹çŠ¶æ€ï¼ˆæé«˜è‡³0.8ï¼Œç¡®ä¿è„‰å†²æœŸé—´æ”¾ç”µèƒ½åŠ›å……è¶³ï¼‰
        self.soc = 0.8
        self.current_power = 0.0
        self.voltage = 0.0
        self.current = 0.0
        self.energy_stored = capacity * self.soc

        # ç”¨äºè¶…ä½é€šæ»¤æ³¢çš„ä¸Šä¸€æ—¶åˆ»å€¼
        self.last_current = 0.0
        self.last_voltage = 0.0

        # å†å²è®°å½•
        self.history_soc = []
        self.history_power = []
        self.history_energy = []
        self.history_cost = []                     # è¿ç»´+ç‡ƒæ–™+è€åŒ–
        self.history_op_cost = []                   # çº¯è¿ç»´
        self.history_aging_cost = []                 # è€åŒ–æˆæœ¬
        self.history_fuel_cost = []                  # ç‡ƒæ–™æˆæœ¬ï¼ˆCAESï¼‰
        self.history_voltage = []
        self.history_current = []

    def update_state(self, power_set, dt):
        """æ›´æ–°è®¾å¤‡çŠ¶æ€ï¼ŒåŒ…å«æ–œå¡é™åˆ¶ã€SOCè¾¹ç•Œä¿æŠ¤ã€æˆæœ¬è®¡ç®—"""
        # æ–œå¡é™åˆ¶ï¼ˆåŠŸç‡å˜åŒ–ç‡é™åˆ¶ï¼‰
        max_change = self.power_rating * dt / self.response_time
        delta = power_set - self.current_power
        if abs(delta) > max_change:
            delta = np.sign(delta) * max_change
        power = self.current_power + delta
        power = np.clip(power, -self.power_rating, self.power_rating)
        self.current_power = power

        # èƒ½é‡æ›´æ–°
        if power >= 0:   # æ”¾ç”µ
            energy_out = power * dt / 3600 * self.discharge_eff
            self.energy_stored -= energy_out
        else:            # å……ç”µ
            energy_in = -power * dt / 3600 / self.charge_eff
            self.energy_stored -= energy_in   # å‡å»è´Ÿå€¼ = åŠ æ­£å€¼

        # SOCè¾¹ç•Œä¿æŠ¤ï¼ˆå®‰å…¨é˜²æŠ¤ï¼‰
        soc_min, soc_max = 0.1, 0.9
        if self.energy_stored < soc_min * self.capacity:
            self.energy_stored = soc_min * self.capacity
            self.current_power = 0.0
        if self.energy_stored > soc_max * self.capacity:
            self.energy_stored = soc_max * self.capacity
            self.current_power = 0.0
        self.soc = self.energy_stored / self.capacity

        # è®¡ç®—ç”µæ°”å‚æ•°ï¼ˆåŒ…å«æå¼ºä½é€šæ»¤æ³¢ï¼Œä½¿ç”µæµã€ç”µå‹æ¸å˜ï¼‰
        self._calc_electrical(dt)

        # æˆæœ¬è®¡ç®—ï¼ˆè¿ç»´ + è€åŒ– + ç‡ƒæ–™ï¼‰
        op_cost_val = self._calc_op_cost(power, dt)
        aging_cost_val = self._calc_aging_cost(power, dt, self.soc)
        fuel_cost_val = self._calc_fuel_cost(power, dt) if hasattr(self, '_calc_fuel_cost') else 0.0
        total_cost = op_cost_val + aging_cost_val + fuel_cost_val

        # è®°å½•å†å²
        self.history_soc.append(self.soc)
        self.history_power.append(self.current_power)
        self.history_energy.append(self.energy_stored)
        self.history_cost.append(total_cost)
        self.history_op_cost.append(op_cost_val)
        self.history_aging_cost.append(aging_cost_val)
        self.history_fuel_cost.append(fuel_cost_val)
        self.history_voltage.append(self.voltage)
        self.history_current.append(self.current)

        return self.soc, total_cost, self.energy_stored

    def _calc_electrical(self, dt, filter_alpha=0.02):
        """ç”µæ°”å‚æ•°è®¡ç®—ï¼ˆç”±å­ç±»é‡å†™ï¼Œå¹¶åŠ å…¥ä¸€é˜¶ä½é€šæ»¤æ³¢ï¼‰"""
        pass

    def _apply_lowpass_filter(self, dt, alpha):
        """å¯¹ç”µæµå’Œç”µå‹æ–½åŠ è¶…å¼ºä½é€šæ»¤æ³¢ï¼Œæ¶ˆé™¤ç¬æ—¶è·³å˜"""
        # ä¸€é˜¶ä½é€šæ»¤æ³¢: y_new = alpha * x + (1-alpha) * y_old
        if not hasattr(self, 'last_current'):
            self.last_current = self.current
            self.last_voltage = self.voltage
        else:
            # ç”µæµæ»¤æ³¢
            raw_current = self.current
            self.current = alpha * raw_current + (1 - alpha) * self.last_current
            self.last_current = self.current
            # ç”µå‹æ»¤æ³¢
            raw_voltage = self.voltage
            self.voltage = alpha * raw_voltage + (1 - alpha) * self.last_voltage
            self.last_voltage = self.voltage

    def _calc_op_cost(self, power, dt):
        """è¿ç»´æˆæœ¬ï¼ˆçº¿æ€§ï¼‰"""
        return abs(power) * dt / 3600 * self.op_cost

    def _calc_aging_cost(self, power, dt, soc):
        """
        éçº¿æ€§è€åŒ–æˆæœ¬æ¨¡å‹ï¼š
        - ä¸åŠŸç‡çš„ 1.8 æ¬¡æ–¹æˆæ­£æ¯”ï¼ˆå¼ºåŒ–ç”µæµçƒ­æ•ˆåº”å½±å“ï¼‰
        - ä¸æ”¾ç”µæ·±åº¦å˜åŒ–ç›¸å…³ï¼ˆç®€åŒ–ç”¨ (1-soc) æƒ©ç½šï¼‰
        - ç³»æ•° aging_coeff å•ä½ï¼šå…ƒ/MW^1.8/h
        """
        if abs(power) < 1e-6:
            return 0.0
        non_linear = abs(power) ** 1.8
        dod_factor = 1.0 + 0.5 * (1 - soc) if power > 0 else 0.5
        return self.aging_coeff * non_linear * dt / 3600 * dod_factor

    def _calc_fuel_cost(self, power, dt):
        """ç‡ƒæ–™æˆæœ¬ï¼ˆä»…CAESé‡å†™ï¼‰"""
        return 0.0

    def get_charge_available(self):
        """å¯å……ç”µé‡ (MWh)"""
        return (0.9 - self.soc) * self.capacity

    def get_discharge_available(self):
        """å¯æ”¾ç”µé‡ (MWh)"""
        return (self.soc - 0.1) * self.capacity

    @property
    def marginal_cost(self):
        """
        è¾¹é™…æˆæœ¬ç³»æ•°ï¼ˆå…ƒ/MW/hï¼‰------ ç”¨äºåŠŸç‡åˆ†é…æƒé‡è®¡ç®—
        å–è¿ç»´æˆæœ¬ + çº¿æ€§åŒ–åçš„è€åŒ–æˆæœ¬ï¼ˆå¼ºåŒ–åŠŸç‡å½±å“ï¼Œé‡‡ç”¨ P^0.8ï¼‰
        """
        avg_aging_per_mw = self.aging_coeff * (self.power_rating ** 0.8)   # å…ƒ/MW/h
        return self.op_cost + avg_aging_per_mw

# ==================== äºŒã€äº”ç±»å‚¨èƒ½è®¾å¤‡å…·ä½“æ¨¡å‹ï¼ˆé‡æ–°è°ƒæ•´å æ¯”ï¼‰====================
# æ€»åŠŸç‡20MW / æ€»å®¹é‡480MWh
# -----------------------------------------------------------------------------
# è®¾å¤‡åç§°       åŠŸç‡(MW)  å®¹é‡(MWh)  å“åº”æ—¶é—´(s)  è€åŒ–ç³»æ•°(å…ƒ/MW^1.8/h)  è¯´æ˜
# -----------------------------------------------------------------------------
# è¶…çº§ç”µå®¹å™¨        8          8          0.2           0.6             é«˜é¢‘ä¸»åŠ›
# é£è½®å‚¨èƒ½          6          6          0.3           1.2             é«˜é¢‘/ä¸­é¢‘
# è¶…å¯¼ç£å‚¨èƒ½        4          4          0.2           0.8             æç«¯é«˜é¢‘å¤‡ç”¨
# é”‚ç”µæ± å‚¨èƒ½        1.5      300          0.5           3.5             ä¸­/ä½é¢‘ï¼Œå¤§å®¹é‡
# å‹ç¼©ç©ºæ°”å‚¨èƒ½      0.5      162          1.0           0.5             ä½é¢‘
# -----------------------------------------------------------------------------
# æ€»åŠŸç‡ï¼š8+6+4+1.5+0.5 = 20 MWï¼Œæ€»å®¹é‡ï¼š8+6+4+300+162 = 480 MWh

class FESS(EnergyStorageDevice):   # é£è½®å‚¨èƒ½
    def __init__(self):
        super().__init__("é£è½®å‚¨èƒ½", power_rating=6.0, capacity=6.0,
                         charge_eff=0.90, discharge_eff=0.90,
                         op_cost=15, response_time=0.3, aging_coeff=1.2)
        self.voltage_nominal = 480

    def _calc_electrical(self, dt):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
        else:
            self.current = 0
        # ç”µå‹ä¸SOCæˆæ­£æ¯”ï¼ˆçº¿æ€§ï¼‰
        self.voltage = self.voltage_nominal * (0.95 + 0.1 * self.soc)
        self._apply_lowpass_filter(dt, alpha=0.02)

class SMES(EnergyStorageDevice):   # è¶…å¯¼ç£å‚¨èƒ½
    def __init__(self):
        super().__init__("è¶…å¯¼ç£å‚¨èƒ½", power_rating=4.0, capacity=4.0,
                         charge_eff=0.97, discharge_eff=0.97,
                         op_cost=50, response_time=0.2, aging_coeff=0.8)
        self.voltage_nominal = 600
        self.critical_current = 10000

    def _calc_electrical(self, dt):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
            if abs(self.current) > self.critical_current:
                self.current = np.sign(self.current) * self.critical_current
                self.current_power = self.current * self.voltage_nominal / 1e6
        else:
            self.current = 0
        self.voltage = self.voltage_nominal
        self._apply_lowpass_filter(dt, alpha=0.02)

class SC(EnergyStorageDevice):   # è¶…çº§ç”µå®¹å™¨
    def __init__(self):
        super().__init__("è¶…çº§ç”µå®¹å™¨", power_rating=8.0, capacity=8.0,
                         charge_eff=0.95, discharge_eff=0.95,
                         op_cost=10, response_time=0.2, aging_coeff=0.6)
        self.voltage_nominal = 300
        self.max_voltage = 330
        self.min_voltage = 150

    def _calc_electrical(self, dt):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
        else:
            self.current = 0
        # ç”µå‹ä¸SOCå¹³æ–¹æ ¹æˆæ­£æ¯”
        self.voltage = self.min_voltage + (self.max_voltage - self.min_voltage) * np.sqrt(self.soc)
        self._apply_lowpass_filter(dt, alpha=0.02)

class BESS(EnergyStorageDevice):   # é”‚ç”µæ± å‚¨èƒ½
    def __init__(self):
        super().__init__("é”‚ç”µæ± å‚¨èƒ½", power_rating=1.5, capacity=300.0,
                         charge_eff=0.92, discharge_eff=0.92,
                         op_cost=25, response_time=0.5, aging_coeff=3.5)
        self.voltage_nominal = 400
        self.internal_resistance = 0.001

    def _calc_electrical(self, dt):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
        else:
            self.current = 0
        # ç”µå‹éšSOCçº¿æ€§å˜åŒ–
        self.voltage = self.voltage_nominal * (0.8 + 0.4 * self.soc)
        vdrop = self.current * self.internal_resistance
        if self.current_power > 0:
            self.voltage -= vdrop
        elif self.current_power < 0:
            self.voltage += vdrop
        self._apply_lowpass_filter(dt, alpha=0.02)

class CAES(EnergyStorageDevice):   # å‹ç¼©ç©ºæ°”å‚¨èƒ½
    def __init__(self):
        super().__init__("å‹ç¼©ç©ºæ°”å‚¨èƒ½", power_rating=0.5, capacity=162.0,
                         charge_eff=0.70, discharge_eff=0.65,
                         op_cost=5, response_time=1.0, aging_coeff=0.5, gas_price=3.6)
        self.voltage_nominal = 10000
        self.gas_consumption = []

    def _calc_electrical(self, dt):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
        else:
            self.current = 0
        self.voltage = self.voltage_nominal
        self._apply_lowpass_filter(dt, alpha=0.02)

    def _calc_fuel_cost(self, power, dt):
        """ç‡ƒæ°”æˆæœ¬ï¼ˆæ”¾ç”µæ—¶æ¶ˆè€—å¤©ç„¶æ°”ï¼‰"""
        if power > 0:
            gas_used = power * dt / 3600 * 0.3   # 0.3 mÂ³/MWh
            self.gas_consumption.append(gas_used)
            return gas_used * self.gas_price * 1000   # å…ƒ
        return 0.0

# ==================== ä¸‰ã€åˆ†å±‚MPCæ§åˆ¶å™¨ ====================
class HierarchicalMPC:
    def __init__(self, pred_horizon=10, control_horizon=5,
                 stochastic=True, n_scenarios=10, uncertainty_std=0.05):
        self.pred_horizon = pred_horizon
        self.control_horizon = control_horizon
        self.stochastic = stochastic
        self.n_scenarios = n_scenarios
        self.uncertainty_std = uncertainty_std
        self._buffer = None
        self.last_scenarios = None  # ä¿å­˜æœ€è¿‘ä¸€æ¬¡ç”Ÿæˆçš„åœºæ™¯ï¼Œç”¨äºå¯è§†åŒ–

    def wavelet_decompose(self, signal, levels=3, wavelet='db4'):
        """å°æ³¢åŒ…åˆ†è§£ï¼ˆé¢‘æ®µåˆ†ç¦»ï¼‰"""
        if not PYWT_AVAILABLE:
            # ç§»åŠ¨å¹³å‡è¿‘ä¼¼
            low = np.convolve(signal, np.ones(10)/10, mode='same')
            residual = signal - low
            mid = np.convolve(residual, np.ones(5)/5, mode='same')
            high = residual - mid
            return {'low': low, 'mid': mid, 'high': high}
        wp = pywt.WaveletPacket(data=signal, wavelet=wavelet,
                                mode='symmetric', maxlevel=levels)
        low = getattr(wp['a'*levels], 'data', np.zeros_like(signal))
        high = getattr(wp['d'*levels], 'data', np.zeros_like(signal))
        if len(low) != len(signal):
            low = np.interp(np.linspace(0,1,len(signal)), np.linspace(0,1,len(low)), low)
        if len(high) != len(signal):
            high = np.interp(np.linspace(0,1,len(signal)), np.linspace(0,1,len(high)), high)
        mid = signal - low - high
        return {'low': low, 'mid': mid, 'high': high}

    def economic_dispatch(self, devices, net_load, time_idx, dt, eco_mode=False):
        """ä¸Šå±‚ç»æµè°ƒåº¦ï¼šæœ€å°åŒ–æœŸæœ›æ€»æˆæœ¬ï¼ˆè´­ç”µ + å‚¨èƒ½è¿ç»´ + è€åŒ– + ç‡ƒæ–™ + å¯é€‰ç¢³æƒ©ç½šï¼‰"""
        n = len(devices)
        if n == 0:
            return np.array([])

        # åˆ†æ—¶ç”µä»·ï¼ˆå—äº¬å†¬å­£å·¥å•†ä¸šï¼‰
        hour = (time_idx * dt) / 3600 % 24
        if 0 <= hour < 6 or 11 <= hour < 13:
            price = 0.21           # ä½è°·
        elif 14 <= hour < 22:
            price = 1.12           # é«˜å³°
        else:
            price = 0.62           # å¹³æ®µ

        # è´Ÿè·è·Ÿè¸ªæƒ©ç½šç³»æ•°ï¼ˆé€‚åº¦ï¼Œä¿è¯é‡åˆåº¦ï¼‰
        track_penalty = 500.0      # å…ƒ/MW

        # ç”Ÿæˆå‡€è´Ÿè·åœºæ™¯ï¼ˆå¦‚æœå¯ç”¨éšæœºè§„åˆ’ï¼‰
        if self.stochastic:
            base = max(abs(net_load), 0.1)
            sigma = self.uncertainty_std * base
            scenarios = net_load + np.random.normal(0, sigma, self.n_scenarios)
            scenarios = np.maximum(scenarios, 0)   # å‡€è´Ÿè·ä¸èƒ½ä¸ºè´Ÿ
            weights = np.ones(self.n_scenarios) / self.n_scenarios
            self.last_scenarios = scenarios  # ä¿å­˜ç”¨äºå¯è§†åŒ–
        else:
            scenarios = np.array([net_load])
            weights = np.array([1.0])
            self.last_scenarios = None

        const = dt / 3600 * price * 1000   # è´­ç”µæˆæœ¬ç³»æ•° (å…ƒ/MWå¯¹åº”dtå†…çš„æˆæœ¬)

        def objective(x):
            total_power = np.sum(x)
            # å‚¨èƒ½æˆæœ¬
            storage_cost = sum(
                dev._calc_op_cost(x[i], dt) +
                dev._calc_aging_cost(x[i], dt, dev.soc) +
                (dev._calc_fuel_cost(x[i], dt) if hasattr(dev, '_calc_fuel_cost') else 0.0)
                for i, dev in enumerate(devices)
            )
            # æœŸæœ›è´­ç”µæˆæœ¬
            expected_grid_cost = 0.0
            carbon_cost = 0.0
            for s, w in zip(scenarios, weights):
                grid_power = s - total_power
                if grid_power > 0:
                    expected_grid_cost += w * grid_power * const
                    if eco_mode:
                        # ç¢³æƒ©ç½šæˆæœ¬ = è´­ç”µç”µé‡ (kWh) * ç¢³å› å­ * ç¢³ä»·æ ¼
                        carbon_cost += w * (grid_power * dt / 3600 * 1000) * CARBON_FACTOR * CARBON_PRICE
            # è´Ÿè·è·Ÿè¸ªæƒ©ç½š
            track_cost = track_penalty * (net_load - total_power) ** 2
            return expected_grid_cost + storage_cost + track_cost + carbon_cost

        bounds, x0 = [], []
        for dev in devices:
            max_charge = dev.get_charge_available() * 3600 / dt
            max_discharge = dev.get_discharge_available() * 3600 / dt
            p_min = -min(dev.power_rating, max_charge)
            p_max = min(dev.power_rating, max_discharge)
            bounds.append((p_min, p_max))
            x0.append(0.0)

        res = minimize(objective, x0, method='SLSQP', bounds=bounds,
                       options={'maxiter': 500, 'ftol': 1e-9})
        if not res.success:
            return np.zeros(n)
        return res.x

    def _allocate_frequency_power(self, devices, power_target, freq_type, dt):
        """æŒ‰é¢‘æ®µåˆ†é…åŠŸç‡ï¼ˆè¾¹é™…æˆæœ¬ä¼˜å…ˆï¼Œä½†é«˜é¢‘è®¾å¤‡æŒ‡å®šï¼‰"""
        if abs(power_target) < 1e-6:
            return {}
        allocation = {}
        remaining = power_target

        if freq_type == 'high':
            # é«˜é¢‘è®¾å¤‡ï¼šè¶…çº§ç”µå®¹å™¨ã€é£è½®å‚¨èƒ½ã€è¶…å¯¼ç£å‚¨èƒ½
            # ç¬¬ä¸€ä¼˜å…ˆçº§ï¼šè¶…çº§ç”µå®¹å™¨
            sc_devs = [d for d in devices if d.name == 'è¶…çº§ç”µå®¹å™¨']
            if sc_devs:
                dev = sc_devs[0]
                p_max = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt) if power_target > 0 else -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                assign = np.clip(power_target, -p_max if power_target<0 else 0, p_max if power_target>0 else 0) if power_target > 0 else np.clip(power_target, -p_max, 0)
                if abs(assign) > 0:
                    allocation[dev.name] = assign
                    remaining -= assign

            # ç¬¬äºŒä¼˜å…ˆçº§ï¼šé£è½®å‚¨èƒ½
            if abs(remaining) > 0.01:
                fess_devs = [d for d in devices if d.name == 'é£è½®å‚¨èƒ½']
                if fess_devs:
                    dev = fess_devs[0]
                    p_max = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt) if remaining > 0 else -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                    assign = np.clip(remaining, -p_max if remaining<0 else 0, p_max if remaining>0 else 0) if remaining > 0 else np.clip(remaining, -p_max, 0)
                    if abs(assign) > 0:
                        allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                        remaining -= assign

            # ç¬¬ä¸‰ä¼˜å…ˆçº§ï¼šè¶…å¯¼ç£å‚¨èƒ½
            if abs(remaining) > 0.01:
                smes_devs = [d for d in devices if d.name == 'è¶…å¯¼ç£å‚¨èƒ½']
                if smes_devs:
                    dev = smes_devs[0]
                    p_max = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt) if remaining > 0 else -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                    assign = np.clip(remaining, -abs(p_max) if remaining<0 else 0, abs(p_max) if remaining>0 else 0)
                    if abs(assign) > 0.01:
                        allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                        remaining -= assign

        elif freq_type == 'mid':
            # ä¸­é¢‘è®¾å¤‡ï¼šé£è½®å‚¨èƒ½ã€é”‚ç”µæ± å‚¨èƒ½
            eligible = [d for d in devices if d.name in ['é£è½®å‚¨èƒ½', 'é”‚ç”µæ± å‚¨èƒ½']]
            eligible.sort(key=lambda d: d.marginal_cost)
            for dev in eligible:
                if abs(remaining) < 1e-6:
                    break
                if remaining > 0:
                    p_max = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt)
                    assign = min(remaining, p_max)
                else:
                    p_min = -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                    assign = max(remaining, p_min)
                if abs(assign) > 0:
                    allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                    remaining -= assign

        else:   # low
            # ä½é¢‘è®¾å¤‡ï¼šå‹ç¼©ç©ºæ°”å‚¨èƒ½ã€é”‚ç”µæ± å‚¨èƒ½
            eligible = [d for d in devices if d.name in ['å‹ç¼©ç©ºæ°”å‚¨èƒ½', 'é”‚ç”µæ± å‚¨èƒ½']]
            eligible.sort(key=lambda d: d.marginal_cost)
            for dev in eligible:
                if abs(remaining) < 1e-6:
                    break
                if remaining > 0:
                    p_max = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt)
                    assign = min(remaining, p_max)
                else:
                    p_min = -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                    assign = max(remaining, p_min)
                if abs(assign) > 0:
                    allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                    remaining -= assign

        return allocation

    def real_time_balance(self, devices, net_load, dt):
        """ä¸‹å±‚å®æ—¶å¹³è¡¡ï¼šå°æ³¢åˆ†è§£ + é¢‘æ®µåˆ†é…ï¼Œä»¥æœ€å°åŒ–å¿«é€Ÿå‚¨èƒ½æ€»å‡ºåŠ›ä¸å¾…å¹³è¡¡ä¸­é«˜é¢‘åŠŸç‡åå·®ä¸ºç›®æ ‡"""
        if self._buffer is None:
            self._buffer = np.ones(16) * net_load
        else:
            self._buffer = np.roll(self._buffer, -1)
            self._buffer[-1] = net_load

        comp = self.wavelet_decompose(self._buffer, levels=2)
        high = comp['high'][-1] if len(comp['high']) else 0
        mid = comp['mid'][-1] if len(comp['mid']) else 0
        low = comp['low'][-1] if len(comp['low']) else 0

        alloc = {}
        # é«˜é¢‘åˆ†é…
        alloc_high = self._allocate_frequency_power(devices, high, 'high', dt)
        for k, v in alloc_high.items():
            alloc[k] = alloc.get(k, 0.0) + v
        # ä¸­é¢‘åˆ†é…
        alloc_mid = self._allocate_frequency_power(devices, mid, 'mid', dt)
        for k, v in alloc_mid.items():
            alloc[k] = alloc.get(k, 0.0) + v
        # ä½é¢‘åˆ†é…
        alloc_low = self._allocate_frequency_power(devices, low, 'low', dt)
        for k, v in alloc_low.items():
            alloc[k] = alloc.get(k, 0.0) + v

        return alloc

# ==================== å››ã€æ··åˆå‚¨èƒ½ç³»ç»Ÿä¸»ç±» ====================
class HybridEnergyStorageSystem:
    def __init__(self):
        self.device_specs = {
            'é£è½®å‚¨èƒ½': {'class': FESS},
            'è¶…å¯¼ç£å‚¨èƒ½': {'class': SMES},
            'è¶…çº§ç”µå®¹å™¨': {'class': SC},
            'é”‚ç”µæ± å‚¨èƒ½': {'class': BESS},
            'å‹ç¼©ç©ºæ°”å‚¨èƒ½': {'class': CAES}
        }
        self.devices = []
        self.mpc = HierarchicalMPC(stochastic=True, n_scenarios=10, uncertainty_std=0.05)
        self.simulation_results = None
        self.monitor_window = None
        self.monitor_labels = {}
        self.total_cost_label = None
        self.grid_power_label = None
        self.trend_canvases = {}  # ç”¨äºå­˜å‚¨è¶‹åŠ¿å›¾çš„Canvas
        self.trend_data = {}       # å­˜å‚¨æ¯ä¸ªè®¾å¤‡æœ€è¿‘åŠŸç‡æ•°æ®

    def create_devices(self, selected_names):
        self.devices = []
        for name in selected_names:
            dev_class = self.device_specs[name]['class']
            self.devices.append(dev_class())
            self.trend_data[name] = []  # åˆå§‹åŒ–è¶‹åŠ¿æ•°æ®

    def _clip_power_to_limits(self, power, dev, dt):
        """å°†å•ä¸ªè®¾å¤‡çš„åŠŸç‡è£å‰ªåˆ°å¯è°ƒèŒƒå›´å†…"""
        max_charge = dev.get_charge_available() * 3600 / dt
        max_discharge = dev.get_discharge_available() * 3600 / dt
        p_min = -min(dev.power_rating, max_charge)
        p_max = min(dev.power_rating, max_discharge)
        return np.clip(power, p_min, p_max)

    def _adjust_power_to_track(self, set_powers, devices, target, dt):
        """äºŒæ¬¡åŠŸç‡è°ƒæ•´ï¼šè‹¥å½“å‰æ€»åŠŸç‡ä¸ç›®æ ‡å‡€è´Ÿè·åå·®è¶…è¿‡0.05MWï¼Œåˆ™æŒ‰å„è®¾å¤‡å‰©ä½™å¯è°ƒå®¹é‡æ¯”ä¾‹è¡¥å……"""
        current_total = np.sum(set_powers)
        diff = target - current_total
        if abs(diff) < 0.05:
            return set_powers

        capacities = []
        for i, dev in enumerate(devices):
            max_charge = dev.get_charge_available() * 3600 / dt
            max_discharge = dev.get_discharge_available() * 3600 / dt
            p_min = -min(dev.power_rating, max_charge)
            p_max = min(dev.power_rating, max_discharge)
            if diff > 0:
                room = p_max - set_powers[i]
            else:
                room = set_powers[i] - p_min
            capacities.append(max(0, room))

        total_capacity = np.sum(capacities)
        if total_capacity < abs(diff):
            scale = 1.0
        else:
            scale = abs(diff) / total_capacity

        adjusted = set_powers.copy()
        for i in range(len(devices)):
            if capacities[i] > 0:
                if diff > 0:
                    adjusted[i] += capacities[i] * scale
                else:
                    adjusted[i] -= capacities[i] * scale
        return adjusted

    def _update_trend_graph(self, dev_name, power):
        """æ›´æ–°è¶‹åŠ¿å›¾æ•°æ®å¹¶é‡ç»˜"""
        # ä¿å­˜æœ€è¿‘50ä¸ªç‚¹ï¼ˆå¯¹åº”5ç§’ï¼Œdt=0.1ï¼‰
        max_points = 50
        if dev_name not in self.trend_data:
            self.trend_data[dev_name] = []
        data = self.trend_data[dev_name]
        data.append(power)
        if len(data) > max_points:
            data.pop(0)
        # æ›´æ–°å¯¹åº”çš„Canvas
        if dev_name in self.trend_canvases:
            canvas = self.trend_canvases[dev_name]
            canvas.delete("trend")
            if len(data) < 2:
                return
            w = canvas.winfo_width()
            h = canvas.winfo_height()
            if w <= 1 or h <= 1:
                return
            # ç»˜åˆ¶æŠ˜çº¿
            points = []
            for i, val in enumerate(data):
                x = (i / (max_points - 1)) * w
                # å°†åŠŸç‡æ˜ å°„åˆ°ç”»å¸ƒé«˜åº¦ï¼Œå‡è®¾é¢å®šåŠŸç‡ä¸ºå‚è€ƒï¼Œæ˜¾ç¤ºèŒƒå›´[-rating, rating]
                dev = next(d for d in self.devices if d.name == dev_name)
                rating = dev.power_rating
                # yåæ ‡ï¼šåŠŸç‡æ­£ä¸ºå‘ä¸Šï¼Œè´Ÿä¸ºå‘ä¸‹ï¼ŒèŒƒå›´[-rating, rating] æ˜ å°„åˆ° [h, 0]
                y = h/2 - (val / rating) * (h/2 - 5)  # ç•™è¾¹è·
                points.append((x, y))
            if len(points) > 1:
                canvas.create_line(points, fill='blue', width=1, tags="trend")
            # ç»˜åˆ¶é›¶çº¿
            canvas.create_line(0, h/2, w, h/2, fill='gray', dash=(2,2), tags="trend")

    def simulate(self, pulse_amp, pulse_dur, plant_power=10.0, sim_time=30, dt=0.1, econ_interval=1, eco_mode=False):
        time = np.arange(0, sim_time, dt)
        n = len(time)

        # è´Ÿè·ï¼šåŸºç¡€plant_power MW + è„‰å†²
        load = plant_power * np.ones_like(time)
        start = int(10.0 / dt)
        end = int((10.0 + pulse_dur) / dt)
        load[start:end] += pulse_amp

        plant = plant_power * np.ones_like(time)   # ç”µå‚æ’å‘
        net_load = load - plant

        res = {
            'time': time, 'load': load, 'plant': plant, 'net_load': net_load,
            'smoothed_load': np.zeros_like(time),
            'total_ess': np.zeros_like(time),
            'grid_power': np.zeros_like(time),
            'grid_purchase': np.zeros_like(time),
            'device_power': {d.name: np.zeros_like(time) for d in self.devices},
            'device_soc': {d.name: np.zeros_like(time) for d in self.devices},
            'device_energy': {d.name: np.zeros_like(time) for d in self.devices},
            'device_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_op_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_aging_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_fuel_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_current': {d.name: np.zeros_like(time) for d in self.devices},
            'device_voltage': {d.name: np.zeros_like(time) for d in self.devices},
            'pulse_amp': pulse_amp, 'pulse_dur': pulse_dur,
            'eco_mode': eco_mode
        }

        total_purchase = 0.0
        total_op = 0.0
        total_aging = 0.0
        total_fuel = 0.0
        total_carbon_penalty = 0.0

        last_econ_powers = np.zeros(len(self.devices))
        econ_cnt = econ_interval + 1

        # åˆå§‹åŒ–ç›‘æ§çª—å£
        self._update_monitor(init=True)

        for t in range(n):
            demand = net_load[t]

            # ä¸Šå±‚ç»æµè°ƒåº¦
            if econ_cnt >= econ_interval:
                last_econ_powers = self.mpc.economic_dispatch(self.devices, demand, t, dt, eco_mode=eco_mode)
                econ_cnt = 0
            econ_cnt += 1

            # ä¸‹å±‚å®æ—¶å¹³è¡¡
            alloc = self.mpc.real_time_balance(self.devices, demand, dt)

            # ç»„åˆæŒ‡ä»¤
            set_powers = last_econ_powers.copy()
            for i, dev in enumerate(self.devices):
                if dev.name in alloc:
                    set_powers[i] += alloc[dev.name]

            # åŠŸç‡è¾¹ç•Œè£å‰ª
            for i, dev in enumerate(self.devices):
                set_powers[i] = self._clip_power_to_limits(set_powers[i], dev, dt)

            # äºŒæ¬¡åŠŸç‡è°ƒæ•´
            set_powers = self._adjust_power_to_track(set_powers, self.devices, demand, dt)

            # å¼ºåˆ¶ä¸å…è®¸å‘ç”µç½‘å”®ç”µ
            total_ess_now = np.sum(set_powers)
            if total_ess_now > demand + 1e-6:
                excess = total_ess_now - demand
                discharge_indices = [i for i, p in enumerate(set_powers) if p > 0]
                if discharge_indices:
                    discharge_powers = np.array([set_powers[i] for i in discharge_indices])
                    total_discharge = np.sum(discharge_powers)
                    reduction_factors = discharge_powers / total_discharge
                    reductions = reduction_factors * excess
                    for idx, red in zip(discharge_indices, reductions):
                        set_powers[idx] = max(0, set_powers[idx] - red)
                    total_ess_now = np.sum(set_powers)
                    if total_ess_now > demand + 1e-6:
                        diff = total_ess_now - demand
                        for i in discharge_indices:
                            if set_powers[i] > diff:
                                set_powers[i] -= diff
                                break

            total_ess = 0.0
            for i, dev in enumerate(self.devices):
                set_power = set_powers[i]
                soc, cost, energy = dev.update_state(set_power, dt)
                total_op += dev.history_op_cost[-1]
                total_aging += dev.history_aging_cost[-1]
                total_fuel += dev.history_fuel_cost[-1]

                res['device_power'][dev.name][t] = dev.current_power
                res['device_soc'][dev.name][t] = soc
                res['device_energy'][dev.name][t] = energy
                res['device_cost'][dev.name][t] = cost
                res['device_op_cost'][dev.name][t] = dev.history_op_cost[-1]
                res['device_aging_cost'][dev.name][t] = dev.history_aging_cost[-1]
                res['device_fuel_cost'][dev.name][t] = dev.history_fuel_cost[-1]
                res['device_current'][dev.name][t] = dev.current
                res['device_voltage'][dev.name][t] = dev.voltage
                total_ess += dev.current_power

                # æ›´æ–°è¶‹åŠ¿å›¾
                self._update_trend_graph(dev.name, dev.current_power)

            res['total_ess'][t] = total_ess
            res['smoothed_load'][t] = plant[t] + total_ess
            res['grid_power'][t] = max(0, demand - total_ess)

            # è´­ç”µè´¹ç”¨
            hour = (t * dt) / 3600 % 24
            if 0 <= hour < 6 or 11 <= hour < 13:
                price = 0.21
            elif 14 <= hour < 22:
                price = 1.12
            else:
                price = 0.62
            if res['grid_power'][t] > 0:
                purchase = res['grid_power'][t] * dt / 3600 * price * 1000
                res['grid_purchase'][t] = purchase
                total_purchase += purchase
                if eco_mode:
                    # ç¢³æƒ©ç½šæˆæœ¬
                    carbon_penalty = (res['grid_power'][t] * dt / 3600 * 1000) * CARBON_FACTOR * CARBON_PRICE
                    total_carbon_penalty += carbon_penalty

            if t % 5 == 0:
                self._update_monitor(total_purchase + total_op + total_aging + total_fuel + total_carbon_penalty, res['grid_power'][t])

        self.sim_res = res
        self.total_purchase = total_purchase
        self.total_op = total_op
        self.total_aging = total_aging
        self.total_fuel = total_fuel
        self.total_carbon_penalty = total_carbon_penalty
        self.total_cost = total_purchase + total_op + total_aging + total_fuel + total_carbon_penalty
        self.net_cost = self.total_cost

        return res

    def _update_monitor(self, total_cost=None, grid_power=None, init=False):
        """å®æ—¶ç›‘æ§é¢æ¿ï¼ˆæ˜¾ç¤ºåŠŸç‡/SOC/å¯å……æ”¾ç”µé‡/ç”µæµ/ç”µå‹/åŠŸç‡è¶‹åŠ¿ï¼Œè¶Šç•Œçº¢è‰²é¢„è­¦ï¼‰"""
        if init:
            self.monitor_window = tk.Toplevel()
            self.monitor_window.title("å‚¨èƒ½ç³»ç»Ÿå®æ—¶ç›‘æ§ (ç»æµåˆ†é… + é«˜ç²¾åº¦è·Ÿè¸ª + éšæœºè§„åˆ’)")
            self.monitor_window.geometry("900x750")
            self.monitor_labels = {}

            # åˆ›å»ºä¸»ç”»å¸ƒå’Œæ»šåŠ¨æ¡ï¼Œä»¥ä¾¿å®¹çº³æ›´å¤šè®¾å¤‡
            canvas = tk.Canvas(self.monitor_window)
            scrollbar = tk.Scrollbar(self.monitor_window, orient="vertical", command=canvas.yview)
            scrollable_frame = ttk.Frame(canvas)

            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)

            for dev in self.devices:
                frame = ttk.LabelFrame(scrollable_frame, text=dev.name, padding=(8,5))
                frame.pack(fill='x', padx=10, pady=6)

                # ç¬¬ä¸€è¡Œï¼šåŠŸç‡ã€SOC
                ttk.Label(frame, text="åŠŸç‡ (MW):").grid(row=0, column=0, sticky='w')
                l1 = ttk.Label(frame, text="0.00", width=8)
                l1.grid(row=0, column=1)

                ttk.Label(frame, text="SOC:").grid(row=0, column=2, sticky='w', padx=(10,0))
                l2 = ttk.Label(frame, text="0.80", width=6)
                l2.grid(row=0, column=3)

                # ç¬¬äºŒè¡Œï¼šå¯å……ã€å¯æ”¾
                ttk.Label(frame, text="å¯å……(MWh):").grid(row=1, column=0, sticky='w')
                l3 = ttk.Label(frame, text="0.00", width=8)
                l3.grid(row=1, column=1)

                ttk.Label(frame, text="å¯æ”¾(MWh):").grid(row=1, column=2, sticky='w', padx=(10,0))
                l4 = ttk.Label(frame, text="0.00", width=8)
                l4.grid(row=1, column=3)

                # ç¬¬ä¸‰è¡Œï¼šç”µæµã€ç”µå‹
                ttk.Label(frame, text="ç”µæµ (A):").grid(row=2, column=0, sticky='w')
                l5 = ttk.Label(frame, text="0.0", width=8)
                l5.grid(row=2, column=1)

                ttk.Label(frame, text="ç”µå‹ (V):").grid(row=2, column=2, sticky='w', padx=(10,0))
                l6 = ttk.Label(frame, text="0.0", width=8)
                l6.grid(row=2, column=3)

                # ç¬¬å››è¡Œï¼šåŠŸç‡è£•åº¦
                ttk.Label(frame, text="åŠŸç‡è£•åº¦:").grid(row=3, column=0, sticky='w')
                l7 = ttk.Label(frame, text="100%", width=6)
                l7.grid(row=3, column=1)

                # åˆ›æ–°ï¼šåŠŸç‡è¶‹åŠ¿å›¾ (å°å‹Canvas)
                trend_canvas = tk.Canvas(frame, width=180, height=50, bg='white', highlightthickness=1, highlightbackground='gray')
                trend_canvas.grid(row=0, column=4, rowspan=4, padx=(10,0), sticky='nsew')
                self.trend_canvases[dev.name] = trend_canvas

                self.monitor_labels[dev.name] = (l1, l2, l3, l4, l5, l6, l7)

            # åº•éƒ¨å…¨å±€ä¿¡æ¯
            bottom_frame = ttk.Frame(scrollable_frame)
            bottom_frame.pack(fill='x', padx=10, pady=10)
            ttk.Label(bottom_frame, text="ç´¯è®¡æ€»æˆæœ¬(å…ƒ):", font=('å¾®è½¯é›…é»‘',10)).pack(side='left')
            self.total_cost_label = ttk.Label(bottom_frame, text="0.00", font=('å¾®è½¯é›…é»‘',10,'bold'), foreground='blue')
            self.total_cost_label.pack(side='left', padx=5)
            ttk.Label(bottom_frame, text="ç”µç½‘åŠŸç‡(MW):", font=('å¾®è½¯é›…é»‘',10)).pack(side='left', padx=(20,0))
            self.grid_power_label = ttk.Label(bottom_frame, text="0.00", font=('å¾®è½¯é›…é»‘',10,'bold'), foreground='green')
            self.grid_power_label.pack(side='left', padx=5)

            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            self.monitor_window.update()
        else:
            for dev in self.devices:
                if dev.name in self.monitor_labels:
                    l1, l2, l3, l4, l5, l6, l7 = self.monitor_labels[dev.name]
                    l1.config(text=f"{dev.current_power:.3f}")
                    l2.config(text=f"{dev.soc:.3f}")
                    l3.config(text=f"{dev.get_charge_available():.3f}")
                    l4.config(text=f"{dev.get_discharge_available():.3f}")
                    if abs(dev.current) > 999:
                        l5.config(text=f"{dev.current/1000:.2f}k")
                    else:
                        l5.config(text=f"{dev.current:.1f}")
                    l6.config(text=f"{dev.voltage:.1f}")
                    # SOCè¶Šç•Œçº¢è‰²é¢„è­¦
                    if dev.soc < 0.11 or dev.soc > 0.89:
                        l2.config(foreground='red')
                    else:
                        l2.config(foreground='black')
                    # åŠŸç‡è£•åº¦é¢„è­¦ï¼ˆå½“å‰åŠŸç‡ä¸é¢å®šåŠŸç‡æ¯”å€¼ï¼‰
                    ratio = abs(dev.current_power) / dev.power_rating * 100
                    if ratio > 90:
                        l7.config(text=f"{ratio:.0f}%", foreground='red')
                    elif ratio > 75:
                        l7.config(text=f"{ratio:.0f}%", foreground='orange')
                    else:
                        l7.config(text=f"{ratio:.0f}%", foreground='green')
            if total_cost is not None:
                self.total_cost_label.config(text=f"{total_cost:,.2f}")
            if grid_power is not None:
                self.grid_power_label.config(text=f"{grid_power:.3f}")
            self.monitor_window.update()

    def close_monitor(self):
        """å…³é—­å®æ—¶ç›‘æ§çª—å£"""
        if self.monitor_window:
            self.monitor_window.destroy()
            self.monitor_window = None

# ==================== äº”ã€GUIç”¨æˆ·ç•Œé¢ ====================
class HESSGUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("æ··åˆå‚¨èƒ½è„‰å†²å¹³æ»‘æ§åˆ¶(20MW/480MWh) - ç»æµåˆ†é… + é«˜ç²¾åº¦è·Ÿè¸ª + éšæœºè§„åˆ’")
        self.root.geometry("650x800")
        self.pulse_amp = tk.DoubleVar(value=12.0)
        self.pulse_dur = tk.DoubleVar(value=10.0)
        self.plant_power = tk.DoubleVar(value=10.0)  # å¾®ç”µç½‘è§„æ¨¡ï¼ˆç”µå‚æ’å‘åŠŸç‡ï¼‰
        self.dev_vars = {
            'é£è½®å‚¨èƒ½': tk.BooleanVar(value=True),
            'è¶…å¯¼ç£å‚¨èƒ½': tk.BooleanVar(value=True),
            'è¶…çº§ç”µå®¹å™¨': tk.BooleanVar(value=True),
            'é”‚ç”µæ± å‚¨èƒ½': tk.BooleanVar(value=True),
            'å‹ç¼©ç©ºæ°”å‚¨èƒ½': tk.BooleanVar(value=True)
        }
        self.use_stochastic = tk.BooleanVar(value=True)
        self.n_scenarios = tk.IntVar(value=10)
        self.uncertainty_std = tk.DoubleVar(value=0.05)
        self.eco_mode = tk.BooleanVar(value=False)  # ç¯ä¿æ¨¡å¼
        self.sim_running = False  # é˜²æ­¢é‡å¤ç‚¹å‡»
        self.setup_ui()

    def setup_ui(self):
        tk.Label(self.root, text="æ··åˆå‚¨èƒ½ç³»ç»Ÿ(HESS)è„‰å†²å¹³æ»‘æ§åˆ¶",
                 font=("å¾®è½¯é›…é»‘", 16, "bold")).pack(pady=10)

        # è„‰å†²å‚æ•°è®¾ç½®åŒºåŸŸï¼ˆä¸Šä¸‹æ’åˆ—ï¼‰
        pf = tk.LabelFrame(self.root, text="è„‰å†²å‚æ•°è®¾ç½® (å³°å€¼â‰¤20MW, æ—¶é•¿â‰¤20s)", padx=10, pady=10)
        pf.pack(padx=20, pady=10, fill='x')

        # å¹…å€¼æ»‘å—ï¼ˆä¸Šï¼‰
        frame_amp = tk.Frame(pf)
        frame_amp.pack(fill='x', pady=5)
        tk.Label(frame_amp, text="è„‰å†²å¹…å€¼ (MW):", width=15, anchor='w').pack(side='left')
        tk.Scale(frame_amp, from_=1, to=20, orient='horizontal',
                 variable=self.pulse_amp, length=280).pack(side='left', padx=5)
        tk.Label(frame_amp, textvariable=self.pulse_amp, width=4).pack(side='left')

        # æŒç»­æ—¶é—´æ»‘å—ï¼ˆä¸‹ï¼‰
        frame_dur = tk.Frame(pf)
        frame_dur.pack(fill='x', pady=5)
        tk.Label(frame_dur, text="è„‰å†²æŒç»­æ—¶é—´ (s):", width=15, anchor='w').pack(side='left')
        tk.Scale(frame_dur, from_=1, to=20, orient='horizontal',
                 variable=self.pulse_dur, length=280).pack(side='left', padx=5)
        tk.Label(frame_dur, textvariable=self.pulse_dur, width=4).pack(side='left')

        # å¾®ç”µç½‘è§„æ¨¡ï¼ˆç”µå‚å‡ºåŠ›ï¼‰
        mg_frame = tk.Frame(pf)
        mg_frame.pack(fill='x', pady=5)
        tk.Label(mg_frame, text="ç”µå‚æ’å‘åŠŸç‡ (MW):", width=15, anchor='w').pack(side='left')
        tk.Spinbox(mg_frame, from_=1, to=20, textvariable=self.plant_power,
                   width=8, font=('å¾®è½¯é›…é»‘',10)).pack(side='left', padx=5)
        tk.Label(mg_frame, text="MW", font=('å¾®è½¯é›…é»‘',10)).pack(side='left')

        # éšæœºè§„åˆ’å‚æ•°åŒºåŸŸ
        spf = tk.LabelFrame(self.root, text="éšæœºè§„åˆ’å‚æ•°", padx=10, pady=10)
        spf.pack(padx=20, pady=10, fill='x')
        tk.Checkbutton(spf, text="å¯ç”¨éšæœºè§„åˆ’", variable=self.use_stochastic,
                       font=("å¾®è½¯é›…é»‘", 11)).pack(anchor='w')
        tk.Label(spf, text="åœºæ™¯æ•°é‡:").pack(side='left')
        tk.Spinbox(spf, from_=1, to=50, textvariable=self.n_scenarios,
                   width=5).pack(side='left', padx=5)
        tk.Label(spf, text=" é¢„æµ‹è¯¯å·®æ ‡å‡†å·® (%):").pack(side='left')
        tk.Spinbox(spf, from_=1, to=30, textvariable=self.uncertainty_std,
                   width=5, format="%.2f").pack(side='left', padx=5)

        # é«˜çº§é€‰é¡¹åŒºåŸŸï¼ˆåˆ›æ–°è®¾è®¡ï¼‰
        advf = tk.LabelFrame(self.root, text="é«˜çº§é€‰é¡¹ (åˆ›æ–°è®¾è®¡)", padx=10, pady=10)
        advf.pack(padx=20, pady=10, fill='x')
        tk.Checkbutton(advf, text="ğŸŒ¿ ç¯ä¿æ¨¡å¼ (è€ƒè™‘ç¢³å‡æ’æƒ©ç½š)", variable=self.eco_mode,
                       font=("å¾®è½¯é›…é»‘", 11)).pack(anchor='w')
        tk.Label(advf, text="ç¢³ä»·æ ¼: 0.05 å…ƒ/kg COâ‚‚ (å›ºå®š)", font=('å¾®è½¯é›…é»‘',9), fg='gray').pack(anchor='w', padx=20)

        # å‚¨èƒ½è®¾å¤‡é€‰æ‹©åŒºåŸŸ
        df = tk.LabelFrame(self.root, text="å‚¨èƒ½è®¾å¤‡é€‰æ‹© (æ€»åŠŸç‡20MW/æ€»å®¹é‡480MWh)", padx=10, pady=10)
        df.pack(padx=20, pady=10, fill='x')
        for name, var in self.dev_vars.items():
            tk.Checkbutton(df, text=name, variable=var, font=("å¾®è½¯é›…é»‘", 11)).pack(anchor='w', pady=2)

        # æŒ‰é’®åŒºåŸŸ
        btnf = tk.Frame(self.root)
        btnf.pack(pady=10)
        self.start_btn = tk.Button(btnf, text="âš¡ å¼€å§‹ä»¿çœŸ", command=self.run_sim,
                                    bg="green", fg="white", font=("å¾®è½¯é›…é»‘", 12), width=14)
        self.start_btn.pack(side='left', padx=8)
        tk.Button(btnf, text="âŒ é€€å‡º", command=self.root.quit,
                  bg="red", fg="white", font=("å¾®è½¯é›…é»‘", 12), width=14).pack(side='left', padx=8)

        # çŠ¶æ€æ ‡ç­¾ï¼ˆåˆ›æ„åŠ¨æ€æç¤ºï¼‰
        self.status = tk.Label(self.root, text="âœ¨ å°±ç»ªï¼Œè¯·è®¾ç½®å‚æ•°å¹¶é€‰æ‹©è®¾å¤‡", font=("å¾®è½¯é›…é»‘", 10), fg="blue")
        self.status.pack(pady=5)

        # åˆ›æ„å°è´´å£«
        tip_frame = tk.LabelFrame(self.root, text="ğŸ’¡ åˆ›æ„å°è´´å£«", padx=10, pady=5)
        tip_frame.pack(padx=20, pady=5, fill='x')
        tk.Label(tip_frame, text="âœ“ å¯è‡ªå®šä¹‰å¾®ç”µç½‘è§„æ¨¡ï¼ˆç”µå‚å‡ºåŠ›ï¼‰ï¼Œæ¨¡æ‹Ÿä¸åŒåœºæ™¯",
                 font=("å¾®è½¯é›…é»‘", 9), fg="gray").pack(anchor='w')
        tk.Label(tip_frame, text="âœ“ ç¯ä¿æ¨¡å¼å°†åœ¨ç»æµè°ƒåº¦ä¸­åŠ å…¥ç¢³æˆæœ¬ï¼Œå¼•å¯¼ç»¿è‰²è¿è¡Œ",
                 font=("å¾®è½¯é›…é»‘", 9), fg="gray").pack(anchor='w')
        tk.Label(tip_frame, text="âœ“ å®æ—¶ç›‘æ§é¢æ¿æ–°å¢åŠŸç‡è¶‹åŠ¿å›¾ï¼ŒåŠ¨æ€æ˜¾ç¤ºåŠŸç‡å˜åŒ–",
                 font=("å¾®è½¯é›…é»‘", 9), fg="gray").pack(anchor='w')

    def run_sim(self):
        if self.sim_running:
            messagebox.showinfo("æç¤º", "ä»¿çœŸæ­£åœ¨è¿›è¡Œä¸­ï¼Œè¯·ç¨å€™...")
            return

        selected = [name for name, var in self.dev_vars.items() if var.get()]
        if not selected:
            messagebox.showerror("é”™è¯¯", "è‡³å°‘é€‰æ‹©ä¸€ä¸ªå‚¨èƒ½è®¾å¤‡ï¼")
            return

        # ç¦ç”¨å¼€å§‹æŒ‰é’®ï¼Œé˜²æ­¢é‡å¤ç‚¹å‡»
        self.start_btn.config(state='disabled')
        self.status.config(text="ğŸš€ ä»¿çœŸè¿›è¡Œä¸­... æ­£åœ¨æ¶ˆé™¤è„‰å†²...", fg="orange")
        self.root.update()

        self.sim_running = True

        try:
            amp = self.pulse_amp.get()
            dur = self.pulse_dur.get()
            plant_power = self.plant_power.get()
            hess = HybridEnergyStorageSystem()
            hess.mpc.stochastic = self.use_stochastic.get()
            hess.mpc.n_scenarios = self.n_scenarios.get()
            hess.mpc.uncertainty_std = self.uncertainty_std.get()
            hess.create_devices(selected)
            results = hess.simulate(amp, dur, plant_power=plant_power, econ_interval=1, eco_mode=self.eco_mode.get())

            # ä»¿çœŸç»“æŸåæ›´æ–°çŠ¶æ€
            self.status.config(text="âœ… ä»¿çœŸå®Œæˆï¼å¹³æ»‘åè´Ÿè·ä¸åŸå§‹è´Ÿè·é«˜åº¦é‡åˆ", fg="green")
            self.start_btn.config(state='normal')
            self.sim_running = False

            # å¼¹å‡ºè¯¦ç»†ç»“æœçª—å£
            self.show_results(hess, results, amp, dur, selected)

        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"ä»¿çœŸå¼‚å¸¸ï¼š{str(e)}")
            self.status.config(text="âŒ ä»¿çœŸå¤±è´¥", fg="red")
            self.start_btn.config(state='normal')
            self.sim_running = False

    def show_results(self, hess, res, amp, dur, selected):
        # æ±‡æ€»æˆæœ¬
        total_purchase = hess.total_purchase
        total_op = hess.total_op
        total_aging = hess.total_aging
        total_fuel = hess.total_fuel
        total_carbon = hess.total_carbon_penalty
        total_cost = hess.total_cost
        net_cost = hess.net_cost

        # ç¢³å‡æ’ä¼°ç®— (åŸºäºç”µç½‘è´­ç”µå‡å°‘é‡ï¼Œä¸æ— å‚¨èƒ½æ—¶å¯¹æ¯”)
        total_grid_without_storage = np.sum(res['net_load']) * 0.1 / 3600  # MWh
        total_grid_with_storage = np.sum(res['grid_power']) * 0.1 / 3600
        grid_reduction = total_grid_without_storage - total_grid_with_storage  # MWh
        carbon_reduction = grid_reduction * 1000 * CARBON_FACTOR  # kg COâ‚‚

        # å„è®¾å¤‡æŒ‡æ ‡
        dev_charge = {}
        dev_discharge = {}
        dev_avg_p = {}
        dev_max_p = {}
        for dev in hess.devices:
            p = res['device_power'][dev.name]
            dev_charge[dev.name] = -np.sum(p[p < 0]) * 0.1 / 3600
            dev_discharge[dev.name] = np.sum(p[p > 0]) * 0.1 / 3600
            dev_avg_p[dev.name] = np.mean(np.abs(p))
            dev_max_p[dev.name] = np.max(np.abs(p))

        # è„‰å†²æœŸé—´åŠŸç‡åˆ†é…å æ¯”
        mask = (res['time'] >= 10) & (res['time'] < 10 + dur)
        pulse_power = {}
        for dev in hess.devices:
            avg = np.mean(np.abs(res['device_power'][dev.name][mask]))
            if avg > 0.01:
                pulse_power[dev.name] = avg

        # è®¡ç®—å¹³æ»‘æ€§èƒ½è¯„åˆ†ï¼ˆåˆ›æ„æŒ‡æ ‡ï¼‰
        rmse = np.sqrt(np.mean((res['load'] - res['smoothed_load'])**2))
        max_dev = np.max(np.abs(res['load'] - res['smoothed_load']))
        smooth_score = max(0, 100 - rmse * 200)  # å‡è®¾RMSE 0.5 -> 0åˆ†ï¼Œ0 -> 100åˆ†

        # åˆ›å»ºç‹¬ç«‹çš„ç»“æœçª—å£
        win = tk.Toplevel()
        win.title("è„‰å†²å¹³æ»‘ä»¿çœŸè¯¦ç»†ç»“æœ")
        win.geometry("1000x850")

        main_frame = ttk.Frame(win)
        main_frame.pack(fill='both', expand=True, padx=10, pady=10)

        # ä¸Šéƒ¨å…³é”®æŒ‡æ ‡æ‘˜è¦
        summary_frame = ttk.LabelFrame(main_frame, text="ğŸŒŸ å…³é”®æŒ‡æ ‡æ‘˜è¦", padding=(10,5))
        summary_frame.pack(fill='x', pady=(0,10))

        row1 = ttk.Frame(summary_frame)
        row1.pack(fill='x', pady=2)
        ttk.Label(row1, text="å¹³æ»‘æ•ˆæœè¯„åˆ†:", font=('å¾®è½¯é›…é»‘',10)).pack(side='left')
        score_color = 'green' if smooth_score >= 90 else ('orange' if smooth_score >= 70 else 'red')
        ttk.Label(row1, text=f"{smooth_score:.1f} åˆ†", font=('å¾®è½¯é›…é»‘',12,'bold'), foreground=score_color).pack(side='left', padx=5)

        ttk.Label(row1, text="æ€»æˆæœ¬:", font=('å¾®è½¯é›…é»‘',10)).pack(side='left', padx=(20,0))
        ttk.Label(row1, text=f"{total_cost:,.0f} å…ƒ", font=('å¾®è½¯é›…é»‘',12,'bold'), foreground='blue').pack(side='left', padx=5)

        row2 = ttk.Frame(summary_frame)
        row2.pack(fill='x', pady=2)
        ttk.Label(row2, text="ç”µç½‘è´­ç”µæ¯”ä¾‹:", font=('å¾®è½¯é›…é»‘',10)).pack(side='left')
        grid_ratio = total_purchase / (total_purchase + total_op + total_aging + total_fuel + total_carbon + 1e-9) * 100
        ttk.Label(row2, text=f"{grid_ratio:.1f}%", font=('å¾®è½¯é›…é»‘',10,'bold')).pack(side='left', padx=5)

        ttk.Label(row2, text="æœ€å¤§ç¬æ—¶åå·®:", font=('å¾®è½¯é›…é»‘',10)).pack(side='left', padx=(20,0))
        ttk.Label(row2, text=f"{max_dev:.3f} MW", font=('å¾®è½¯é›…é»‘',10,'bold')).pack(side='left', padx=5)

        # ç¢³å‡æ’æŒ‡æ ‡
        row3 = ttk.Frame(summary_frame)
        row3.pack(fill='x', pady=2)
        ttk.Label(row3, text="ğŸŒ¿ ç¢³å‡æ’é‡:", font=('å¾®è½¯é›…é»‘',10)).pack(side='left')
        ttk.Label(row3, text=f"{carbon_reduction:.2f} kg COâ‚‚", font=('å¾®è½¯é›…é»‘',12,'bold'), foreground='darkgreen').pack(side='left', padx=5)

        # ç¯ä¿æ¨¡å¼çŠ¶æ€
        if res.get('eco_mode', False):
            ttk.Label(row3, text="(ç¯ä¿æ¨¡å¼å¼€å¯)", font=('å¾®è½¯é›…é»‘',9), foreground='green').pack(side='left', padx=10)

        if pulse_power:
            row4 = ttk.Frame(summary_frame)
            row4.pack(fill='x', pady=2)
            ttk.Label(row4, text="ğŸ¯ è„‰å†²ä¸»å¯¼è®¾å¤‡:", font=('å¾®è½¯é›…é»‘',10)).pack(side='left')
            main_dev = max(pulse_power, key=pulse_power.get)
            ttk.Label(row4, text=f"{main_dev} ({pulse_power[main_dev]:.2f} MW)", font=('å¾®è½¯é›…é»‘',10,'bold'), foreground='purple').pack(side='left', padx=5)

        # æŒ‰é’®æ¡†æ¶ï¼šå¢åŠ éšæœºè§„åˆ’åœºæ™¯å¯è§†åŒ–
        btn_frame = ttk.Frame(main_frame)
        btn_frame.pack(fill='x', pady=5)
        ttk.Button(btn_frame, text="ğŸ“Š æ˜¾ç¤ºè¯¦ç»†ç‰¹æ€§æ›²çº¿", command=lambda: self.plot_all(hess, res), width=25).pack(side='left', padx=5)
        if hess.mpc.stochastic and hess.mpc.last_scenarios is not None:
            ttk.Button(btn_frame, text="ğŸ² æ˜¾ç¤ºéšæœºè§„åˆ’åœºæ™¯", command=lambda: self.plot_scenarios(hess.mpc.last_scenarios), width=20).pack(side='left', padx=5)

        # è¯¦ç»†æ–‡æœ¬åŒºåŸŸ
        text_frame = ttk.Frame(main_frame)
        text_frame.pack(fill='both', expand=True, pady=5)

        text = tk.Text(text_frame, wrap='word', font=('å¾®è½¯é›…é»‘', 10))
        scroll = tk.Scrollbar(text_frame, command=text.yview)
        text.config(yscrollcommand=scroll.set)
        text.pack(side='left', fill='both', expand=True)
        scroll.pack(side='right', fill='y')

        text.insert('end', "="*90 + "\n")
        text.insert('end', "â˜… æ··åˆå‚¨èƒ½ç³»ç»Ÿè„‰å†²å¹³æ»‘ä»¿çœŸè¯¦ç»†æ•°æ® â˜…\n")
        text.insert('end', "="*90 + "\n\n")
        text.insert('end', f"å¾®ç”µç½‘è§„æ¨¡ (ç”µå‚æ’å‘åŠŸç‡): {res['plant'][0]:.2f} MW\n")
        text.insert('end', f"è„‰å†²å¹…å€¼: {amp:.2f} MW\n")
        text.insert('end', f"è„‰å†²æŒç»­æ—¶é—´: {dur:.2f} s\n")
        text.insert('end', f"ç¯ä¿æ¨¡å¼: {'å¼€å¯' if res.get('eco_mode',False) else 'å…³é—­'}\n\n")

        text.insert('end', "ã€éšæœºè§„åˆ’è®¾ç½®ã€‘\n")
        text.insert('end', f"  å¯ç”¨éšæœºè§„åˆ’: {hess.mpc.stochastic}\n")
        if hess.mpc.stochastic:
            text.insert('end', f"  åœºæ™¯æ•°é‡: {hess.mpc.n_scenarios}\n")
            text.insert('end', f"  é¢„æµ‹è¯¯å·®æ ‡å‡†å·®: {hess.mpc.uncertainty_std*100:.1f}%\n")
        text.insert('end', "\n")

        text.insert('end', "ã€å‚¨èƒ½è®¾å¤‡é…ç½®ã€‘æ€»åŠŸç‡20MW / æ€»å®¹é‡480MWh\n")
        for name in selected:
            spec = hess.device_specs[name]['class']
            tmp_dev = spec()
            text.insert('end', f"  {name}: åŠŸç‡ {tmp_dev.power_rating:.1f} MW, å®¹é‡ {tmp_dev.capacity:.1f} MWh, "
                        f"è¾¹é™…æˆæœ¬ {tmp_dev.marginal_cost:.2f} å…ƒ/MW/h\n")
        text.insert('end', "\n")

        text.insert('end', "ã€å¹³æ»‘æ€§èƒ½ã€‘\n")
        text.insert('end', f"  å¹³æ»‘åè´Ÿè·ä¸åŸå§‹è´Ÿè· RMSE: {rmse:.4f} MW\n")
        text.insert('end', f"  æœ€å¤§ç¬æ—¶åå·®: {max_dev:.4f} MW (ç”µç½‘æ‰¿æ‹…)\n")
        text.insert('end', f"  æ€»åå·®èƒ½é‡: {np.sum(np.abs(res['load'] - res['smoothed_load'])) * 0.1 / 3600:.2f} MWh\n\n")

        text.insert('end', "ã€ç»æµæ€§æŒ‡æ ‡ (å…ƒ)ã€‘\n")
        text.insert('end', f"  è´­ç”µæ”¯å‡º: {total_purchase:,.2f}\n")
        text.insert('end', f"  è¿ç»´æˆæœ¬: {total_op:,.2f}\n")
        text.insert('end', f"  è€åŒ–æˆæœ¬: {total_aging:,.2f}\n")
        text.insert('end', f"  ç‡ƒæ–™æˆæœ¬: {total_fuel:,.2f}\n")
        if total_carbon > 0:
            text.insert('end', f"  ç¢³æƒ©ç½šæˆæœ¬: {total_carbon:,.2f}\n")
        text.insert('end', f"  â†’ æ€»æˆæœ¬: {total_cost:,.2f}\n")
        text.insert('end', f"  â†’ å‡€æˆæœ¬: {net_cost:,.2f}\n\n")

        text.insert('end', "ã€ç¯å¢ƒæ•ˆç›Šã€‘\n")
        text.insert('end', f"  ç”µç½‘è´­ç”µå‡å°‘é‡: {grid_reduction:.3f} MWh\n")
        text.insert('end', f"  ç­‰æ•ˆç¢³å‡æ’: {carbon_reduction:.2f} kg COâ‚‚\n\n")

        text.insert('end', "ã€å„è®¾å¤‡æˆæœ¬æ„æˆã€‘\n")
        text.insert('end', f"{'è®¾å¤‡åç§°':<16} {'è¿ç»´æˆæœ¬':<12} {'è€åŒ–æˆæœ¬':<12} {'ç‡ƒæ–™æˆæœ¬':<12} {'æ€»æˆæœ¬':<12}\n")
        text.insert('end', "-"*70 + "\n")
        for dev in hess.devices:
            op_sum = np.sum(res['device_op_cost'][dev.name])
            aging_sum = np.sum(res['device_aging_cost'][dev.name])
            fuel_sum = np.sum(res['device_fuel_cost'][dev.name])
            total_dev = op_sum + aging_sum + fuel_sum
            text.insert('end', f"{dev.name:<16} {op_sum:<12.2f} {aging_sum:<12.2f} {fuel_sum:<12.2f} {total_dev:<12.2f}\n")
        text.insert('end', "\n")

        text.insert('end', "ã€è„‰å†²æœŸé—´åŠŸç‡åˆ†é…ç­–ç•¥ (è¾¹é™…æˆæœ¬ä¼˜å…ˆ + é¢‘æ®µåˆ†é…)ã€‘\n")
        total_pulse_power = sum(pulse_power.values())
        for name, avg in pulse_power.items():
            ratio = avg / total_pulse_power * 100 if total_pulse_power > 0 else 0
            text.insert('end', f"  {name}: {avg:.3f} MW ({ratio:.1f}%)\n")
        text.insert('end', "\n")

        text.insert('end', "ã€å„è®¾å¤‡å……æ”¾ç”µç»Ÿè®¡ã€‘\n")
        text.insert('end', f"{'è®¾å¤‡åç§°':<16} {'å……ç”µé‡(MWh)':<12} {'æ”¾ç”µé‡(MWh)':<12} "
                    f"{'å¹³å‡åŠŸç‡(MW)':<12} {'æœ€å¤§åŠŸç‡(MW)':<12}\n")
        text.insert('end', "-"*70 + "\n")
        for dev in hess.devices:
            text.insert('end', f"{dev.name:<16} {dev_charge[dev.name]:<12.4f} {dev_discharge[dev.name]:<12.4f} "
                        f"{dev_avg_p[dev.name]:<12.4f} {dev_max_p[dev.name]:<12.4f}\n")
        text.insert('end', "\n")

        text.insert('end', "ã€è¯¦ç»†è¾¹ç•Œçº¦æŸã€‘\n")
        text.insert('end', " â€¢ ç”µå‚é¢å®šåŠŸç‡: 13 MW (å®é™…æ’å‘å¯é…ç½®)\n")
        text.insert('end', " â€¢ å‚¨èƒ½ç³»ç»Ÿæ€»åŠŸç‡ä¸Šé™: 20 MW (å·²æ»¡é…)\n")
        text.insert('end', " â€¢ å‚¨èƒ½ç³»ç»Ÿæ€»å®¹é‡: 480 MWh\n")
        text.insert('end', " â€¢ å„è®¾å¤‡SOCå®‰å…¨åŒºé—´: [0.1, 0.9] (è¶Šç•Œè‡ªåŠ¨é™åŠŸç‡ï¼Œç›‘æ§çº¢è‰²é¢„è­¦)\n")
        text.insert('end', " â€¢ åˆå§‹SOCæé«˜è‡³0.8ï¼Œç¡®ä¿è„‰å†²æ”¾ç”µèƒ½åŠ›\n")
        text.insert('end', " â€¢ è„‰å†²å¹…å€¼ä¸Šé™: 20 MWï¼ŒæŒç»­æ—¶é—´ä¸Šé™: 20 s\n")
        text.insert('end', " â€¢ åˆ†æ—¶ç”µä»·(å—äº¬å†¬å­£å·¥å•†ä¸š): ä½è°·0.21ã€å¹³æ®µ0.62ã€é«˜å³°1.12 å…ƒ/kWh\n")
        text.insert('end', " â€¢ å¤©ç„¶æ°”ä»·æ ¼: 3.6 å…ƒ/mÂ³ (å‹ç¼©ç©ºæ°”å‚¨èƒ½)\n")
        text.insert('end', " â€¢ éçº¿æ€§è€åŒ–æˆæœ¬: åŠŸç‡^1.8 + æ”¾ç”µæ·±åº¦å½±å“\n")
        text.insert('end', " â€¢ åŠŸç‡åˆ†é…ç­–ç•¥: è¶…çº§ç”µå®¹/é£è½®ä¼˜å…ˆæ‰¿æ‹…é«˜é¢‘ï¼Œå…¶ä»–è®¾å¤‡æŒ‰è¾¹é™…æˆæœ¬è¡¥å……\n")
        text.insert('end', " â€¢ ç¯ä¿æ¨¡å¼ç¢³ä»·æ ¼: 0.05 å…ƒ/kg COâ‚‚\n")
        text.insert('end', "\n")
        text.insert('end', "ã€ç»“è®ºã€‘è„‰å†²å·²è¢«é«˜åº¦å¹³æ»‘ï¼Œå¹³æ»‘åè´Ÿè·ä¸åŸå§‹è´Ÿè·é«˜åº¦é‡åˆï¼Œç¬¦åˆç»æµè°ƒåº¦åŸåˆ™ï¼Œå¹¶å¸¦æ¥ç¯å¢ƒæ•ˆç›Šã€‚\n")
        text.config(state='disabled')

    def plot_scenarios(self, scenarios):
        """ç»˜åˆ¶éšæœºè§„åˆ’ç”Ÿæˆçš„åœºæ™¯"""
        plt.figure(figsize=(10, 6))
        for i, s in enumerate(scenarios):
            plt.plot(s, 'o-', markersize=3, label=f'åœºæ™¯{i+1}' if i<10 else None)
        plt.xlabel('æ—¶é—´æ­¥')
        plt.ylabel('å‡€è´Ÿè· (MW)')
        plt.title('éšæœºè§„åˆ’ç”Ÿæˆçš„å‡€è´Ÿè·é¢„æµ‹åœºæ™¯')
        plt.legend(loc='upper right', ncol=2, fontsize=8)
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()

    def plot_all(self, hess, res):
        """ç»˜åˆ¶æ‰€æœ‰è¦æ±‚çš„å›¾å½¢ï¼ŒåŠ¨æ€é€‚åº”æ‰€é€‰è®¾å¤‡"""
        try:
            plt.figure(figsize=(18, 16))
            plt.rcParams['font.sans-serif'] = ['SimHei']

            # 1. è„‰å†²å¹³æ»‘æ•ˆæœå¯¹æ¯”
            plt.subplot(4, 4, 1)
            plt.plot(res['time'], res['load'], 'r-', lw=2, label='åŸå§‹è´Ÿè·')
            plt.plot(res['time'], res['smoothed_load'], 'b--', lw=2, label='å¹³æ»‘åè´Ÿè·(ç”µå‚+å‚¨èƒ½)')
            plt.plot(res['time'], res['plant'], 'g-', lw=1.5, label=f'ç”µå‚å‡ºåŠ›({res["plant"][0]:.0f}MW)')
            plt.fill_between(res['time'], res['load'], res['smoothed_load'], alpha=0.25, color='gray')
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('åŠŸç‡ (MW)', fontsize=10)
            plt.title('è„‰å†²å¹³æ»‘æ•ˆæœå¯¹æ¯” (é«˜åº¦é‡åˆ)', fontsize=12)
            plt.legend(fontsize=8)
            plt.grid(True, alpha=0.3)

            # 2. è„‰å†²æœŸé—´åŠŸç‡åˆ†é…é¥¼å›¾
            plt.subplot(4, 4, 2)
            mask = (res['time'] >= 10) & (res['time'] < 10 + res['pulse_dur'])
            pulse_power = {}
            for dev in hess.devices:
                avg = np.mean(np.abs(res['device_power'][dev.name][mask]))
                if avg > 0.05:
                    pulse_power[dev.name] = avg
            if pulse_power:
                labels = list(pulse_power.keys())
                sizes = list(pulse_power.values())
                plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90,
                        textprops={'fontsize': 8})
                plt.title('è„‰å†²æœŸé—´åŠŸç‡åˆ†é…ç­–ç•¥', fontsize=12)
            else:
                plt.text(0.5,0.5,'æ— è„‰å†²æ•°æ®', ha='center', va='center')
                plt.title('è„‰å†²æœŸé—´åŠŸç‡åˆ†é…ç­–ç•¥', fontsize=12)

            # 3. å„è®¾å¤‡ç”µæµéšæ—¶é—´å˜åŒ–
            plt.subplot(4, 4, 3)
            for dev in hess.devices:
                current_smooth = gaussian_filter1d(res['device_current'][dev.name], sigma=4)
                plt.plot(res['time'], current_smooth, label=dev.name, linewidth=1.5)
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('ç”µæµ (A)', fontsize=10)
            plt.title('å„è®¾å¤‡ç”µæµå˜åŒ– (è¶…å¼ºæ»¤æ³¢, æ— è·³å˜)', fontsize=12)
            plt.legend(fontsize=7)
            plt.grid(True, alpha=0.3)

            # 4. å„è®¾å¤‡ç”µå‹éšæ—¶é—´å˜åŒ–
            plt.subplot(4, 4, 4)
            for dev in hess.devices:
                voltage_smooth = gaussian_filter1d(res['device_voltage'][dev.name], sigma=4)
                plt.plot(res['time'], voltage_smooth, label=dev.name, linewidth=1.5)
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('ç”µå‹ (V)', fontsize=10)
            plt.title('å„è®¾å¤‡ç”µå‹å˜åŒ– (è¶…å¼ºæ»¤æ³¢, æ— è·³å˜)', fontsize=12)
            plt.legend(fontsize=7)
            plt.grid(True, alpha=0.3)

            # 5. è¶…çº§ç”µå®¹å™¨èƒ½é‡-ç”µå‹ (å¦‚æœå­˜åœ¨)
            plt.subplot(4, 4, 5)
            sc = next((d for d in hess.devices if 'è¶…çº§ç”µå®¹' in d.name), None)
            if sc:
                energy_kWh = res['device_energy'][sc.name] * 1000
                voltage = res['device_voltage'][sc.name]
                plt.scatter(energy_kWh, voltage, c=res['time'], cmap='viridis', alpha=0.7, s=10)
                plt.xlabel('å‚¨å­˜èƒ½é‡ (kWh)', fontsize=10)
                plt.ylabel('ç”µå‹ (V)', fontsize=10)
                plt.title('è¶…çº§ç”µå®¹å™¨èƒ½é‡-ç”µå‹å…³ç³»', fontsize=12)
                plt.colorbar(label='æ—¶é—´ (ç§’)')
                plt.grid(True, alpha=0.3)
            else:
                plt.text(0.5,0.5,'æœªé€‰æ‹©è¶…çº§ç”µå®¹å™¨', ha='center', va='center')
                plt.title('è¶…çº§ç”µå®¹å™¨èƒ½é‡-ç”µå‹', fontsize=12)

            # 6. é”‚ç”µæ± èƒ½é‡-ç”µæµ (å¦‚æœå­˜åœ¨)
            plt.subplot(4, 4, 6)
            bess = next((d for d in hess.devices if 'é”‚ç”µæ± ' in d.name), None)
            if bess:
                energy_kWh = res['device_energy'][bess.name] * 1000
                current_kA = res['device_current'][bess.name] / 1000
                plt.scatter(energy_kWh, current_kA, c=res['time'], cmap='plasma', alpha=0.7, s=10)
                plt.xlabel('å‚¨å­˜èƒ½é‡ (kWh)', fontsize=10)
                plt.ylabel('ç”µæµ (kA)', fontsize=10)
                plt.title('é”‚ç”µæ± å‚¨èƒ½èƒ½é‡-ç”µæµå…³ç³»', fontsize=12)
                plt.colorbar(label='æ—¶é—´ (ç§’)')
                plt.grid(True, alpha=0.3)
            else:
                plt.text(0.5,0.5,'æœªé€‰æ‹©é”‚ç”µæ± ', ha='center', va='center')
                plt.title('é”‚ç”µæ± èƒ½é‡-ç”µæµ', fontsize=12)

            # 7. é£è½®å‚¨èƒ½èƒ½é‡-ç”µå‹ (å¦‚æœå­˜åœ¨)
            plt.subplot(4, 4, 7)
            fess = next((d for d in hess.devices if 'é£è½®' in d.name), None)
            if fess:
                energy_kWh = res['device_energy'][fess.name] * 1000
                voltage = res['device_voltage'][fess.name]
                plt.scatter(energy_kWh, voltage, c=res['time'], cmap='cool', alpha=0.7, s=10)
                plt.xlabel('å‚¨å­˜èƒ½é‡ (kWh)', fontsize=10)
                plt.ylabel('ç”µå‹ (V)', fontsize=10)
                plt.title('é£è½®å‚¨èƒ½èƒ½é‡-ç”µå‹å…³ç³»', fontsize=12)
                plt.colorbar(label='æ—¶é—´ (ç§’)')
                plt.grid(True, alpha=0.3)
            else:
                plt.text(0.5,0.5,'æœªé€‰æ‹©é£è½®å‚¨èƒ½', ha='center', va='center')
                plt.title('é£è½®èƒ½é‡-ç”µå‹', fontsize=12)

            # 8. è¶…å¯¼ç£å‚¨èƒ½èƒ½é‡-ç”µæµ (å¦‚æœå­˜åœ¨)
            plt.subplot(4, 4, 8)
            smes = next((d for d in hess.devices if 'è¶…å¯¼ç£' in d.name), None)
            if smes:
                energy_kWh = res['device_energy'][smes.name] * 1000
                current = res['device_current'][smes.name]
                plt.scatter(energy_kWh, current, c=res['time'], cmap='magma', alpha=0.7, s=10)
                plt.xlabel('å‚¨å­˜èƒ½é‡ (kWh)', fontsize=10)
                plt.ylabel('ç”µæµ (A)', fontsize=10)
                plt.title('è¶…å¯¼ç£å‚¨èƒ½èƒ½é‡-ç”µæµå…³ç³»', fontsize=12)
                plt.colorbar(label='æ—¶é—´ (ç§’)')
                plt.grid(True, alpha=0.3)
            else:
                plt.text(0.5,0.5,'æœªé€‰æ‹©è¶…å¯¼ç£å‚¨èƒ½', ha='center', va='center')
                plt.title('è¶…å¯¼ç£èƒ½é‡-ç”µæµ', fontsize=12)

            # 9. å‹ç¼©ç©ºæ°”å‚¨èƒ½èƒ½é‡-ç”µå‹ (å¦‚æœå­˜åœ¨)
            plt.subplot(4, 4, 9)
            caes = next((d for d in hess.devices if 'å‹ç¼©ç©ºæ°”' in d.name), None)
            if caes:
                energy_kWh = res['device_energy'][caes.name] * 1000
                voltage = res['device_voltage'][caes.name]
                plt.scatter(energy_kWh, voltage, c=res['time'], cmap='winter', alpha=0.7, s=10)
                plt.xlabel('å‚¨å­˜èƒ½é‡ (kWh)', fontsize=10)
                plt.ylabel('ç”µå‹ (V)', fontsize=10)
                plt.title('å‹ç¼©ç©ºæ°”å‚¨èƒ½èƒ½é‡-ç”µå‹å…³ç³»', fontsize=12)
                plt.colorbar(label='æ—¶é—´ (ç§’)')
                plt.grid(True, alpha=0.3)
            else:
                plt.text(0.5,0.5,'æœªé€‰æ‹©å‹ç¼©ç©ºæ°”', ha='center', va='center')
                plt.title('å‹ç¼©ç©ºæ°”èƒ½é‡-ç”µå‹', fontsize=12)

            # 10. å‚¨èƒ½æ€»åŠŸç‡ä¸ç”µç½‘äº¤äº’
            plt.subplot(4, 4, 10)
            plt.plot(res['time'], res['total_ess'], 'purple', lw=2, label='å‚¨èƒ½æ€»åŠŸç‡')
            plt.plot(res['time'], res['grid_power'], 'orange', lw=1.5, label='ç”µç½‘è´­ç”µåŠŸç‡')
            plt.axhline(0, color='black', ls='--', alpha=0.5)
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('åŠŸç‡ (MW)', fontsize=10)
            plt.title('å‚¨èƒ½æ€»åŠŸç‡ä¸ç”µç½‘è´­ç”µ', fontsize=12)
            plt.legend(fontsize=8)
            plt.grid(True, alpha=0.3)

            # 11. å„è®¾å¤‡SOCå˜åŒ–
            plt.subplot(4, 4, 11)
            for dev in hess.devices:
                plt.plot(res['time'], res['device_soc'][dev.name], label=dev.name, linewidth=1.5)
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('SOC', fontsize=10)
            plt.title('å„è®¾å¤‡è·ç”µçŠ¶æ€', fontsize=12)
            plt.legend(fontsize=7)
            plt.grid(True, alpha=0.3)

            # 12. å®æ—¶å¯å……æ”¾ç”µèƒ½é‡
            plt.subplot(4, 4, 12)
            for dev in hess.devices:
                soc_arr = res['device_soc'][dev.name]
                chargeable = (0.9 - soc_arr) * dev.capacity
                dischargeable = (soc_arr - 0.1) * dev.capacity
                plt.plot(res['time'], chargeable, '--', lw=1, label=f'{dev.name}å¯å……')
                plt.plot(res['time'], dischargeable, '-', lw=1, label=f'{dev.name}å¯æ”¾')
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('èƒ½é‡ (MWh)', fontsize=10)
            plt.title('å®æ—¶å¯å……æ”¾ç”µèƒ½é‡', fontsize=12)
            plt.legend(fontsize=6, loc='upper right')
            plt.grid(True, alpha=0.3)

            # 13. è´­ç”µè´¹ç”¨
            plt.subplot(4, 4, 13)
            plt.plot(res['time'], res['grid_purchase'], 'r-', lw=1.5, label='è´­ç”µæ”¯å‡º')
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('é‡‘é¢ (å…ƒ)', fontsize=10)
            plt.title('ç”µç½‘è´­ç”µè´¹ç”¨', fontsize=12)
            plt.legend(fontsize=8)
            plt.grid(True, alpha=0.3)

            # 14. å‚¨èƒ½å‡ºåŠ›å †å é¢ç§¯å›¾
            plt.subplot(4, 4, 14)
            times = res['time']
            pos_data = []
            neg_data = []
            labels = []
            for dev in hess.devices:
                p = res['device_power'][dev.name]
                pos_data.append(np.maximum(p, 0))
                neg_data.append(np.minimum(p, 0))
                labels.append(dev.name)
            plt.stackplot(times, *pos_data, labels=labels, alpha=0.8, baseline='zero')
            plt.stackplot(times, *neg_data, alpha=0.8, baseline='zero')
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('åŠŸç‡ (MW)', fontsize=10)
            plt.title('å‚¨èƒ½å‡ºåŠ›å †å  (æ­£:æ”¾ç”µ,è´Ÿ:å……ç”µ)', fontsize=12)
            plt.legend(loc='upper right', fontsize=6)
            plt.grid(True, alpha=0.3)

            # 15. å„è®¾å¤‡è¾¹é™…æˆæœ¬å¯¹æ¯”
            plt.subplot(4, 4, 15)
            names = [dev.name for dev in hess.devices]
            costs = [dev.marginal_cost for dev in hess.devices]
            plt.bar(names, costs, color='skyblue')
            plt.xlabel('è®¾å¤‡', fontsize=10)
            plt.ylabel('è¾¹é™…æˆæœ¬ (å…ƒ/MW/h)', fontsize=10)
            plt.title('å„è®¾å¤‡è¾¹é™…æˆæœ¬å¯¹æ¯”', fontsize=12)
            plt.xticks(rotation=15, fontsize=8)

            # 16. è„‰å†²å±€éƒ¨æ”¾å¤§
            plt.subplot(4, 4, 16)
            mask_local = (res['time'] >= 8) & (res['time'] <= 12 + res['pulse_dur'])
            plt.plot(res['time'][mask_local], res['load'][mask_local], 'r-', lw=2, label='åŸå§‹è´Ÿè·')
            plt.plot(res['time'][mask_local], res['smoothed_load'][mask_local], 'b--', lw=2, label='å¹³æ»‘åè´Ÿè·')
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('åŠŸç‡ (MW)', fontsize=10)
            plt.title('è„‰å†²å±€éƒ¨æ”¾å¤§', fontsize=12)
            plt.legend(fontsize=8)
            plt.grid(True, alpha=0.3)

            plt.tight_layout()
            plt.show()
        except Exception as e:
            print(f"ç»˜å›¾è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: {e}")
            messagebox.showerror("ç»˜å›¾é”™è¯¯", f"æ— æ³•æ˜¾ç¤ºå›¾å½¢ï¼Œé”™è¯¯ä¿¡æ¯ï¼š{e}")

# ==================== å…­ã€ä¸»ç¨‹åº ====================
def main():
    if not PYWT_AVAILABLE:
        print("âš ï¸ PyWavelets æœªå®‰è£…ï¼Œå°æ³¢åˆ†è§£ä½¿ç”¨ç§»åŠ¨å¹³å‡è¿‘ä¼¼ã€‚")
    app = HESSGUI()
    app.root.mainloop()

if __name__ == '__main__':
    main()
