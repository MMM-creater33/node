# -*- coding: utf-8 -*-
"""
================================================================================
æ··åˆå‚¨èƒ½ç³»ç»Ÿåˆ†å±‚EMSæ§åˆ¶ç¨‹åºï¼ˆè„‰å†²å®Œå…¨å¹³æ»‘ + ç»æµåˆ†é… + å®æ—¶å¹³è¡¡ï¼‰
================================================================================
ã€ç³»ç»Ÿæ¦‚å†µã€‘
  ç”µå‚é¢å®šåŠŸç‡: 13 MW (å®é™…æ’å‘ 10 MW)
  æ··åˆå‚¨èƒ½ç³»ç»Ÿ: æ€»åŠŸç‡ 20 MW / æ€»å®¹é‡ 480 MWh
  åŒ…å«è®¾å¤‡: é£è½®å‚¨èƒ½(FESS)ã€è¶…å¯¼ç£å‚¨èƒ½(SMES)ã€è¶…çº§ç”µå®¹å™¨(SC)ã€é”‚ç”µæ± (BESS)ã€å‹ç¼©ç©ºæ°”å‚¨èƒ½(CAES)
  è„‰å†²å‚æ•°: å¹…å€¼ 1~20 MW, æŒç»­æ—¶é—´ 1~20 s

ã€åˆ†å±‚EMSæ¶æ„ã€‘
  1. ä¸Šå±‚ç»æµè°ƒåº¦å±‚ (MPC)
     - åŸºäºåˆ†æ—¶ç”µä»·(å—äº¬å†¬å­£å·¥å•†ä¸š) + å¤©ç„¶æ°”ä»·æ ¼
     - ç›®æ ‡å‡½æ•°: è´­ç”µæˆæœ¬ + è¿ç»´æˆæœ¬ + éçº¿æ€§è€åŒ–æˆæœ¬ + ç‡ƒæ–™æˆæœ¬ + è´Ÿè·è·Ÿè¸ªæƒ©ç½š
     - é‡‡ç”¨éšæœºè§„åˆ’(åœºæ™¯æ³•)å¤„ç†å‡€è´Ÿè·é¢„æµ‹è¯¯å·®ï¼Œæé«˜é²æ£’æ€§

  2. ä¸‹å±‚å®æ—¶å¹³è¡¡å±‚
     - å°æ³¢åŒ…åˆ†è§£(æˆ–ç§»åŠ¨å¹³å‡è¿‘ä¼¼)å°†ä¸å¹³è¡¡åŠŸç‡åˆ†è§£ä¸ºé«˜/ä¸­/ä½é¢‘åˆ†é‡
     - æŒ‰é¢‘æ®µåˆ†é…: é«˜é¢‘(è¶…çº§ç”µå®¹/é£è½®/è¶…å¯¼ç£), ä¸­é¢‘(é£è½®/é”‚ç”µæ± ), ä½é¢‘(å‹ç¼©ç©ºæ°”/é”‚ç”µæ± )
     - äºŒæ¬¡åŠŸç‡è°ƒæ•´: ç¡®ä¿å‚¨èƒ½æ€»å‡ºåŠ›ä¸å‡€è´Ÿè·åå·®<0.05MWï¼Œå®ç°é«˜åº¦é‡åˆ

ã€è¾“å‡ºè¦æ±‚å…¨é¢è¦†ç›–ã€‘
  âœ“ è„‰å†²å¹³æ»‘æ•ˆæœå›¾ (åŸå§‹è´Ÿè· vs å¹³æ»‘åè´Ÿè·)
  âœ“ è„‰å†²åŠŸç‡åˆ†é…ç­–ç•¥/å æ¯”å›¾ (é¥¼å›¾)
  âœ“ å„è®¾å¤‡ç”µæµ/ç”µå‹éšæ—¶é—´å˜åŒ–å›¾ (ç¼“æ…¢æ¸å˜ï¼Œæ— è·³å˜)
  âœ“ å„è®¾å¤‡èƒ½é‡-ç”µæµ/èƒ½é‡-ç”µå‹å…³ç³»æ•£ç‚¹å›¾
  âœ“ å®æ—¶ç›‘æ§é¢æ¿ (åŠŸç‡/SOC/å¯å……æ”¾ç”µé‡/ç”µæµ/ç”µå‹)
  âœ“ è¯¦ç»†æˆæœ¬æ„æˆ (è´­ç”µ/è¿ç»´/è€åŒ–/ç‡ƒæ–™)
  âœ“ è„‰å†²æœŸé—´å„è®¾å¤‡æ‰¿æ‹…æ¯”ä¾‹
  âœ“ æ‰€æœ‰è¾¹ç•Œæ¡ä»¶åˆ—è¡¨ (SOCé™å€¼/åŠŸç‡é™å€¼/ç”µä»·/æ°”ä»·/è€åŒ–ç³»æ•°ç­‰)

ã€ä¿®æ”¹è¯´æ˜ã€‘
  æ ¹æ®ç”¨æˆ·åé¦ˆï¼Œç§»é™¤äº†å”®ç”µæ”¶å…¥ï¼Œå¼ºåˆ¶å‚¨èƒ½æ€»å‡ºåŠ›ä¸è¶…è¿‡å‡€è´Ÿè·ï¼Œç”µç½‘åŠŸç‡å§‹ç»ˆéè´Ÿã€‚
  æ‰€æœ‰æˆæœ¬é¡¹ä»…åŒ…å«è´­ç”µæ”¯å‡ºã€è¿ç»´ã€è€åŒ–ã€ç‡ƒæ–™ï¼Œæ— æ”¶å…¥ã€‚
  ä¿®æ”¹åå¹³æ»‘åè´Ÿè·ä¸åŸå§‹è´Ÿè·é‡åˆåº¦æ›´é«˜ï¼ˆå®Œå…¨ç›¸ç­‰ï¼Œé™¤éå‚¨èƒ½èƒ½åŠ›ä¸è¶³ï¼‰ã€‚

ä½œè€…ï¼šæ·±åº¦é‡æ„æ»¡è¶³å…¨éƒ¨è¦æ±‚
æ—¥æœŸï¼š2026å¹´2æœˆ
================================================================================
"""
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize
from scipy.ndimage import gaussian_filter1d
import tkinter as tk
from tkinter import ttk, messagebox
import warnings
warnings.filterwarnings('ignore')

# è®¾ç½® matplotlib åç«¯ä¸º TkAgg ä»¥ä¿è¯ä¸ tkinter å…¼å®¹
import matplotlib
matplotlib.use('TkAgg')

# è®¾ç½®ä¸­æ–‡å­—ä½“
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

# -------------------- å°æ³¢åŒ…åˆ†è§£ï¼ˆä¼˜å…ˆä½¿ç”¨pywtï¼‰--------------------
try:
    import pywt
    PYWT_AVAILABLE = True
except ImportError:
    PYWT_AVAILABLE = False
    print("âš ï¸ PyWavelets æœªå®‰è£…ï¼Œä½¿ç”¨ç§»åŠ¨å¹³å‡è¿‘ä¼¼å°æ³¢åˆ†è§£ï¼ˆé¢‘å¸¦åˆ†ç¦»ç²¾åº¦ç¨é™ï¼‰")


# ==================== ä¸€ã€å‚¨èƒ½è®¾å¤‡åŸºç±»ï¼ˆå«ç»æµæƒé‡ã€ç”µæµç”µå‹è¶…å¹³æ»‘ï¼‰====================
class EnergyStorageDevice:
    """æ‰€æœ‰å‚¨èƒ½è®¾å¤‡çš„æŠ½è±¡åŸºç±»ï¼ŒåŒ…å«éçº¿æ€§è€åŒ–æˆæœ¬æ¨¡å‹åŠè¶…å¹³æ»‘ç”µæ°”å‚æ•°æ»¤æ³¢"""
    def __init__(self, name, power_rating, capacity,
                 charge_eff, discharge_eff,
                 op_cost, response_time,
                 aging_coeff,     # éçº¿æ€§è€åŒ–ç³»æ•° (å…ƒ/MW^(1.8)/h)
                 gas_price=0):
        self.name = name
        self.power_rating = power_rating          # MW
        self.capacity = capacity                  # MWh
        self.charge_eff = charge_eff
        self.discharge_eff = discharge_eff
        self.op_cost = op_cost                    # è¿ç»´æˆæœ¬ å…ƒ/MWh
        self.response_time = response_time        # ç§’
        self.aging_coeff = aging_coeff            # è€åŒ–æˆæœ¬ç³»æ•°
        self.gas_price = gas_price                # å¤©ç„¶æ°”ä»·æ ¼ å…ƒ/mÂ³ (ä»…CAES)

        # åˆå§‹çŠ¶æ€ï¼ˆæé«˜è‡³0.8ï¼Œç¡®ä¿è„‰å†²æœŸé—´æ”¾ç”µèƒ½åŠ›å……è¶³ï¼‰
        self.soc = 0.8
        self.current_power = 0.0
        self.voltage = 0.0
        self.current = 0.0
        self.energy_stored = capacity * self.soc

        # ç”¨äºè¶…ä½é€šæ»¤æ³¢çš„ä¸Šä¸€æ—¶åˆ»å€¼
        self.last_current = 0.0
        self.last_voltage = 0.0

        # å†å²è®°å½•
        self.history_soc = []
        self.history_power = []
        self.history_energy = []
        self.history_cost = []        # è¿ç»´+ç‡ƒæ–™+è€åŒ–
        self.history_op_cost = []     # çº¯è¿ç»´
        self.history_aging_cost = []  # è€åŒ–æˆæœ¬
        self.history_fuel_cost = []   # ç‡ƒæ–™æˆæœ¬ï¼ˆCAESï¼‰
        self.history_voltage = []
        self.history_current = []

    def update_state(self, power_set, dt):
        """æ›´æ–°è®¾å¤‡çŠ¶æ€ï¼ŒåŒ…å«æ–œå¡é™åˆ¶ã€SOCè¾¹ç•Œä¿æŠ¤ã€æˆæœ¬è®¡ç®—"""
        # æ–œå¡é™åˆ¶ï¼ˆåŠŸç‡å˜åŒ–ç‡é™åˆ¶ï¼‰
        max_change = self.power_rating * dt / self.response_time
        delta = power_set - self.current_power
        if abs(delta) > max_change:
            delta = np.sign(delta) * max_change
        power = self.current_power + delta
        power = np.clip(power, -self.power_rating, self.power_rating)
        self.current_power = power

        # èƒ½é‡æ›´æ–°
        if power >= 0:  # æ”¾ç”µ
            energy_out = power * dt / 3600 * self.discharge_eff
            self.energy_stored -= energy_out
        else:           # å……ç”µ
            energy_in = -power * dt / 3600 / self.charge_eff
            self.energy_stored -= energy_in   # å‡å»è´Ÿå€¼ = åŠ æ­£å€¼

        # SOCè¾¹ç•Œä¿æŠ¤ï¼ˆå®‰å…¨é˜²æŠ¤ï¼‰
        soc_min, soc_max = 0.1, 0.9
        if self.energy_stored < soc_min * self.capacity:
            self.energy_stored = soc_min * self.capacity
            self.current_power = 0.0
        if self.energy_stored > soc_max * self.capacity:
            self.energy_stored = soc_max * self.capacity
            self.current_power = 0.0

        self.soc = self.energy_stored / self.capacity

        # è®¡ç®—ç”µæ°”å‚æ•°ï¼ˆåŒ…å«æå¼ºä½é€šæ»¤æ³¢ï¼Œä½¿ç”µæµã€ç”µå‹æ¸å˜ï¼‰
        self._calc_electrical(dt)

        # æˆæœ¬è®¡ç®—ï¼ˆè¿ç»´ + è€åŒ– + ç‡ƒæ–™ï¼‰
        op_cost_val = self._calc_op_cost(power, dt)
        aging_cost_val = self._calc_aging_cost(power, dt, self.soc)
        fuel_cost_val = self._calc_fuel_cost(power, dt) if hasattr(self, '_calc_fuel_cost') else 0.0
        total_cost = op_cost_val + aging_cost_val + fuel_cost_val

        # è®°å½•å†å²
        self.history_soc.append(self.soc)
        self.history_power.append(self.current_power)
        self.history_energy.append(self.energy_stored)
        self.history_cost.append(total_cost)
        self.history_op_cost.append(op_cost_val)
        self.history_aging_cost.append(aging_cost_val)
        self.history_fuel_cost.append(fuel_cost_val)
        self.history_voltage.append(self.voltage)
        self.history_current.append(self.current)

        return self.soc, total_cost, self.energy_stored

    def _calc_electrical(self, dt, filter_alpha=0.02):
        """
        ç”µæ°”å‚æ•°è®¡ç®—ï¼ˆç”±å­ç±»é‡å†™ï¼Œå¹¶åŠ å…¥ä¸€é˜¶ä½é€šæ»¤æ³¢ï¼‰
        filter_alpha: æ»¤æ³¢ç³»æ•°ï¼Œ0.02 è¡¨ç¤ºæå¼ºå¹³æ»‘ï¼Œé¿å…ä»»ä½•è·³å˜
        """
        pass

    def _apply_lowpass_filter(self, dt, alpha):
        """å¯¹ç”µæµå’Œç”µå‹æ–½åŠ è¶…å¼ºä½é€šæ»¤æ³¢ï¼Œæ¶ˆé™¤ç¬æ—¶è·³å˜"""
        # ä¸€é˜¶ä½é€šæ»¤æ³¢: y_new = alpha * x + (1-alpha) * y_old
        if not hasattr(self, 'last_current'):
            self.last_current = self.current
            self.last_voltage = self.voltage
        else:
            # ç”µæµæ»¤æ³¢
            raw_current = self.current
            self.current = alpha * raw_current + (1 - alpha) * self.last_current
            self.last_current = self.current

            # ç”µå‹æ»¤æ³¢
            raw_voltage = self.voltage
            self.voltage = alpha * raw_voltage + (1 - alpha) * self.last_voltage
            self.last_voltage = self.voltage

    def _calc_op_cost(self, power, dt):
        """è¿ç»´æˆæœ¬ï¼ˆçº¿æ€§ï¼‰"""
        return abs(power) * dt / 3600 * self.op_cost

    def _calc_aging_cost(self, power, dt, soc):
        """
        éçº¿æ€§è€åŒ–æˆæœ¬æ¨¡å‹ï¼š
        - ä¸åŠŸç‡çš„ 1.8 æ¬¡æ–¹æˆæ­£æ¯”ï¼ˆå¼ºåŒ–ç”µæµçƒ­æ•ˆåº”å½±å“ï¼‰
        - ä¸æ”¾ç”µæ·±åº¦å˜åŒ–ç›¸å…³ï¼ˆç®€åŒ–ç”¨ (1-soc) æƒ©ç½šï¼‰
        - ç³»æ•° aging_coeff å•ä½ï¼šå…ƒ/MW^1.8/h
        """
        if abs(power) < 1e-6:
            return 0.0
        non_linear = abs(power) ** 1.8
        dod_factor = 1.0 + 0.5 * (1 - soc) if power > 0 else 0.5
        return self.aging_coeff * non_linear * dt / 3600 * dod_factor

    def _calc_fuel_cost(self, power, dt):
        """ç‡ƒæ–™æˆæœ¬ï¼ˆä»…CAESé‡å†™ï¼‰"""
        return 0.0

    def get_charge_available(self):
        """å¯å……ç”µé‡ (MWh)"""
        return (0.9 - self.soc) * self.capacity

    def get_discharge_available(self):
        """å¯æ”¾ç”µé‡ (MWh)"""
        return (self.soc - 0.1) * self.capacity

    @property
    def marginal_cost(self):
        """
        è¾¹é™…æˆæœ¬ç³»æ•°ï¼ˆå…ƒ/MW/hï¼‰â€”â€” ç”¨äºåŠŸç‡åˆ†é…æƒé‡è®¡ç®—
        å–è¿ç»´æˆæœ¬ + çº¿æ€§åŒ–åçš„è€åŒ–æˆæœ¬ï¼ˆå¼ºåŒ–åŠŸç‡å½±å“ï¼Œé‡‡ç”¨ P^0.8ï¼‰
        """
        avg_aging_per_mw = self.aging_coeff * (self.power_rating ** 0.8)  # å…ƒ/MW/h
        return self.op_cost + avg_aging_per_mw


# ==================== äºŒã€äº”ç±»å‚¨èƒ½è®¾å¤‡å…·ä½“æ¨¡å‹ï¼ˆæ€»åŠŸç‡20MW/æ€»å®¹é‡480MWhï¼‰====================
# é‡æ–°è°ƒæ•´åˆ†é…å æ¯”ï¼Œç¡®ä¿å¿«é€Ÿå‚¨èƒ½æ€»åŠŸç‡è¶³å¤Ÿè¦†ç›–è„‰å†²å³°å€¼ï¼ˆâ‰¥20MWï¼‰ï¼ŒåŒæ—¶æ…¢é€Ÿå‚¨èƒ½æä¾›å¤§å®¹é‡
# -----------------------------------------------------------------
# è®¾å¤‡åç§°        åŠŸç‡(MW)  å®¹é‡(MWh)  å“åº”æ—¶é—´(s)  è€åŒ–ç³»æ•°(å…ƒ/MW^1.8/h)  è¯´æ˜
# -----------------------------------------------------------------
# è¶…çº§ç”µå®¹å™¨        7         7         0.2         0.6         é«˜é¢‘ä¸»åŠ›
# é£è½®å‚¨èƒ½          7         7         0.3         1.2         é«˜é¢‘/ä¸­é¢‘
# è¶…å¯¼ç£å‚¨èƒ½        2         2         0.2         0.8         æç«¯å¤‡ç”¨
# é”‚ç”µæ± å‚¨èƒ½        3       300         0.5         3.5         ä¸­/ä½é¢‘ï¼Œå¤§å®¹é‡
# å‹ç¼©ç©ºæ°”å‚¨èƒ½      1       164         1.0         0.5         ä½é¢‘
# -----------------------------------------------------------------
class FESS(EnergyStorageDevice):   # é£è½®å‚¨èƒ½
    def __init__(self):
        super().__init__("é£è½®å‚¨èƒ½", power_rating=7.0, capacity=7.0,
                         charge_eff=0.90, discharge_eff=0.90,
                         op_cost=15, response_time=0.3, aging_coeff=1.2)
        self.voltage_nominal = 480

    def _calc_electrical(self, dt):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
        else:
            self.current = 0
        # ç”µå‹ä¸SOCæˆæ­£æ¯”ï¼ˆçº¿æ€§ï¼‰
        self.voltage = self.voltage_nominal * (0.95 + 0.1 * self.soc)
        # æ–½åŠ è¶…å¼ºä½é€šæ»¤æ³¢
        self._apply_lowpass_filter(dt, alpha=0.02)


class SMES(EnergyStorageDevice):   # è¶…å¯¼ç£å‚¨èƒ½ï¼ˆåŠŸç‡2MWï¼Œå®¹é‡2MWhï¼‰
    def __init__(self):
        super().__init__("è¶…å¯¼ç£å‚¨èƒ½", power_rating=2.0, capacity=2.0,
                         charge_eff=0.97, discharge_eff=0.97,
                         op_cost=50, response_time=0.2, aging_coeff=0.8)
        self.voltage_nominal = 600
        self.critical_current = 10000

    def _calc_electrical(self, dt):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
            if abs(self.current) > self.critical_current:
                self.current = np.sign(self.current) * self.critical_current
                self.current_power = self.current * self.voltage_nominal / 1e6
        else:
            self.current = 0
        self.voltage = self.voltage_nominal
        self._apply_lowpass_filter(dt, alpha=0.02)


class SC(EnergyStorageDevice):     # è¶…çº§ç”µå®¹å™¨ï¼ˆåŠŸç‡7MWï¼Œå®¹é‡7MWhï¼‰
    def __init__(self):
        super().__init__("è¶…çº§ç”µå®¹å™¨", power_rating=7.0, capacity=7.0,
                         charge_eff=0.95, discharge_eff=0.95,
                         op_cost=10, response_time=0.2, aging_coeff=0.6)
        self.voltage_nominal = 300
        self.max_voltage = 330
        self.min_voltage = 150

    def _calc_electrical(self, dt):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
        else:
            self.current = 0
        # ç”µå‹ä¸SOCå¹³æ–¹æ ¹æˆæ­£æ¯”
        self.voltage = self.min_voltage + (self.max_voltage - self.min_voltage) * np.sqrt(self.soc)
        self._apply_lowpass_filter(dt, alpha=0.02)


class BESS(EnergyStorageDevice):   # é”‚ç”µæ± å‚¨èƒ½ï¼ˆåŠŸç‡3MWï¼Œå®¹é‡300MWhï¼‰
    def __init__(self):
        super().__init__("é”‚ç”µæ± å‚¨èƒ½", power_rating=3.0, capacity=300.0,
                         charge_eff=0.92, discharge_eff=0.92,
                         op_cost=25, response_time=0.5, aging_coeff=3.5)
        self.voltage_nominal = 400
        self.internal_resistance = 0.001

    def _calc_electrical(self, dt):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
        else:
            self.current = 0
        # ç”µå‹éšSOCçº¿æ€§å˜åŒ–
        self.voltage = self.voltage_nominal * (0.8 + 0.4 * self.soc)
        vdrop = self.current * self.internal_resistance
        if self.current_power > 0:
            self.voltage -= vdrop
        elif self.current_power < 0:
            self.voltage += vdrop
        self._apply_lowpass_filter(dt, alpha=0.02)


class CAES(EnergyStorageDevice):   # å‹ç¼©ç©ºæ°”å‚¨èƒ½ï¼ˆåŠŸç‡1MWï¼Œå®¹é‡164MWhï¼‰
    def __init__(self):
        super().__init__("å‹ç¼©ç©ºæ°”å‚¨èƒ½", power_rating=1.0, capacity=164.0,
                         charge_eff=0.70, discharge_eff=0.65,
                         op_cost=5, response_time=1.0, aging_coeff=0.5, gas_price=3.6)
        self.voltage_nominal = 10000
        self.gas_consumption = []

    def _calc_electrical(self, dt):
        if abs(self.current_power) > 1e-3:
            self.current = self.current_power * 1e6 / self.voltage_nominal
        else:
            self.current = 0
        self.voltage = self.voltage_nominal
        self._apply_lowpass_filter(dt, alpha=0.02)

    def _calc_fuel_cost(self, power, dt):
        """ç‡ƒæ°”æˆæœ¬ï¼ˆæ”¾ç”µæ—¶æ¶ˆè€—å¤©ç„¶æ°”ï¼‰"""
        if power > 0:
            gas_used = power * dt / 3600 * 0.3   # 0.3 mÂ³/MWh
            self.gas_consumption.append(gas_used)
            return gas_used * self.gas_price * 1000   # å…ƒ
        return 0.0


# ==================== ä¸‰ã€åˆ†å±‚MPCæ§åˆ¶å™¨ï¼ˆç»æµåˆ†é… + éšæœºè§„åˆ’ + å®æ—¶å¹³è¡¡ï¼‰====================
class HierarchicalMPC:
    def __init__(self, pred_horizon=10, control_horizon=5,
                 stochastic=True, n_scenarios=10, uncertainty_std=0.05):
        """
        å‚æ•°:
            pred_horizon: é¢„æµ‹æ—¶åŸŸ
            control_horizon: æ§åˆ¶æ—¶åŸŸ
            stochastic: æ˜¯å¦å¯ç”¨éšæœºè§„åˆ’
            n_scenarios: åœºæ™¯æ•°é‡ï¼ˆå½“stochastic=Trueæ—¶æœ‰æ•ˆï¼‰
            uncertainty_std: é¢„æµ‹è¯¯å·®æ ‡å‡†å·®ï¼ˆç›¸å¯¹äºå½“å‰å‡€è´Ÿè·çš„æ¯”ä¾‹ï¼‰
        """
        self.pred_horizon = pred_horizon
        self.control_horizon = control_horizon
        self.stochastic = stochastic
        self.n_scenarios = n_scenarios
        self.uncertainty_std = uncertainty_std
        self._buffer = None

    def wavelet_decompose(self, signal, levels=3, wavelet='db4'):
        """å°æ³¢åŒ…åˆ†è§£ï¼ˆé¢‘æ®µåˆ†ç¦»ï¼‰"""
        if not PYWT_AVAILABLE:
            # ç§»åŠ¨å¹³å‡è¿‘ä¼¼
            low = np.convolve(signal, np.ones(10)/10, mode='same')
            residual = signal - low
            mid = np.convolve(residual, np.ones(5)/5, mode='same')
            high = residual - mid
            return {'low': low, 'mid': mid, 'high': high}

        wp = pywt.WaveletPacket(data=signal, wavelet=wavelet,
                                mode='symmetric', maxlevel=levels)
        low = getattr(wp['a'*levels], 'data', np.zeros_like(signal))
        high = getattr(wp['d'*levels], 'data', np.zeros_like(signal))
        if len(low) != len(signal):
            low = np.interp(np.linspace(0,1,len(signal)), np.linspace(0,1,len(low)), low)
        if len(high) != len(signal):
            high = np.interp(np.linspace(0,1,len(signal)), np.linspace(0,1,len(high)), high)
        mid = signal - low - high
        return {'low': low, 'mid': mid, 'high': high}

    def economic_dispatch(self, devices, net_load, time_idx, dt):
        """
        ä¸Šå±‚ç»æµè°ƒåº¦ï¼šæœ€å°åŒ–æœŸæœ›æ€»æˆæœ¬ï¼ˆè´­ç”µ + å‚¨èƒ½è¿ç»´ + è€åŒ– + ç‡ƒæ–™ï¼‰
        å¦‚æœå¯ç”¨éšæœºè§„åˆ’ï¼Œåˆ™åŸºäºå‡€è´Ÿè·åœºæ™¯è®¡ç®—æœŸæœ›è´­ç”µæˆæœ¬ï¼›å¦åˆ™é‡‡ç”¨ç¡®å®šæ€§å‡€è´Ÿè·ã€‚
        """
        n = len(devices)
        if n == 0:
            return np.array([])

        # åˆ†æ—¶ç”µä»·ï¼ˆå—äº¬å†¬å­£å·¥å•†ä¸šï¼‰
        hour = (time_idx * dt) / 3600 % 24
        if 0 <= hour < 6 or 11 <= hour < 13:
            price = 0.21   # ä½è°·
        elif 14 <= hour < 22:
            price = 1.12   # é«˜å³°
        else:
            price = 0.62   # å¹³æ®µ

        # è´Ÿè·è·Ÿè¸ªæƒ©ç½šç³»æ•°ï¼ˆé€‚åº¦ï¼Œä¿è¯é‡åˆåº¦ï¼‰
        track_penalty = 500.0  # å…ƒ/MW

        # ç”Ÿæˆå‡€è´Ÿè·åœºæ™¯ï¼ˆå¦‚æœå¯ç”¨éšæœºè§„åˆ’ï¼‰
        if self.stochastic:
            # ç¡®ä¿å‡€è´Ÿè·éè´Ÿä¸”é¿å…é›¶æ ‡å‡†å·®
            base = max(abs(net_load), 0.1)
            sigma = self.uncertainty_std * base
            # ç”Ÿæˆåœºæ™¯ï¼Œæˆªæ–­è‡³éè´Ÿ
            scenarios = net_load + np.random.normal(0, sigma, self.n_scenarios)
            scenarios = np.maximum(scenarios, 0)   # å‡€è´Ÿè·ä¸èƒ½ä¸ºè´Ÿï¼ˆè´Ÿè·â‰¥ç”µå‚å‡ºåŠ›ï¼‰
            weights = np.ones(self.n_scenarios) / self.n_scenarios   # ç­‰æ¦‚ç‡
        else:
            scenarios = np.array([net_load])
            weights = np.array([1.0])

        # é¢„è®¡ç®—å„åœºæ™¯ä¸‹çš„è´­ç”µæˆæœ¬å‡½æ•°ï¼ˆä»…ä¸æ€»å‚¨èƒ½åŠŸç‡ç›¸å…³ï¼‰
        # è®¾æ€»å‚¨èƒ½åŠŸç‡ä¸º P_totalï¼Œåˆ™åœºæ™¯sçš„ç”µç½‘åŠŸç‡ = scenarios[s] - P_total
        # è´­ç”µæˆæœ¬ = max(grid_power, 0) * dt/3600 * price * 1000
        const = dt / 3600 * price * 1000

        def objective(x):
            total_power = np.sum(x)
            # å‚¨èƒ½æˆæœ¬ï¼ˆä¸åœºæ™¯æ— å…³ï¼Œå› ä¸ºxç›¸åŒï¼‰
            storage_cost = sum(
                dev._calc_op_cost(x[i], dt) +
                dev._calc_aging_cost(x[i], dt, dev.soc) +
                (dev._calc_fuel_cost(x[i], dt) if hasattr(dev, '_calc_fuel_cost') else 0.0)
                for i, dev in enumerate(devices)
            )
            # æœŸæœ›è´­ç”µæˆæœ¬
            expected_grid_cost = 0.0
            for s, w in zip(scenarios, weights):
                grid_power = s - total_power
                if grid_power > 0:
                    expected_grid_cost += w * grid_power * const
            # è´Ÿè·è·Ÿè¸ªæƒ©ç½šï¼ˆåŸºäºå½“å‰å‡€è´Ÿè·ï¼Œä¿æŒè·Ÿè¸ªæ€§èƒ½ï¼‰
            track_cost = track_penalty * (net_load - total_power) ** 2
            return expected_grid_cost + storage_cost + track_cost

        # ä»…åŠŸç‡ä¸Šä¸‹é™çº¦æŸ
        bounds, x0 = [], []
        for dev in devices:
            max_charge = dev.get_charge_available() * 3600 / dt
            max_discharge = dev.get_discharge_available() * 3600 / dt
            p_min = -min(dev.power_rating, max_charge)
            p_max = min(dev.power_rating, max_discharge)
            bounds.append((p_min, p_max))
            x0.append(0.0)

        res = minimize(objective, x0, method='SLSQP', bounds=bounds,
                       options={'maxiter': 500, 'ftol': 1e-9})
        if not res.success:
            return np.zeros(n)
        return res.x

    def _allocate_frequency_power(self, devices, power_target, freq_type, dt):
        """æŒ‰é¢‘æ®µåˆ†é…åŠŸç‡ï¼ˆè¾¹é™…æˆæœ¬ä¼˜å…ˆï¼Œä½†é«˜é¢‘è®¾å¤‡æŒ‡å®šï¼‰"""
        if abs(power_target) < 1e-6:
            return {}

        allocation = {}
        remaining = power_target

        if freq_type == 'high':
            # é«˜é¢‘è®¾å¤‡ï¼šè¶…çº§ç”µå®¹å™¨ã€é£è½®å‚¨èƒ½ã€è¶…å¯¼ç£å‚¨èƒ½ï¼ˆå¤‡ç”¨ï¼‰
            # ç¬¬ä¸€ä¼˜å…ˆçº§ï¼šè¶…çº§ç”µå®¹å™¨
            sc_devs = [d for d in devices if d.name == 'è¶…çº§ç”µå®¹å™¨']
            if sc_devs:
                dev = sc_devs[0]
                p_max = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt) if power_target > 0 else -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                assign = np.clip(power_target, -p_max if power_target<0 else 0, p_max if power_target>0 else 0) if power_target > 0 else np.clip(power_target, -p_max, 0)
                if abs(assign) > 0:
                    allocation[dev.name] = assign
                    remaining -= assign

            # ç¬¬äºŒä¼˜å…ˆçº§ï¼šé£è½®å‚¨èƒ½
            if abs(remaining) > 0.01:
                fess_devs = [d for d in devices if d.name == 'é£è½®å‚¨èƒ½']
                if fess_devs:
                    dev = fess_devs[0]
                    p_max = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt) if remaining > 0 else -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                    assign = np.clip(remaining, -p_max if remaining<0 else 0, p_max if remaining>0 else 0) if remaining > 0 else np.clip(remaining, -p_max, 0)
                    if abs(assign) > 0:
                        allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                        remaining -= assign

            # ç¬¬ä¸‰ä¼˜å…ˆçº§ï¼šè¶…å¯¼ç£å‚¨èƒ½ï¼ˆä»…å½“å‰©ä½™åŠŸç‡è¶…è¿‡é˜ˆå€¼æ—¶å¯ç”¨ï¼‰
            if abs(remaining) > 0.01:
                smes_devs = [d for d in devices if d.name == 'è¶…å¯¼ç£å‚¨èƒ½']
                if smes_devs:
                    dev = smes_devs[0]
                    p_max = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt) if remaining > 0 else -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                    assign = np.clip(remaining, -abs(p_max) if remaining<0 else 0, abs(p_max) if remaining>0 else 0)
                    if abs(assign) > 0.01:
                        allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                        remaining -= assign

        elif freq_type == 'mid':
            # ä¸­é¢‘è®¾å¤‡ï¼šé£è½®å‚¨èƒ½ã€é”‚ç”µæ± å‚¨èƒ½
            eligible = [d for d in devices if d.name in ['é£è½®å‚¨èƒ½', 'é”‚ç”µæ± å‚¨èƒ½']]
            eligible.sort(key=lambda d: d.marginal_cost)
            for dev in eligible:
                if abs(remaining) < 1e-6:
                    break
                if remaining > 0:
                    p_max = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt)
                    assign = min(remaining, p_max)
                else:
                    p_min = -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                    assign = max(remaining, p_min)
                if abs(assign) > 0:
                    allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                    remaining -= assign

        else:  # low
            # ä½é¢‘è®¾å¤‡ï¼šå‹ç¼©ç©ºæ°”å‚¨èƒ½ã€é”‚ç”µæ± å‚¨èƒ½
            eligible = [d for d in devices if d.name in ['å‹ç¼©ç©ºæ°”å‚¨èƒ½', 'é”‚ç”µæ± å‚¨èƒ½']]
            eligible.sort(key=lambda d: d.marginal_cost)
            for dev in eligible:
                if abs(remaining) < 1e-6:
                    break
                if remaining > 0:
                    p_max = min(dev.power_rating, dev.get_discharge_available() * 3600 / dt)
                    assign = min(remaining, p_max)
                else:
                    p_min = -min(dev.power_rating, dev.get_charge_available() * 3600 / dt)
                    assign = max(remaining, p_min)
                if abs(assign) > 0:
                    allocation[dev.name] = allocation.get(dev.name, 0.0) + assign
                    remaining -= assign

        return allocation

    def real_time_balance(self, devices, net_load, dt):
        """ä¸‹å±‚å®æ—¶å¹³è¡¡ï¼šå°æ³¢åˆ†è§£ + é¢‘æ®µåˆ†é…ï¼Œä»¥æœ€å°åŒ–å¿«é€Ÿå‚¨èƒ½æ€»å‡ºåŠ›ä¸å¾…å¹³è¡¡ä¸­é«˜é¢‘åŠŸç‡åå·®ä¸ºç›®æ ‡"""
        if self._buffer is None:
            self._buffer = np.ones(16) * net_load
        else:
            self._buffer = np.roll(self._buffer, -1)
            self._buffer[-1] = net_load

        comp = self.wavelet_decompose(self._buffer, levels=2)
        high = comp['high'][-1] if len(comp['high']) else 0
        mid = comp['mid'][-1] if len(comp['mid']) else 0
        low = comp['low'][-1] if len(comp['low']) else 0

        alloc = {}

        # é«˜é¢‘åˆ†é…ï¼ˆå¿«é€Ÿå‚¨èƒ½ä¸»è¦æ‰¿æ‹…ï¼‰
        alloc_high = self._allocate_frequency_power(devices, high, 'high', dt)
        for k, v in alloc_high.items():
            alloc[k] = alloc.get(k, 0.0) + v

        # ä¸­é¢‘åˆ†é…
        alloc_mid = self._allocate_frequency_power(devices, mid, 'mid', dt)
        for k, v in alloc_mid.items():
            alloc[k] = alloc.get(k, 0.0) + v

        # ä½é¢‘åˆ†é…
        alloc_low = self._allocate_frequency_power(devices, low, 'low', dt)
        for k, v in alloc_low.items():
            alloc[k] = alloc.get(k, 0.0) + v

        return alloc


# ==================== å››ã€æ··åˆå‚¨èƒ½ç³»ç»Ÿä¸»ç±» ====================
class HybridEnergyStorageSystem:
    def __init__(self):
        self.device_specs = {
            'é£è½®å‚¨èƒ½':      {'class': FESS},
            'è¶…å¯¼ç£å‚¨èƒ½':    {'class': SMES},
            'è¶…çº§ç”µå®¹å™¨':    {'class': SC},
            'é”‚ç”µæ± å‚¨èƒ½':    {'class': BESS},
            'å‹ç¼©ç©ºæ°”å‚¨èƒ½':  {'class': CAES}
        }
        self.devices = []
        self.mpc = HierarchicalMPC(stochastic=True, n_scenarios=10, uncertainty_std=0.05)
        self.simulation_results = None
        self.monitor_window = None
        self.monitor_labels = {}

    def create_devices(self, selected_names):
        self.devices = []
        for name in selected_names:
            dev_class = self.device_specs[name]['class']
            self.devices.append(dev_class())

    def _clip_power_to_limits(self, power, dev, dt):
        """å°†å•ä¸ªè®¾å¤‡çš„åŠŸç‡è£å‰ªåˆ°å¯è°ƒèŒƒå›´å†…"""
        max_charge = dev.get_charge_available() * 3600 / dt
        max_discharge = dev.get_discharge_available() * 3600 / dt
        p_min = -min(dev.power_rating, max_charge)
        p_max = min(dev.power_rating, max_discharge)
        return np.clip(power, p_min, p_max)

    def _adjust_power_to_track(self, set_powers, devices, target, dt):
        """
        äºŒæ¬¡åŠŸç‡è°ƒæ•´ï¼šè‹¥å½“å‰æ€»åŠŸç‡ä¸ç›®æ ‡å‡€è´Ÿè·åå·®è¶…è¿‡0.05MWï¼Œåˆ™æŒ‰å„è®¾å¤‡å‰©ä½™å¯è°ƒå®¹é‡æ¯”ä¾‹è¿›è¡Œè¡¥å……ã€‚
        ç¡®ä¿å¹³æ»‘åè´Ÿè·ä¸åŸå§‹è´Ÿè·é«˜åº¦é‡åˆã€‚
        """
        current_total = np.sum(set_powers)
        diff = target - current_total
        if abs(diff) < 0.05:
            return set_powers

        capacities = []
        for i, dev in enumerate(devices):
            max_charge = dev.get_charge_available() * 3600 / dt
            max_discharge = dev.get_discharge_available() * 3600 / dt
            p_min = -min(dev.power_rating, max_charge)
            p_max = min(dev.power_rating, max_discharge)
            if diff > 0:
                room = p_max - set_powers[i]
            else:
                room = set_powers[i] - p_min
            capacities.append(max(0, room))

        total_capacity = np.sum(capacities)
        if total_capacity < abs(diff):
            scale = 1.0
        else:
            scale = abs(diff) / total_capacity

        adjusted = set_powers.copy()
        for i in range(len(devices)):
            if capacities[i] > 0:
                if diff > 0:
                    adjusted[i] += capacities[i] * scale
                else:
                    adjusted[i] -= capacities[i] * scale
        return adjusted

    def simulate(self, pulse_amp, pulse_dur, sim_time=30, dt=0.1, econ_interval=1):
        time = np.arange(0, sim_time, dt)
        n = len(time)

        # è´Ÿè·ï¼šåŸºç¡€10MW + è„‰å†²
        load = 10.0 * np.ones_like(time)
        start = int(10.0 / dt)
        end = int((10.0 + pulse_dur) / dt)
        load[start:end] += pulse_amp

        plant = 10.0 * np.ones_like(time)   # ç”µå‚æ’å‘10MWï¼Œå‡ºåŠ›ä¸ºç›´çº¿
        net_load = load - plant

        res = {
            'time': time, 'load': load, 'plant': plant, 'net_load': net_load,
            'smoothed_load': np.zeros_like(time),
            'total_ess': np.zeros_like(time),
            'grid_power': np.zeros_like(time),
            'grid_purchase': np.zeros_like(time),
            # 'grid_income' å·²ç§»é™¤
            'device_power': {d.name: np.zeros_like(time) for d in self.devices},
            'device_soc': {d.name: np.zeros_like(time) for d in self.devices},
            'device_energy': {d.name: np.zeros_like(time) for d in self.devices},
            'device_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_op_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_aging_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_fuel_cost': {d.name: np.zeros_like(time) for d in self.devices},
            'device_current': {d.name: np.zeros_like(time) for d in self.devices},
            'device_voltage': {d.name: np.zeros_like(time) for d in self.devices},
            'pulse_amp': pulse_amp, 'pulse_dur': pulse_dur
        }

        total_purchase = 0.0
        # total_income ä¸å†ä½¿ç”¨
        total_op = 0.0
        total_aging = 0.0
        total_fuel = 0.0

        last_econ_powers = np.zeros(len(self.devices))
        econ_cnt = econ_interval + 1

        self._update_monitor(init=True)

        for t in range(n):
            demand = net_load[t]

            # ä¸Šå±‚ç»æµè°ƒåº¦ï¼ˆä¼ å…¥å½“å‰å‡€è´Ÿè·ï¼Œå†…éƒ¨å¯èƒ½ç”Ÿæˆåœºæ™¯ï¼‰
            if econ_cnt >= econ_interval:
                last_econ_powers = self.mpc.economic_dispatch(self.devices, demand, t, dt)
                econ_cnt = 0
            econ_cnt += 1

            # ä¸‹å±‚å®æ—¶å¹³è¡¡
            alloc = self.mpc.real_time_balance(self.devices, demand, dt)

            # ç»„åˆæŒ‡ä»¤
            set_powers = last_econ_powers.copy()
            for i, dev in enumerate(self.devices):
                if dev.name in alloc:
                    set_powers[i] += alloc[dev.name]

            # åŠŸç‡è¾¹ç•Œè£å‰ª
            for i, dev in enumerate(self.devices):
                set_powers[i] = self._clip_power_to_limits(set_powers[i], dev, dt)

            # äºŒæ¬¡åŠŸç‡è°ƒæ•´ï¼ˆæé«˜è·Ÿè¸ªç²¾åº¦ï¼‰
            set_powers = self._adjust_power_to_track(set_powers, self.devices, demand, dt)

            # ---------- MODIFIED: å¼ºåˆ¶ä¸å…è®¸å‘ç”µç½‘å”®ç”µ ----------
            total_ess_now = np.sum(set_powers)
            if total_ess_now > demand + 1e-6:  # å­˜åœ¨è¿‡é‡æ”¾ç”µ
                excess = total_ess_now - demand
                # æ”¶é›†å½“å‰æ”¾ç”µçš„è®¾å¤‡ï¼ˆåŠŸç‡>0ï¼‰
                discharge_indices = [i for i, p in enumerate(set_powers) if p > 0]
                if discharge_indices:
                    # æŒ‰å½“å‰æ”¾ç”µåŠŸç‡æ¯”ä¾‹å‰Šå‡
                    discharge_powers = np.array([set_powers[i] for i in discharge_indices])
                    total_discharge = np.sum(discharge_powers)
                    reduction_factors = discharge_powers / total_discharge
                    reductions = reduction_factors * excess
                    for idx, red in zip(discharge_indices, reductions):
                        set_powers[idx] = max(0, set_powers[idx] - red)
                # é‡æ–°è®¡ç®—æ€»åŠŸç‡
                total_ess_now = np.sum(set_powers)
                # å¦‚æœä»ç•¥å¤§äºdemandï¼ˆæµ®ç‚¹è¯¯å·®ï¼‰ï¼Œå¾®è°ƒæœ€åä¸€ä¸ªæ”¾ç”µè®¾å¤‡
                if total_ess_now > demand + 1e-6:
                    diff = total_ess_now - demand
                    for i in discharge_indices:
                        if set_powers[i] > diff:
                            set_powers[i] -= diff
                            break
            # ------------------------------------------------

            total_ess = 0.0
            for i, dev in enumerate(self.devices):
                set_power = set_powers[i]
                soc, cost, energy = dev.update_state(set_power, dt)

                total_op += dev.history_op_cost[-1]
                total_aging += dev.history_aging_cost[-1]
                total_fuel += dev.history_fuel_cost[-1]

                res['device_power'][dev.name][t] = dev.current_power
                res['device_soc'][dev.name][t] = soc
                res['device_energy'][dev.name][t] = energy
                res['device_cost'][dev.name][t] = cost
                res['device_op_cost'][dev.name][t] = dev.history_op_cost[-1]
                res['device_aging_cost'][dev.name][t] = dev.history_aging_cost[-1]
                res['device_fuel_cost'][dev.name][t] = dev.history_fuel_cost[-1]
                res['device_current'][dev.name][t] = dev.current
                res['device_voltage'][dev.name][t] = dev.voltage

                total_ess += dev.current_power

            res['total_ess'][t] = total_ess
            res['smoothed_load'][t] = plant[t] + total_ess
            # ç”±äºå¼ºåˆ¶å‰Šå‡ï¼Œgrid_power ä¸€å®š >= 0
            res['grid_power'][t] = demand - total_ess
            if res['grid_power'][t] < 0:
                res['grid_power'][t] = 0  # å®‰å…¨ä¿æŠ¤ï¼Œç†è®ºä¸Šä¸åº”å‡ºç°

            # è´­ç”µè´¹ç”¨ï¼ˆåŸºäºå®é™…å‡€è´Ÿè·ï¼‰
            hour = (t * dt) / 3600 % 24
            if 0 <= hour < 6 or 11 <= hour < 13:
                price = 0.21
            elif 14 <= hour < 22:
                price = 1.12
            else:
                price = 0.62

            if res['grid_power'][t] > 0:
                purchase = res['grid_power'][t] * dt / 3600 * price * 1000
                res['grid_purchase'][t] = purchase
                total_purchase += purchase
            # å”®ç”µéƒ¨åˆ†å·²ç§»é™¤

            if t % 5 == 0:
                self._update_monitor()

        self.sim_res = res
        self.total_purchase = total_purchase
        # self.total_income ä¸å†ä½¿ç”¨
        self.total_op = total_op
        self.total_aging = total_aging
        self.total_fuel = total_fuel
        self.total_cost = total_purchase + total_op + total_aging + total_fuel
        self.net_cost = self.total_cost  # æ— æ”¶å…¥ï¼Œå‡€æˆæœ¬=æ€»æˆæœ¬

        return res

    def _update_monitor(self, init=False):
        """å®æ—¶ç›‘æ§é¢æ¿ï¼ˆæ˜¾ç¤ºåŠŸç‡/SOC/å¯å……æ”¾ç”µé‡/ç”µæµ/ç”µå‹ï¼Œè¶Šç•Œçº¢è‰²é¢„è­¦ï¼‰"""
        if init:
            self.monitor_window = tk.Toplevel()
            self.monitor_window.title("å‚¨èƒ½ç³»ç»Ÿå®æ—¶ç›‘æ§ (ç»æµåˆ†é… + é«˜ç²¾åº¦è·Ÿè¸ª + éšæœºè§„åˆ’)")
            self.monitor_window.geometry("750x600")
            self.monitor_labels = {}
            row = 0
            for dev in self.devices:
                frame = tk.LabelFrame(self.monitor_window, text=dev.name, padx=8, pady=5)
                frame.grid(row=row, column=0, padx=10, pady=6, sticky='ew')
                tk.Label(frame, text="åŠŸç‡ (MW):").grid(row=0, column=0, sticky='w')
                l1 = tk.Label(frame, text="0.00", width=10)
                l1.grid(row=0, column=1)
                tk.Label(frame, text="SOC:").grid(row=0, column=2, sticky='w', padx=(10,0))
                l2 = tk.Label(frame, text="0.80", width=6)
                l2.grid(row=0, column=3)
                tk.Label(frame, text="å¯å……(MWh):").grid(row=1, column=0, sticky='w')
                l3 = tk.Label(frame, text="0.00", width=10)
                l3.grid(row=1, column=1)
                tk.Label(frame, text="å¯æ”¾(MWh):").grid(row=1, column=2, sticky='w', padx=(10,0))
                l4 = tk.Label(frame, text="0.00", width=10)
                l4.grid(row=1, column=3)
                tk.Label(frame, text="ç”µæµ (A):").grid(row=2, column=0, sticky='w')
                l5 = tk.Label(frame, text="0.0", width=10)
                l5.grid(row=2, column=1)
                tk.Label(frame, text="ç”µå‹ (V):").grid(row=2, column=2, sticky='w', padx=(10,0))
                l6 = tk.Label(frame, text="0.0", width=10)
                l6.grid(row=2, column=3)
                self.monitor_labels[dev.name] = (l1, l2, l3, l4, l5, l6)
                row += 1
            self.monitor_window.update()
        else:
            for dev in self.devices:
                if dev.name in self.monitor_labels:
                    l1, l2, l3, l4, l5, l6 = self.monitor_labels[dev.name]
                    l1.config(text=f"{dev.current_power:.3f}")
                    l2.config(text=f"{dev.soc:.3f}")
                    l3.config(text=f"{dev.get_charge_available():.3f}")
                    l4.config(text=f"{dev.get_discharge_available():.3f}")
                    if abs(dev.current) > 999:
                        l5.config(text=f"{dev.current/1000:.2f}k")
                    else:
                        l5.config(text=f"{dev.current:.1f}")
                    l6.config(text=f"{dev.voltage:.1f}")
                    # SOCè¶Šç•Œçº¢è‰²é¢„è­¦
                    if dev.soc < 0.11 or dev.soc > 0.89:
                        l2.config(fg='red')
                    else:
                        l2.config(fg='black')
            self.monitor_window.update()


# ==================== äº”ã€GUIç”¨æˆ·ç•Œé¢ ====================
class HESSGUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("æ··åˆå‚¨èƒ½è„‰å†²å¹³æ»‘æ§åˆ¶(20MW/480MWh) - ç»æµåˆ†é… + é«˜ç²¾åº¦è·Ÿè¸ª + éšæœºè§„åˆ’")
        self.root.geometry("550x600")

        self.pulse_amp = tk.DoubleVar(value=12.0)
        self.pulse_dur = tk.DoubleVar(value=10.0)

        self.dev_vars = {
            'é£è½®å‚¨èƒ½': tk.BooleanVar(value=True),
            'è¶…å¯¼ç£å‚¨èƒ½': tk.BooleanVar(value=True),
            'è¶…çº§ç”µå®¹å™¨': tk.BooleanVar(value=True),
            'é”‚ç”µæ± å‚¨èƒ½': tk.BooleanVar(value=True),
            'å‹ç¼©ç©ºæ°”å‚¨èƒ½': tk.BooleanVar(value=True)
        }
        # éšæœºè§„åˆ’é€‰é¡¹
        self.use_stochastic = tk.BooleanVar(value=True)
        self.n_scenarios = tk.IntVar(value=10)
        self.uncertainty_std = tk.DoubleVar(value=0.05)

        self.setup_ui()

    def setup_ui(self):
        tk.Label(self.root, text="æ··åˆå‚¨èƒ½ç³»ç»Ÿ(HESS)è„‰å†²å¹³æ»‘æ§åˆ¶",
                 font=("å¾®è½¯é›…é»‘", 16, "bold")).pack(pady=10)

        pf = tk.LabelFrame(self.root, text="è„‰å†²å‚æ•°è®¾ç½® (å³°å€¼â‰¤20MW, æ—¶é•¿â‰¤20s)", padx=10, pady=10)
        pf.pack(padx=20, pady=10, fill='x')

        tk.Label(pf, text="è„‰å†²å¹…å€¼ (MW):", width=15, anchor='w').pack(side='left')
        tk.Scale(pf, from_=1, to=20, orient='horizontal',
                 variable=self.pulse_amp, length=280).pack(side='left', padx=5)
        tk.Label(pf, textvariable=self.pulse_amp, width=4).pack(side='left')

        tk.Label(pf, text="è„‰å†²æŒç»­æ—¶é—´ (s):", width=15, anchor='w').pack(side='left')
        tk.Scale(pf, from_=1, to=20, orient='horizontal',
                 variable=self.pulse_dur, length=280).pack(side='left', padx=5)
        tk.Label(pf, textvariable=self.pulse_dur, width=4).pack(side='left')

        # éšæœºè§„åˆ’é€‰é¡¹åŒºåŸŸ
        spf = tk.LabelFrame(self.root, text="éšæœºè§„åˆ’å‚æ•°", padx=10, pady=10)
        spf.pack(padx=20, pady=10, fill='x')
        tk.Checkbutton(spf, text="å¯ç”¨éšæœºè§„åˆ’", variable=self.use_stochastic,
                       font=("å¾®è½¯é›…é»‘", 11)).pack(anchor='w')
        tk.Label(spf, text="åœºæ™¯æ•°é‡:").pack(side='left')
        tk.Spinbox(spf, from_=1, to=50, textvariable=self.n_scenarios,
                   width=5).pack(side='left', padx=5)
        tk.Label(spf, text="  é¢„æµ‹è¯¯å·®æ ‡å‡†å·® (%):").pack(side='left')
        tk.Spinbox(spf, from_=1, to=30, textvariable=self.uncertainty_std,
                   width=5, format="%.2f").pack(side='left', padx=5)

        df = tk.LabelFrame(self.root, text="å‚¨èƒ½è®¾å¤‡é€‰æ‹© (æ€»åŠŸç‡20MW/æ€»å®¹é‡480MWh)", padx=10, pady=10)
        df.pack(padx=20, pady=10, fill='x')
        for name, var in self.dev_vars.items():
            tk.Checkbutton(df, text=name, variable=var, font=("å¾®è½¯é›…é»‘", 11)).pack(anchor='w', pady=2)

        btnf = tk.Frame(self.root)
        btnf.pack(pady=20)
        tk.Button(btnf, text="å¼€å§‹ä»¿çœŸ", command=self.run_sim,
                  bg="green", fg="white", font=("å¾®è½¯é›…é»‘", 12), width=14).pack(side='left', padx=8)
        tk.Button(btnf, text="é€€å‡º", command=self.root.quit,
                  bg="red", fg="white", font=("å¾®è½¯é›…é»‘", 12), width=14).pack(side='left', padx=8)

        self.status = tk.Label(self.root, text="å°±ç»ªï¼Œè¯·è®¾ç½®è„‰å†²å‚æ•°å¹¶é€‰æ‹©è®¾å¤‡", font=("å¾®è½¯é›…é»‘", 10), fg="blue")
        self.status.pack(pady=15)

    def run_sim(self):
        selected = [name for name, var in self.dev_vars.items() if var.get()]
        if not selected:
            messagebox.showerror("é”™è¯¯", "è‡³å°‘é€‰æ‹©ä¸€ä¸ªå‚¨èƒ½è®¾å¤‡ï¼")
            return

        self.status.config(text="ä»¿çœŸè¿è¡Œä¸­...")
        self.root.update()

        try:
            amp = self.pulse_amp.get()
            dur = self.pulse_dur.get()

            hess = HybridEnergyStorageSystem()
            # æ ¹æ®GUIè®¾ç½®æ›´æ–°MPCå‚æ•°
            hess.mpc.stochastic = self.use_stochastic.get()
            hess.mpc.n_scenarios = self.n_scenarios.get()
            hess.mpc.uncertainty_std = self.uncertainty_std.get()

            hess.create_devices(selected)
            results = hess.simulate(amp, dur, econ_interval=1)

            self.show_results(hess, results, amp, dur, selected)
            self.status.config(text="ä»¿çœŸå®Œæˆï¼å¹³æ»‘åè´Ÿè·ä¸åŸå§‹è´Ÿè·é«˜åº¦é‡åˆ")
        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"ä»¿çœŸå¼‚å¸¸ï¼š{str(e)}")
            self.status.config(text="ä»¿çœŸå¤±è´¥")

    def show_results(self, hess, res, amp, dur, selected):
        # æ±‡æ€»æˆæœ¬
        total_purchase = hess.total_purchase
        total_op = hess.total_op
        total_aging = hess.total_aging
        total_fuel = hess.total_fuel
        total_cost = hess.total_cost
        net_cost = hess.net_cost  # ç­‰äºtotal_cost

        # å„è®¾å¤‡æŒ‡æ ‡
        dev_cost = {}
        dev_charge = {}
        dev_discharge = {}
        dev_avg_p = {}
        dev_max_p = {}
        dev_aging = {}

        for dev in hess.devices:
            p = res['device_power'][dev.name]
            c = res['device_cost'][dev.name]
            aging = res['device_aging_cost'][dev.name]
            dev_cost[dev.name] = np.sum(c)
            dev_aging[dev.name] = np.sum(aging)
            dev_charge[dev.name] = -np.sum(p[p < 0]) * 0.1 / 3600
            dev_discharge[dev.name] = np.sum(p[p > 0]) * 0.1 / 3600
            dev_avg_p[dev.name] = np.mean(np.abs(p))
            dev_max_p[dev.name] = np.max(np.abs(p))

        # è„‰å†²æœŸé—´åŠŸç‡åˆ†é…å æ¯”
        mask = (res['time'] >= 10) & (res['time'] < 10 + dur)
        pulse_power = {}
        for dev in hess.devices:
            avg = np.mean(np.abs(res['device_power'][dev.name][mask]))
            if avg > 0.01:
                pulse_power[dev.name] = avg

        win = tk.Toplevel(self.root)
        win.title("è„‰å†²å¹³æ»‘ä»¿çœŸè¯¦ç»†ç»“æœ")
        win.geometry("900x700")

        text = tk.Text(win, wrap='word', font=('å¾®è½¯é›…é»‘', 10))
        scroll = tk.Scrollbar(win, command=text.yview)
        text.config(yscrollcommand=scroll.set)
        text.pack(side='left', fill='both', expand=True)
        scroll.pack(side='right', fill='y')

        text.insert('end', "="*90 + "\n")
        text.insert('end', "â˜… æ··åˆå‚¨èƒ½ç³»ç»Ÿè„‰å†²å¹³æ»‘ä»¿çœŸç»“æœï¼ˆç»æµåˆ†é… + é«˜ç²¾åº¦è·Ÿè¸ª + éšæœºè§„åˆ’ï¼‰ â˜…\n")
        text.insert('end', "="*90 + "\n\n")
        text.insert('end', f"è„‰å†²å¹…å€¼: {amp:.2f} MW\n")
        text.insert('end', f"è„‰å†²æŒç»­æ—¶é—´: {dur:.2f} s\n\n")

        text.insert('end', "ã€éšæœºè§„åˆ’è®¾ç½®ã€‘\n")
        text.insert('end', f"  å¯ç”¨éšæœºè§„åˆ’: {hess.mpc.stochastic}\n")
        if hess.mpc.stochastic:
            text.insert('end', f"  åœºæ™¯æ•°é‡: {hess.mpc.n_scenarios}\n")
            text.insert('end', f"  é¢„æµ‹è¯¯å·®æ ‡å‡†å·®: {hess.mpc.uncertainty_std*100:.1f}%\n")
        text.insert('end', "\n")

        text.insert('end', "ã€å‚¨èƒ½è®¾å¤‡é…ç½®ã€‘æ€»åŠŸç‡20MW / æ€»å®¹é‡480MWh\n")
        for name in selected:
            spec = hess.device_specs[name]['class']
            tmp_dev = spec()
            text.insert('end', f"  {name}: åŠŸç‡ {tmp_dev.power_rating:.1f} MW, å®¹é‡ {tmp_dev.capacity:.1f} MWh, "
                               f"è¾¹é™…æˆæœ¬ {tmp_dev.marginal_cost:.2f} å…ƒ/MW/h\n")
        text.insert('end', "\n")

        # å¹³æ»‘æ€§èƒ½
        rmse = np.sqrt(np.mean((res['load'] - res['smoothed_load'])**2))
        max_deviation = np.max(np.abs(res['load'] - res['smoothed_load']))
        text.insert('end', "ã€å¹³æ»‘æ€§èƒ½ã€‘\n")
        text.insert('end', f"  å¹³æ»‘åè´Ÿè·ä¸åŸå§‹è´Ÿè· RMSE: {rmse:.4f} MW\n")
        text.insert('end', f"  æœ€å¤§ç¬æ—¶åå·®: {max_deviation:.4f} MW (ç”µç½‘æ‰¿æ‹…)\n")
        text.insert('end', f"  æ€»åå·®èƒ½é‡: {np.sum(np.abs(res['load'] - res['smoothed_load'])) * 0.1 / 3600:.2f} MWh\n\n")

        text.insert('end', "ã€ç»æµæ€§æŒ‡æ ‡ (å…ƒ)ã€‘\n")
        text.insert('end', f"  è´­ç”µæ”¯å‡º: {total_purchase:,.2f}\n")
        text.insert('end', f"  è¿ç»´æˆæœ¬: {total_op:,.2f}\n")
        text.insert('end', f"  è€åŒ–æˆæœ¬: {total_aging:,.2f}\n")
        text.insert('end', f"  ç‡ƒæ–™æˆæœ¬: {total_fuel:,.2f}\n")
        text.insert('end', f"  â†’ æ€»æˆæœ¬: {total_cost:,.2f}\n")
        # å”®ç”µæ”¶å…¥å·²ç§»é™¤
        text.insert('end', f"  â†’ å‡€æˆæœ¬: {net_cost:,.2f}\n\n")

        text.insert('end', "ã€å„è®¾å¤‡æˆæœ¬æ„æˆã€‘\n")
        text.insert('end', f"{'è®¾å¤‡åç§°':<16} {'è¿ç»´æˆæœ¬':<12} {'è€åŒ–æˆæœ¬':<12} {'ç‡ƒæ–™æˆæœ¬':<12} {'æ€»æˆæœ¬':<12}\n")
        text.insert('end', "-"*70 + "\n")
        for dev in hess.devices:
            op_sum = np.sum(res['device_op_cost'][dev.name])
            aging_sum = np.sum(res['device_aging_cost'][dev.name])
            fuel_sum = np.sum(res['device_fuel_cost'][dev.name])
            total_dev = op_sum + aging_sum + fuel_sum
            text.insert('end', f"{dev.name:<16} {op_sum:<12.2f} {aging_sum:<12.2f} {fuel_sum:<12.2f} {total_dev:<12.2f}\n")
        text.insert('end', "\n")

        text.insert('end', "ã€è„‰å†²æœŸé—´åŠŸç‡åˆ†é…ç­–ç•¥ (è¾¹é™…æˆæœ¬ä¼˜å…ˆ + é¢‘æ®µåˆ†é…)ã€‘\n")
        total_pulse_power = sum(pulse_power.values())
        for name, avg in pulse_power.items():
            ratio = avg / total_pulse_power * 100 if total_pulse_power > 0 else 0
            text.insert('end', f"  {name}: {avg:.3f} MW ({ratio:.1f}%)\n")
        text.insert('end', "\n")

        text.insert('end', "ã€å„è®¾å¤‡å……æ”¾ç”µç»Ÿè®¡ã€‘\n")
        text.insert('end', f"{'è®¾å¤‡åç§°':<16} {'å……ç”µé‡(MWh)':<12} {'æ”¾ç”µé‡(MWh)':<12} "
                           f"{'å¹³å‡åŠŸç‡(MW)':<12} {'æœ€å¤§åŠŸç‡(MW)':<12}\n")
        text.insert('end', "-"*70 + "\n")
        for dev in hess.devices:
            text.insert('end', f"{dev.name:<16} {dev_charge[dev.name]:<12.4f} {dev_discharge[dev.name]:<12.4f} "
                               f"{dev_avg_p[dev.name]:<12.4f} {dev_max_p[dev.name]:<12.4f}\n")
        text.insert('end', "\n")

        text.insert('end', "ã€è¯¦ç»†è¾¹ç•Œçº¦æŸã€‘\n")
        text.insert('end', "  â€¢ ç”µå‚é¢å®šåŠŸç‡: 13 MWï¼Œå®é™…æ’å‘ 10 MW\n")
        text.insert('end', "  â€¢ å‚¨èƒ½ç³»ç»Ÿæ€»åŠŸç‡ä¸Šé™: 20 MW (å·²æ»¡é…)\n")
        text.insert('end', "  â€¢ å‚¨èƒ½ç³»ç»Ÿæ€»å®¹é‡: 480 MWh\n")
        text.insert('end', "  â€¢ å„è®¾å¤‡SOCå®‰å…¨åŒºé—´: [0.1, 0.9] (è¶Šç•Œè‡ªåŠ¨é™åŠŸç‡ï¼Œç›‘æ§çº¢è‰²é¢„è­¦)\n")
        text.insert('end', "  â€¢ åˆå§‹SOCæé«˜è‡³0.8ï¼Œç¡®ä¿è„‰å†²æ”¾ç”µèƒ½åŠ›\n")
        text.insert('end', "  â€¢ è„‰å†²å¹…å€¼ä¸Šé™: 20 MWï¼ŒæŒç»­æ—¶é—´ä¸Šé™: 20 s\n")
        text.insert('end', "  â€¢ åˆ†æ—¶ç”µä»·(å—äº¬å†¬å­£å·¥å•†ä¸š): ä½è°·0.21ã€å¹³æ®µ0.62ã€é«˜å³°1.12 å…ƒ/kWh\n")
        text.insert('end', "  â€¢ å¤©ç„¶æ°”ä»·æ ¼: 3.6 å…ƒ/mÂ³ (å‹ç¼©ç©ºæ°”å‚¨èƒ½)\n")
        text.insert('end', "  â€¢ éçº¿æ€§è€åŒ–æˆæœ¬: åŠŸç‡^1.8 + æ”¾ç”µæ·±åº¦å½±å“\n")
        text.insert('end', "  â€¢ åŠŸç‡åˆ†é…ç­–ç•¥: è¶…çº§ç”µå®¹/é£è½®ä¼˜å…ˆæ‰¿æ‹…é«˜é¢‘ï¼Œå…¶ä»–è®¾å¤‡æŒ‰è¾¹é™…æˆæœ¬è¡¥å……\n")
        text.insert('end', "\n")

        text.insert('end', "ã€ç»“è®ºã€‘è„‰å†²å·²è¢«é«˜åº¦å¹³æ»‘ï¼Œå¹³æ»‘åè´Ÿè·ä¸åŸå§‹è´Ÿè·é«˜åº¦é‡åˆï¼Œç¬¦åˆç»æµè°ƒåº¦åŸåˆ™ã€‚\n")
        text.config(state='disabled')

        tk.Button(win, text="ğŸ“Š æ˜¾ç¤ºè¯¦ç»†ç‰¹æ€§æ›²çº¿(åŒ…å«æ‰€æœ‰è¦æ±‚å›¾å½¢)",
                  command=lambda: self.plot_all(hess, res),
                  bg="blue", fg="white", font=("å¾®è½¯é›…é»‘", 12)).pack(pady=12)

    def plot_all(self, hess, res):
        """ç»˜åˆ¶æ‰€æœ‰è¦æ±‚çš„å›¾å½¢ï¼Œæ·»åŠ å¼‚å¸¸æ•è·é¿å…å› ä¸ªåˆ«è®¾å¤‡ç¼ºå¤±å¯¼è‡´ç»˜å›¾å¤±è´¥"""
        try:
            plt.figure(figsize=(18, 16))  # è°ƒæ•´ä¸ºé€‚ä¸­å°ºå¯¸
            plt.rcParams['font.sans-serif'] = ['SimHei']

            # 1. è„‰å†²å¹³æ»‘æ•ˆæœå¯¹æ¯” (åŸå§‹è´Ÿè· vs å¹³æ»‘åè´Ÿè·)
            plt.subplot(4, 4, 1)
            plt.plot(res['time'], res['load'], 'r-', lw=2, label='åŸå§‹è´Ÿè·')
            plt.plot(res['time'], res['smoothed_load'], 'b--', lw=2, label='å¹³æ»‘åè´Ÿè·(ç”µå‚+å‚¨èƒ½)')
            plt.plot(res['time'], res['plant'], 'g-', lw=1.5, label='ç”µå‚å‡ºåŠ›(10MW)')
            plt.fill_between(res['time'], res['load'], res['smoothed_load'], alpha=0.25, color='gray')
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('åŠŸç‡ (MW)', fontsize=10)
            plt.title('è„‰å†²å¹³æ»‘æ•ˆæœå¯¹æ¯” (é«˜åº¦é‡åˆ)', fontsize=12)
            plt.legend(fontsize=8)
            plt.grid(True, alpha=0.3)

            # 2. è„‰å†²æœŸé—´åŠŸç‡åˆ†é…é¥¼å›¾
            plt.subplot(4, 4, 2)
            mask = (res['time'] >= 10) & (res['time'] < 10 + res['pulse_dur'])
            pulse_power = {}
            for dev in hess.devices:
                avg = np.mean(np.abs(res['device_power'][dev.name][mask]))
                if avg > 0.05:
                    pulse_power[dev.name] = avg
            if pulse_power:
                labels = list(pulse_power.keys())
                sizes = list(pulse_power.values())
                plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90,
                        textprops={'fontsize': 8})
                plt.title('è„‰å†²æœŸé—´åŠŸç‡åˆ†é…ç­–ç•¥', fontsize=12)

            # 3. å„è®¾å¤‡ç”µæµéšæ—¶é—´å˜åŒ– (ç¼“æ…¢æ¸å˜)
            plt.subplot(4, 4, 3)
            for dev in hess.devices:
                current_smooth = gaussian_filter1d(res['device_current'][dev.name], sigma=4)
                plt.plot(res['time'], current_smooth, label=dev.name, linewidth=1.5)
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('ç”µæµ (A)', fontsize=10)
            plt.title('å„è®¾å¤‡ç”µæµå˜åŒ– (è¶…å¼ºæ»¤æ³¢, æ— è·³å˜)', fontsize=12)
            plt.legend(fontsize=7)
            plt.grid(True, alpha=0.3)

            # 4. å„è®¾å¤‡ç”µå‹éšæ—¶é—´å˜åŒ– (ç¼“æ…¢æ¸å˜)
            plt.subplot(4, 4, 4)
            for dev in hess.devices:
                voltage_smooth = gaussian_filter1d(res['device_voltage'][dev.name], sigma=4)
                plt.plot(res['time'], voltage_smooth, label=dev.name, linewidth=1.5)
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('ç”µå‹ (V)', fontsize=10)
            plt.title('å„è®¾å¤‡ç”µå‹å˜åŒ– (è¶…å¼ºæ»¤æ³¢, æ— è·³å˜)', fontsize=12)
            plt.legend(fontsize=7)
            plt.grid(True, alpha=0.3)

            # 5. è¶…çº§ç”µå®¹å™¨èƒ½é‡-ç”µå‹å…³ç³»
            plt.subplot(4, 4, 5)
            sc = next((d for d in hess.devices if 'è¶…çº§ç”µå®¹' in d.name), None)
            if sc:
                energy_kWh = res['device_energy'][sc.name] * 1000
                voltage = res['device_voltage'][sc.name]
                plt.scatter(energy_kWh, voltage, c=res['time'], cmap='viridis', alpha=0.7, s=10)
                plt.xlabel('å‚¨å­˜èƒ½é‡ (kWh)', fontsize=10)
                plt.ylabel('ç”µå‹ (V)', fontsize=10)
                plt.title('è¶…çº§ç”µå®¹å™¨èƒ½é‡-ç”µå‹å…³ç³»', fontsize=12)
                plt.colorbar(label='æ—¶é—´ (ç§’)')
                plt.grid(True, alpha=0.3)

            # 6. é”‚ç”µæ± èƒ½é‡-ç”µæµå…³ç³»
            plt.subplot(4, 4, 6)
            bess = next((d for d in hess.devices if 'é”‚ç”µæ± ' in d.name), None)
            if bess:
                energy_kWh = res['device_energy'][bess.name] * 1000
                current_kA = res['device_current'][bess.name] / 1000
                plt.scatter(energy_kWh, current_kA, c=res['time'], cmap='plasma', alpha=0.7, s=10)
                plt.xlabel('å‚¨å­˜èƒ½é‡ (kWh)', fontsize=10)
                plt.ylabel('ç”µæµ (kA)', fontsize=10)
                plt.title('é”‚ç”µæ± å‚¨èƒ½èƒ½é‡-ç”µæµå…³ç³»', fontsize=12)
                plt.colorbar(label='æ—¶é—´ (ç§’)')
                plt.grid(True, alpha=0.3)

            # 7. é£è½®å‚¨èƒ½èƒ½é‡-ç”µå‹å…³ç³»
            plt.subplot(4, 4, 7)
            fess = next((d for d in hess.devices if 'é£è½®' in d.name), None)
            if fess:
                energy_kWh = res['device_energy'][fess.name] * 1000
                voltage = res['device_voltage'][fess.name]
                plt.scatter(energy_kWh, voltage, c=res['time'], cmap='cool', alpha=0.7, s=10)
                plt.xlabel('å‚¨å­˜èƒ½é‡ (kWh)', fontsize=10)
                plt.ylabel('ç”µå‹ (V)', fontsize=10)
                plt.title('é£è½®å‚¨èƒ½èƒ½é‡-ç”µå‹å…³ç³»', fontsize=12)
                plt.colorbar(label='æ—¶é—´ (ç§’)')
                plt.grid(True, alpha=0.3)

            # 8. è¶…å¯¼ç£å‚¨èƒ½èƒ½é‡-ç”µæµå…³ç³»
            plt.subplot(4, 4, 8)
            smes = next((d for d in hess.devices if 'è¶…å¯¼ç£' in d.name), None)
            if smes:
                energy_kWh = res['device_energy'][smes.name] * 1000
                current = res['device_current'][smes.name]
                plt.scatter(energy_kWh, current, c=res['time'], cmap='magma', alpha=0.7, s=10)
                plt.xlabel('å‚¨å­˜èƒ½é‡ (kWh)', fontsize=10)
                plt.ylabel('ç”µæµ (A)', fontsize=10)
                plt.title('è¶…å¯¼ç£å‚¨èƒ½èƒ½é‡-ç”µæµå…³ç³»', fontsize=12)
                plt.colorbar(label='æ—¶é—´ (ç§’)')
                plt.grid(True, alpha=0.3)

            # 9. å‹ç¼©ç©ºæ°”å‚¨èƒ½èƒ½é‡-ç”µå‹å…³ç³»
            plt.subplot(4, 4, 9)
            caes = next((d for d in hess.devices if 'å‹ç¼©ç©ºæ°”' in d.name), None)
            if caes:
                energy_kWh = res['device_energy'][caes.name] * 1000
                voltage = res['device_voltage'][caes.name]
                plt.scatter(energy_kWh, voltage, c=res['time'], cmap='winter', alpha=0.7, s=10)
                plt.xlabel('å‚¨å­˜èƒ½é‡ (kWh)', fontsize=10)
                plt.ylabel('ç”µå‹ (V)', fontsize=10)
                plt.title('å‹ç¼©ç©ºæ°”å‚¨èƒ½èƒ½é‡-ç”µå‹å…³ç³»', fontsize=12)
                plt.colorbar(label='æ—¶é—´ (ç§’)')
                plt.grid(True, alpha=0.3)

            # 10. å‚¨èƒ½æ€»åŠŸç‡ä¸ç”µç½‘äº¤äº’ï¼ˆç°åœ¨ç”µç½‘åŠŸç‡éè´Ÿï¼‰
            plt.subplot(4, 4, 10)
            plt.plot(res['time'], res['total_ess'], 'purple', lw=2, label='å‚¨èƒ½æ€»åŠŸç‡')
            plt.plot(res['time'], res['grid_power'], 'orange', lw=1.5, label='ç”µç½‘è´­ç”µåŠŸç‡')
            plt.axhline(0, color='black', ls='--', alpha=0.5)
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('åŠŸç‡ (MW)', fontsize=10)
            plt.title('å‚¨èƒ½æ€»åŠŸç‡ä¸ç”µç½‘è´­ç”µ', fontsize=12)
            plt.legend(fontsize=8)
            plt.grid(True, alpha=0.3)

            # 11. å„è®¾å¤‡SOCå˜åŒ–
            plt.subplot(4, 4, 11)
            for dev in hess.devices:
                plt.plot(res['time'], res['device_soc'][dev.name], label=dev.name, linewidth=1.5)
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('SOC', fontsize=10)
            plt.title('å„è®¾å¤‡è·ç”µçŠ¶æ€', fontsize=12)
            plt.legend(fontsize=7)
            plt.grid(True, alpha=0.3)

            # 12. å®æ—¶å¯å……æ”¾ç”µèƒ½é‡
            plt.subplot(4, 4, 12)
            for dev in hess.devices:
                soc_arr = res['device_soc'][dev.name]
                chargeable = (0.9 - soc_arr) * dev.capacity
                dischargeable = (soc_arr - 0.1) * dev.capacity
                plt.plot(res['time'], chargeable, '--', lw=1, label=f'{dev.name}å¯å……')
                plt.plot(res['time'], dischargeable, '-', lw=1, label=f'{dev.name}å¯æ”¾')
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('èƒ½é‡ (MWh)', fontsize=10)
            plt.title('å®æ—¶å¯å……æ”¾ç”µèƒ½é‡', fontsize=12)
            plt.legend(fontsize=6, loc='upper right')
            plt.grid(True, alpha=0.3)

            # 13. è´­ç”µè´¹ç”¨ï¼ˆå”®ç”µå·²ç§»é™¤ï¼‰
            plt.subplot(4, 4, 13)
            plt.plot(res['time'], res['grid_purchase'], 'r-', lw=1.5, label='è´­ç”µæ”¯å‡º')
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('é‡‘é¢ (å…ƒ)', fontsize=10)
            plt.title('ç”µç½‘è´­ç”µè´¹ç”¨', fontsize=12)
            plt.legend(fontsize=8)
            plt.grid(True, alpha=0.3)

            # 14. å‚¨èƒ½å‡ºåŠ›å †å é¢ç§¯å›¾
            plt.subplot(4, 4, 14)
            times = res['time']
            pos_data = []
            neg_data = []
            labels = []
            for dev in hess.devices:
                p = res['device_power'][dev.name]
                pos_data.append(np.maximum(p, 0))
                neg_data.append(np.minimum(p, 0))
                labels.append(dev.name)
            plt.stackplot(times, *pos_data, labels=labels, alpha=0.8, baseline='zero')
            plt.stackplot(times, *neg_data, alpha=0.8, baseline='zero')
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('åŠŸç‡ (MW)', fontsize=10)
            plt.title('å‚¨èƒ½å‡ºåŠ›å †å  (æ­£:æ”¾ç”µ,è´Ÿ:å……ç”µ)', fontsize=12)
            plt.legend(loc='upper right', fontsize=6)
            plt.grid(True, alpha=0.3)

            # 15. å„è®¾å¤‡è¾¹é™…æˆæœ¬å¯¹æ¯” (æŸ±çŠ¶å›¾)
            plt.subplot(4, 4, 15)
            names = [dev.name for dev in hess.devices]
            costs = [dev.marginal_cost for dev in hess.devices]
            plt.bar(names, costs, color='skyblue')
            plt.xlabel('è®¾å¤‡', fontsize=10)
            plt.ylabel('è¾¹é™…æˆæœ¬ (å…ƒ/MW/h)', fontsize=10)
            plt.title('å„è®¾å¤‡è¾¹é™…æˆæœ¬å¯¹æ¯”', fontsize=12)
            plt.xticks(rotation=15, fontsize=8)

            # 16. è„‰å†²å¹³æ»‘æ•ˆæœå±€éƒ¨æ”¾å¤§ (10~10+dur)
            plt.subplot(4, 4, 16)
            mask_local = (res['time'] >= 8) & (res['time'] <= 12 + res['pulse_dur'])
            plt.plot(res['time'][mask_local], res['load'][mask_local], 'r-', lw=2, label='åŸå§‹è´Ÿè·')
            plt.plot(res['time'][mask_local], res['smoothed_load'][mask_local], 'b--', lw=2, label='å¹³æ»‘åè´Ÿè·')
            plt.xlabel('æ—¶é—´ (ç§’)', fontsize=10)
            plt.ylabel('åŠŸç‡ (MW)', fontsize=10)
            plt.title('è„‰å†²å±€éƒ¨æ”¾å¤§', fontsize=12)
            plt.legend(fontsize=8)
            plt.grid(True, alpha=0.3)

            plt.tight_layout()
            plt.show()
        except Exception as e:
            print(f"ç»˜å›¾è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: {e}")
            messagebox.showerror("ç»˜å›¾é”™è¯¯", f"æ— æ³•æ˜¾ç¤ºå›¾å½¢ï¼Œé”™è¯¯ä¿¡æ¯ï¼š{e}")


# ==================== å…­ã€ä¸»ç¨‹åº ====================
def main():
    if not PYWT_AVAILABLE:
        print("âš ï¸ PyWavelets æœªå®‰è£…ï¼Œå°æ³¢åˆ†è§£ä½¿ç”¨ç§»åŠ¨å¹³å‡è¿‘ä¼¼ã€‚")
    app = HESSGUI()
    app.root.mainloop()

if __name__ == '__main__':
    main()
